
// Shot Manager
// abxShots.mel
//
// Version 0.8.118
// Created by J. Adam Burke adam@adamburke.net
// Modified : 13 Apr 2012

// DESCRIPTION:
// Shot Manager is a Scene File management system for shot-specific scene files such as animation scenes, layout, lighting, and fx.

// USAGE:
// Source script and call "abxShots;"
// assign to shelf or hotkey as preferred


// Â©2012 J. Adam Burke 
// http://www.adamburke.net

// KNOWN ISSUES
// 


// TODO
// * Check camera film gate to make sure it matches the project defaults
// * Prevent File Master from looping on modified detection
// * Add tools to clear lgt ref files of setAttr on keyable controls
// * handle unknown node errors more gracefully than maya does
// * add safe file importing methods
// 

//*eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/production/abxAssets.mel\"");
//*eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Lighting/abxExportShaderMel.mel\"");
//*eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/production/callMayaBG.mel\"");
//*eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/production/abxShotBot.mel\"");
//*eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Misc/autoCache.mel\"");

// CONFIGURE global vars
//global string $abxShots_ShotNamePattern = "<seq>_<shot>"


global string $abxShots_SceneFileNamePattern = "<shotName>_<dept>_<version>.<ext>";
global string $abxShots_MasterSceneFileNamePattern = "<shotName>_<dept>_MASTER.<ext>";
global string $abxShots_ShotsFolder = "";
global string $abxShots_PrevisFolder = "Previs";
global string $abxShots_AnimFolder = "animation";
global string $abxShots_FXFolder = "dynamics";
global string $abxShots_LgtFolder = "lighting";
global string $abxShots_MDLFolder = "modeling";
global string $abxShots_CamFolder = "camera";
global string $abxShots_workFolder = "";
global string $abxShots_masterFolder = "_MASTER";

global string $abxShots_versionRegEx = "[a-z][0-9][0-9]";
global string $abxShots_ShotNameRegEx = "SH[0-9][0-9][0-9]_.*";

global string $abxShots_AssetsFolder = "scenes/ASSETS/";



global proc abxShotsLite () {

	global string $abxShots_ShotsFolder;
	global string $abxShots_PrevisFolder;

	string $abxShotsVersionString = "1.5b";
	global int $dbExists = 0;
	if (`exists pprainbow`) $dbExists = pprainbow();
	global int $jobLoaded = 0;
	if ($dbExists) $jobLoaded = rain_loadJob("");
	//*eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/production/abxShotBot.mel\"");

	if (!`window -exists abxShotsWindow`)  {
		window -t ("Shot Manager v" + $abxShotsVersionString + "") -width 710 -height 600 -menuBar true abxShotsWindow;

		menu -label "File" -tearOff 1;
			menuItem -en 1 -sm 1 -label "New Scene";
				menuItem -l "New Anm Scene" -c "ppDoNewScene (\"anm\")";
				menuItem -divider true ;
				menuItem -l "New Lgt Scene" -c "ppDoNewScene (\"lgt\")";
				menuItem -divider true ;
				menuItem -l "New Empty Scene" -c "ppDoNewScene \"empty\"";
				menuItem -l "New Rig Scene" -c "ppDoNewScene \"rig\"";
				setParent -menu ..;
			menuItem -en 1 -label "Open Other Scene..." -c "abxShotsOpenOtherFile \"\"";
			menuItem -divider true ;
			menuItem -en 1 -label "Import Scene (Safe)..." -ann "Safely Imports and resolves name clashes even with referenced assets" -c "abxShotsImportOtherFile \"\"";
			menuItem -en 0 -label "Export";
			menuItem -en 0 -label "Export Selected";

			menuItem -en 0 -label "Incremental Save" -c "abxShotsIncrementalSave 0 \"\" \"auto\" \"\" \"\" \"\" \"\"";
			menuItem -en 0 -label "Auto Master Scene" -c "abxShotsMaster 0 \"auto\" \"\" \"\" \"latest\" \"\"";
			menuItem -divider 1;
			menuItem -label "Close" -c "window -e -vis 0 abxShotsWindow";

		menu -label "Project" -tearOff 1;
			menuItem -label "Set Project" -c ("if (`exists abxProject`==0) source \""+`getenv MAYA_PPTOOLS`+"/scripts/Production/abxProject.mel\";if (`exists abxProject`) abxProject"); 
			menuItem -label "Asset Manager" -c ("if (`exists abxAssets`==0) source \""+`getenv MAYA_PPTOOLS`+"/scripts/Production/abxAssets.mel\";if (`exists abxAssets`) abxAssets");

			setParent -menu ..;
		menu -label "Create" -tearOff 1;
			menuItem -en 1 -label "New Shot..." -c "abxShotsShowNewShotUI `tabLayout -q -st abxShotsListTabLyt`" ;
			menuItem -en 1 -label "New Sequence..." -c "abxShotsNewSequence(`abxShotsGetActiveShotFolder`);";

		menu -label "View" -tearOff 1;
			menuItem -en 1 -label "Refresh" -c "abxShotsPopulateList \"_ALL_SHOTS\" abxShotsList;abxShotsPopulateList \"_PREVIS\" abxPrevisList;abxShotsPopulateList \"_ALL_SHOTS\" abxShotGroupsList;abxShotsShowLatestShot `file -q -sn` ";

		menu -label "Tools" -tearOff 1;
			menuItem -en 1 -label "Check for Required Props" -c "abxAssetsCheckForProps({\"\"});";
			menuItem -en 1 -label "Update Prop Instances" -c "abxAssetsUpdatePropInstances({\"\"},0);";
			menuItem -en 1 -label "Rebuild All Prop Instances" -c "abxAssetsUpdatePropInstances({\"\"},1);";
			menuItem -en 1 -label "Check For Reference Updates" -c "abxShotsCheckAllRefsForUpdate";
			menuItem -en 1 -label "Check for Name Clashes" -c ("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Misc/checkNameClash.mel\";checkNameClash;");
			menuItem -en 1 -label "Gather Audio to Server" -c "abxShotsGatherAudio";
			menuItem -en 1 -label "ANM Master Procedures" -sm true;
				menuItem -en 1 -label "Clear Failed Edits on Refs" -c "abxShotsClearFailedEdits";
				menuItem -en 1 -label "Check for Shader Overrides on Refs" -c "abxShotsRemoveGeoEdits 0";
			    menuItem -en 1 -label "Restore Deformed Geo Shader Assignments" -c "abxShotsRestoreDeformedShader {} 0";
				menuItem -en 1 -label "Swap Proxy Assets to Full" -c "abxShotsProxyToFull";
				menuItem -en 1 -label "Check For Deferred Refs" -c "abxShotsCheckDeferredRefs";
				menuItem -en 1 -label "Delete All Render Layers" -c "abxShotsDeleteAllRenderLayers";
			setParent -menu ..;
			menuItem -en 1 -label "Lighting Tools" -sm true;
				menuItem -en 1 -label "Clear Failed Edits on Refs" -c "abxShotsClearFailedEdits";
				menuItem -en 1 -label "Check For Reference Updates" -c "abxShotsCheckAllRefsForUpdate";
				menuItem -en 1 -label "Check For Cloth/Hair Cache" -c ("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Misc/autoCache.mel\";autoCacheFindLatest \"clothSim\";autoCacheFindLatest \"hairSim\"");
			menuItem -en 1 -label "Fix Refs to Neon" -c "abxShotsFixStoryNeonRefs";
			setParent -menu ..;

		menu -label "Help";
			menuItem -l "Wiki" -c "system \"start \\\"C:/Program Files (x86)/Mozilla Firefox/firefox.exe\\\" \\\"\\\"\"";

		formLayout abxShotsWindowMainForm;

		
		paneLayout -configuration "vertical2" abxShotsMainPane;
		tabLayout -imw 0 -imh 0 -cc "abxShotsListTabChange"  abxShotsListTabLyt;
		formLayout -p abxShotsListTabLyt abxPrevisLibForm;
		formLayout -p abxShotsListTabLyt abxShotsLibForm;
		formLayout -p abxShotsListTabLyt abxShotGroupsLibForm;
		
		
		formLayout -p abxShotsMainPane abxShotsDetailsForm;

		setParent abxPrevisLibForm;
		string $previsLister = `treeView -elc abxShotsEditShotLabelCB -numberOfButtons 1 -pc 1 "abxShotsTreeViewButtonA" -adr false -abr true -enk true -idc "abxShotsTreeViewDblClk" -sc "abxShotsSetActiveShot " -cmc "abxShotsUpdatePrevisMenu" -ecc "abxShotsExpandWrapper" abxPrevisList`;
		string $pMenu = `popupMenu -parent $previsLister abxPrevisPopupMenu`;

		setParent abxShotsLibForm;
		string $shotLister = `treeView -elc abxShotsEditShotLabelCB -numberOfButtons 4 -pc 1 "abxShotsTreeViewButtonA" -pc 2 "abxShotsTreeViewButtonF" -pc 3 "abxShotsTreeViewButtonL" -pc 4 "abxShotsTreeViewButtonC" -adr false -abr true -enk true -idc "abxShotsTreeViewDblClk" -sc "abxShotsSetActiveShot " -cmc "abxShotsUpdateMenu" -ecc "abxShotsExpandWrapper" abxShotsList`;
		string $pMenu2 = `popupMenu -parent $shotLister abxShotsPopupMenu`;	

		setParent abxShotGroupsLibForm;
		string $shotGroupsLister = `treeView -elc abxShotsEditShotLabelCB -numberOfButtons 4 -pc 1 "abxShotsTreeViewButtonA" -pc 2 "abxShotsTreeViewButtonF" -pc 3 "abxShotsTreeViewButtonL" -pc 4 "abxShotsTreeViewButtonC" -adr false -abr true -enk true -idc "abxShotsTreeViewDblClk" -sc "abxShotsSetActiveShot " -cmc "abxShotsUpdateShotGroupsMenu" -ecc "abxShotsExpandWrapper" abxShotGroupsList`;
		string $pMenu3 = `popupMenu -parent $shotGroupsLister abxShotGroupsPopupMenu`;			

		abxShotsBuildMenu  $previsLister;
		abxShotsBuildMenu  $shotLister;
		abxShotsBuildMenu  $shotGroupsLister;

		//evalDeferred ("abxShotsPopulateList \"_PREVIS\" \"abxPrevisList\"");
		evalDeferred ("abxShotsPopulateList \""+$abxShots_ShotsFolder+"\" \"abxShotsList\"");
		//evalDeferred ("abxShotsPopulateList \"_ALL_SHOTS\" \"abxShotGroupsList\"");

		treeView -e -addItem "Loading..." "" "abxShotsList";
		treeView -e -addItem "Loading..." "" "abxPrevisList";
		treeView -e -addItem "Loading..." "" "abxShotGroupsList";

		formLayout -e
        		-af abxShotsMainPane top 0
        		-af abxShotsMainPane left 0
        		-af abxShotsMainPane bottom 0
        		-af abxShotsMainPane right 0
        		abxShotsWindowMainForm;

		formLayout -e 
			-af $previsLister left 2
			-af $previsLister top 2
			-af $previsLister right 0
			-af $previsLister bottom 2
			abxPrevisLibForm;

		formLayout -e 
			-af $shotLister left 2
			-af $shotLister top 2
			-af $shotLister right 0
			-af $shotLister bottom 2
			abxShotsLibForm;

		formLayout -e 
			-af $shotGroupsLister left 2
			-af $shotGroupsLister top 2
			-af $shotGroupsLister right 0
			-af $shotGroupsLister bottom 2
			abxShotGroupsLibForm;

		tabLayout -e 
			-tabLabel abxPrevisLibForm "Previs"
			-tabLabel abxShotsLibForm "Shots"
			-tabLabel abxShotGroupsLibForm "Lgt Groups"
			abxShotsListTabLyt;

		tabLayout -e -sti 2 abxShotsListTabLyt;
		
		paneLayout -e -paneSize 1 35 100 abxShotsMainPane;

		abxShotsCreateDetailUI;
		
		evalDeferred -lowestPriority ("abxShotsShowLatestShot `file -q -sn`");
		//showWindow abxShotsWindow;
	}

	//window -e  -width 710 -height 600 abxShotsWindow;
	showWindow abxShotsWindow;
}

//abxShotsNumericalSort {"FMV11"," FMV2", "FMV19"," FMV1"}
// sorts the strings based on numerical number ordering (1 comes before 11)
global proc string[] abxShotsNumericalSort(string $inputArray[]){
	string $newArray[];
	//print ("$inputArray size="+size($inputArray)+"\n");
	for ($i=0;$i<size($inputArray);$i++){
		int $index = 0;
		int $numeralA = 0;
		int $numeralB = 0;
		$justNums = `match "[0-9]+" $inputArray[$i]`;
		if ($justNums != "") $numeralA = $justNums;
		$justNums = `match "[0-9]+" $newArray[$index]`;
		if ($justNums != "") $numeralB = $justNums;

		while($numeralA > $numeralB && $index < size($newArray)){
			$index++;
			$justNums = `match "[0-9]+" $newArray[$index]`;
			if ($justNums == "") $numeralB = 0;
			else $numeralB = $justNums;
		}
		//print ("adding "+$inputArray[$i]+" to newArray\n");
		stringArrayInsertAtIndex($index, $newArray, $inputArray[$i]);
	
	}
	return $newArray;
}


// this procedure looks at the latest shot (either currently open shot or the last opened file)
// and tries to automatically select the shot in the shot manager
global proc abxShotsShowLatestShot (string $sceneFilePath) {

		global string $abxShots_ShotsFolder;
	global string $abxShots_PrevisFolder;
	
	string $currentScene = $sceneFilePath;
	
	string $shotNameGuess = "";
	string $shotTakeGuess = "";
	string $shotDeptGuess = "";
	string $shotSubDeptGuess = "";
	string $shotSequenceGuess = "";
	string $shotFolderGuess = "";
	string $extension = `fileExtension $currentScene`;
	string $currentSceneName = `basenameEx $currentScene`;
	
	string $tokenBuffer[];
	tokenize $currentScene "/" $tokenBuffer;
	if (size($tokenBuffer) > 1){
		$subDeptGuess = $tokenBuffer[size($tokenBuffer)-2];
		if (size($tokenBuffer) > 2 ) {
			$shotDeptGuess = tolower($tokenBuffer[size($tokenBuffer)-3]);
			if (size($tokenBuffer) > 3 ) {
				$shotNameGuess = $tokenBuffer[size($tokenBuffer)-4];
				if (size($tokenBuffer) > 4){
					if ($tokenBuffer[size($tokenBuffer)-5] != "_ALL_SHOTS" && $tokenBuffer[size($tokenBuffer)-5] != "_PREVIS"){
						$shotSequenceGuess = $tokenBuffer[size($tokenBuffer)-5];
						if (size($tokenBuffer) > 5){
							if ($tokenBuffer[size($tokenBuffer)-6] == "_ALL_SHOTS" || $tokenBuffer[size($tokenBuffer)-6] == "_PREVIS" ){
								$shotFolderGuess = $tokenBuffer[size($tokenBuffer)-6];
							}	
						}
					}
					else{
						$shotFolderGuess = $tokenBuffer[size($tokenBuffer)-5];
					}
				}
			}
		}
	}
	string $listViewName = "";
	if ($shotFolderGuess == "_PREVIS"){
		// set the shot list view tab to the _PREVIS tab
		tabLayout -e -st "abxPrevisLibForm"  abxShotsListTabLyt;
		$listViewName = "abxPrevisList";
	}
	else if ($shotFolderGuess == "_ALL_SHOTS"){
		tabLayout -e -st "abxShotsLibForm"  abxShotsListTabLyt;
		$listViewName = "abxShotsList";
	}
	else {
		// try the last selected file instead
		return;
	}
	
	//print ("shotSeq="+$shotSequenceGuess+" shotNameGuess="+$shotNameGuess+"\n");
	//print ("listViewName="+$listViewName+"\n");
	if (`treeView -q -ex $listViewName`){
		//print ("listViewExists\n");
		if ($shotSequenceGuess == ""){
			// for the current selected view select the shotName guess
			if (`treeView -q -itemExists $shotNameGuess $listViewName`){
				treeView -e -selectItem $shotNameGuess 1 $listViewName;
				abxShotsSetActiveShot $shotNameGuess 1; 
			}
		}
		else{
			//print ("Auto Selecting Open Shot\n");
			//print ("treeView -q -itemExists "+$shotSequenceGuess+"/"+$shotNameGuess+" "+$listViewName+"\n");
			// for the current shot folder list, expand the sequence and select the seqName/shotname item as selected
			if (`treeView -q -itemExists $shotSequenceGuess $listViewName`){
				treeView -e -expandItem $shotSequenceGuess 1 $listViewName;
				abxShotsExpandWrapper $shotSequenceGuess 1;
			}
			if (`treeView -q -itemExists ($shotSequenceGuess+"/"+$shotNameGuess) $listViewName`){
				treeView -e -selectItem ($shotSequenceGuess+"/"+$shotNameGuess) 1 $listViewName;
				abxShotsSetActiveShot ($shotSequenceGuess+"/"+$shotNameGuess) 1; 
				$shotDeptGuess = `capitalizeString $shotDeptGuess`;
				tabLayout -e -st ("abxShots"+$shotDeptGuess+"FrmLyt") abxShotsDeptTabLyt;
				//evalDeferred ("abxShotsListTabChange ;");
			}
		}
	}
}


// called when a use changes between PREVIS and ALLSHOTS tabs just enables and disables certain UI
global proc abxShotsListTabChange () {

global string $abxShots_ShotsFolder;
global string $abxShots_PrevisFolder;
	
	if (`tabLayout -q -st abxShotsListTabLyt` == "abxPrevisLibForm"){
		if (size(`treeView -q -ch "" abxPrevisList`)<2){
			//treeView -e -addItem "Loading..." "" "abxPrevisList";
			print ("loading previs list\n");
			evalDeferred ("abxShotsPopulateList \""+$abxShots_ShotsFolder+"\" \"abxPrevisList\"");
		}
		if (`formLayout -q -exists abxShotsPreFrmLyt`){
			formLayout -e -en 1 abxShotsPreFrmLyt;
			formLayout -e -en 0 abxShotsAnmFrmLyt;
			formLayout -e -en 0 abxShotsFxFrmLyt;
			formLayout -e -en 0 abxShotsLgtFrmLyt;
			tabLayout -e -st abxShotsPreFrmLyt abxShotsDeptTabLyt;
		}
	}
	else {
		if (`tabLayout -q -st abxShotsListTabLyt` == "abxShotGroupsLibForm"){
			if (size(`treeView -q -ch "" abxShotGroupsList`)<2){
				print ("loading shot_group list\n");
				//treeView -e -addItem "Loading..." "" "abxShotGroupsList";
				evalDeferred ("abxShotsPopulateList \""+$abxShots_ShotsFolder+"\" \"abxShotGroupsList\"");
			}
		}
		if (`formLayout -q -exists abxShotsPreFrmLyt`){
			formLayout -e -en 0 abxShotsPreFrmLyt;
			formLayout -e -en 1 abxShotsAnmFrmLyt;
			formLayout -e -en 1 abxShotsFxFrmLyt;
			formLayout -e -en 1 abxShotsLgtFrmLyt;
			tabLayout -e -st abxShotsAnmFrmLyt abxShotsDeptTabLyt;
		}
	}
}

// create or updates the shot item list
/*
global proc abxShotsListItemRefresh (string $shotPath){

	// parse the $shotPath

	// if the item does not exist
		// if the parent item does not exist
			// create parent item
		// create the item

	// set the properties of the item and update
	// set the color status
	string $shotDetails[] = `abxShotsGetShotDetails $fullname $shotFolder`;
	if (size($shotDetails) > 4){
		//print $shotDetails;
		string $anmStatBuff[];
		int $status = 0;
		if ($shotDetails[6] != "") {
			tokenize $shotDetails[6] "," $anmStatBuff;
			$status = int($anmStatBuff[0]);
		}


		string $setColorCmd = ("treeView -e ");
		$setColorCmd += ("-btc \""+$fullname+"\" 1 "+`abxShotsStatAsColor $status`+" ") ;
		if (size($anmStatBuff)>1)
			$setColorCmd += ("-i \""+$fullname+"\" 1 \""+`abxShotsStageAsLabel $anmStatBuff[1]`+ "\" ");

		$status = 0;
		if ($shotDetails[7] != "") $status = int($shotDetails[7]);
		$setColorCmd += ("-btc \""+$fullname+"\" 2 "+`abxShotsStatAsColor $status`+" ") ;

		$status = 0;
		if ($shotDetails[8] != "") $status = int($shotDetails[8]);
		$setColorCmd += ("-btc \""+$fullname+"\" 3 "+`abxShotsStatAsColor $status`+" ") ;

		$status = 0;
		if ($shotDetails[9] != "") $status = int($shotDetails[9]);
		$setColorCmd += ("-btc \""+$fullname+"\" 4 "+`abxShotsStatAsColor $status`+" ") ;

		$setColorCmd += $listControl;
		eval($setColorCmd);
}
*/

// poulates a treelist control. only loads the first item in list to cut down on server/UI load
global proc abxShotsPopulateList (string $shotFolder, string $listControl) {

	treeView -e -ra $listControl;
	string $projectPath = `workspace -q -rd`;
	string $shotTab = `abxShotsGetActiveShotTab`;

	global string $abxShots_ShotsFolder;
	global string $abxShots_PrevisFolder;
	global string $abxShots_AnimFolder;
	global string $abxShots_FXFolder;
	global string $abxShots_LgtFolder;
	// if its Shot Groups we need to query rainbow
	if ($listControl =="abxShotGroupsList"){
		
		global int $dbExists;
		if ($dbExists && !catchQuiet(python("len(activeJob.lgt_groups)"))){

			int $shotGroupCount = python("len(activeJob.lgt_groups)");
			for ($i=0;$i<$shotGroupCount;$i++){
				string $label = python("activeJob.lgt_groups["+$i+"].name");
				print ("label="+$label+"\n");
				string $itemName = ($i+":"+$label);

				treeView -e -addItem $itemName "" $listControl;
				treeView -e -selectionColor $itemName .8 .8 .8 $listControl;
				treeView -e -ei $itemName 0 $listControl;
				treeView -e -bti $itemName 1 "A" -bti $itemName 2 "F" -bti $itemName 3 "L" -bti $itemName 4 "C" $listControl;
				treeView -e -btc $itemName 1 .2 .2 .2 -btc $itemName 2 .2 .2 .2 -btc $itemName 3 .2 .2 .2 -btc $itemName 4 .2 .2 .2 $listControl;
				treeView -e -font $itemName boldLabelFont $listControl;
				treeView -e -dl $itemName $label $listControl;	


				string $motherShot = python("activeJob.lgt_groups["+$i+"].mother_shot['natural_key']");
				string $tokenBuffer[];
				tokenize $motherShot "_" $tokenBuffer;
				string $seqName = $tokenBuffer[0];
				string $shotItemName = ($i+":"+$seqName+"/"+$motherShot);
				print("adding to" +$listControl+"\n");
				if (!`treeView -q -iex $shotItemName $listControl`){
					treeView -e -addItem $shotItemName $itemName $listControl;
					treeView -e -selectionColor $shotItemName .8 .8 .8 -lbc $shotItemName .24 .24 .24 $listControl;

					treeView -e -bti $shotItemName 1 "" -bti $shotItemName 2 "" -bti $shotItemName 3 "" -bti $shotItemName 4 "" $listControl;
					treeView -e -dl $shotItemName ($motherShot+" (M)") $listControl;
					// set the color status
					string $shotDetails[] = evalEcho("abxShotsGetShotDetails \""+$seqName+"/"+$motherShot+"\" \""+$shotFolder+"\"");

					if (size($shotDetails) > 4){
						//print $shotDetails;
						string $anmStatBuff[];
						int $status = 0;
						if ($shotDetails[6] != "") {
							tokenize $shotDetails[6] "," $anmStatBuff;
							$status = int($anmStatBuff[0]);
						}

						string $setColorCmd = ("treeView -e ");
						$setColorCmd += ("-btc \""+$shotItemName+"\" 1 "+`abxShotsStatAsColor $status`+" ") ;
						if (size($anmStatBuff)>1)
							$setColorCmd += ("-i \""+$shotItemName+"\" 1 \""+`abxShotsStageAsLabel $anmStatBuff[1]`+ "\" ");

						$status = 0;
						if ($shotDetails[7] != "") $status = int($shotDetails[7]);
						$setColorCmd += ("-btc \""+$shotItemName+"\" 2 "+`abxShotsStatAsColor $status`+" ") ;

						$status = 0;
						if ($shotDetails[8] != "") $status = int($shotDetails[8]);
						$setColorCmd += ("-btc \""+$shotItemName+"\" 3 "+`abxShotsStatAsColor $status`+" ") ;

						$status = 0;
						if ($shotDetails[9] != "") $status = int($shotDetails[9]);
						$setColorCmd += ("-btc \""+$shotItemName+"\" 4 "+`abxShotsStatAsColor $status`+" ") ;

						$setColorCmd += $listControl;
						eval($setColorCmd);
					}	
				}			
			}			
		}
	}
	else{

		string $fldPath = ($projectPath+"/scenes/"+$shotFolder+"/");
		if ($shotFolder == "") $fldPath = ($projectPath+"/scenes/");

		string $shotsFolder[] = `getFileList -folder $fldPath`;

		string $sorted[] = abxShotsNumericalSort($shotsFolder);
		//string $sorted[] = abxShotsSort($shotsFolder);
		int $index = 0;

		for ($each in $sorted){

			if (`filetest -d ($fldPath+$each+"/")`){
				//textScrollList -e -append $each $listControl;

				if ($each != ".DS_Store" && $each != "old" && $each != "Styleframe" && $each != "SH###_shot" && $each != "ASSETS" && $each != "RnD" && $each != "Previs"){
					if ($each == "TESTING" && `getenv MODE` == "pub") {
					}
					else{
						// determine if it is a scene subfolder
						string $subFolders[] = `getFileList -folder ($fldPath+$each+"/")`;
						string $sortedSub[] = sort($subFolders);

						int $isShotFolder = 0;
						if (size($sortedSub)>3){
							for ($every in $sortedSub){
								if ($isShotFolder == 0){
									if  ($every == $abxShots_AnimFolder || $every == $abxShots_LgtFolder || $every == $abxShots_FXFolder){
										$isShotFolder = 1;
									}
								}
								else {
									break;
								}
							}
						}

						if ($isShotFolder == 0){
							// create sequence list tiem
							treeView -e -addItem $each "" $listControl;
							treeView -e -selectionColor $each .8 .8 .8 $listControl;
							treeView -e -bti $each 1 "A" -bti $each 2 "F" -bti $each 3 "L" -bti $each 4 "C" $listControl;
							treeView -e -btc $each 1 .2 .2 .2 -btc $each 2 .2 .2 .2 -btc $each 3 .2 .2 .2 -btc $each 4 .2 .2 .2 $listControl;
							treeView -e -ei $each 0 $listControl;
							treeView -e -font $each boldLabelFont $listControl;


							int $foundOne = 0;

							// add a temporary item displaying "LOADING" feedback. this will be hidden when expand item is finished
							string $tmpLoad = ("loading"+$index);
							treeView -e -addItem $tmpLoad $each $listControl;
							treeView -e -dl $tmpLoad "Loading..." $listControl;
							$index++;

						}
						// non sequence shots
						else {
							treeView -e -addItem $each "" $listControl;
							treeView -e -selectionColor $each .8 .8 .8 -lbc $each .2 .2 .2 $listControl;

							treeView -e -bti $each 1 "" -bti $each 2 "" -bti $each 3 "" -bti $each 4 "" $listControl;
							//treeView -e -or $each 1 0 5 $listControl;
							//treeView -e -bto $each 1 true -bto $each 2 true -bto $each 3 true $listControl;
							//treeView -e -btc $each 1 .3 .7 .4 -btc $each 2 .7 .5 .3 -btc $each 3 .7 .3 .3 $listControl;
						}
						if ($shotFolder == $abxShots_PrevisFolder){
							treeView -e -textColor $each .3 .9 .4 $listControl;
						}
					}
				}
			}	
		}
		if (size($sorted) > 0){
			string $sceneName = basenameEx(`file -q -sn`);
			string $sceneShotName = `abxShotsGetSceneShotName $sceneName` ;
			if (stringArrayContains($sceneShotName,$sorted)){
				//evalDeferred("treeView -e -si \""+$sceneShotName+"\" 1 "+$listControl+";abxShotsSetActiveShot \""+$sceneShotName+"\" 1");
			}
			else {
				//evalDeferred("treeView -e -si \""+$sorted[0]+"\" 1 "+$listControl+";abxShotsSetActiveShot \""+$sorted[0]+"\" 1");
			}
		}
	}
}

// wraps the expand function so that it gives immediate feedback while waiting for sequence list to load
global proc int abxShotsExpandWrapper (string $itemName,int $state){
	evalDeferred("abxShotsExpandList(\""+$itemName+"\","+$state+");");
	evalDeferred -lowestPriority("abxShotsExpandListStatus(\""+$itemName+"\","+$state+");");
	
	return 1;
}

// Expands the list by loading the rest of the shots in a sequence for display
global proc int abxShotsExpandList (string $itemName, int $state) {

global string $abxShots_ShotsFolder;
global string $abxShots_PrevisFolder;
	if ($state == 1){
		string $projectPath = `workspace -q -rd`;
		string $shotFolder = `abxShotsGetActiveShotFolder`;
		string $tabName = `abxShotsGetActiveShotTab`;
		string $listControl;
		if ($tabName == "abxShotsLibForm")
			$listControl = "abxShotsList";
		else if ($tabName == "abxPrevisLibForm")
			$listControl = "abxPrevisList";
		else 
			$listControl = "abxShotGroupsList";

		// if the tab is the shot group tab
		if ($listControl == "abxShotGroupsList"){
			global int $dbExists;
			if ($dbExists){
				string $indexToken[];
				tokenize $itemName ":" $indexToken;
				int $index = $indexToken[0];
				// load the shotList in memory
				python("shotList = activeJob.lgt_groups["+$index+"].get_shots()");

				int $shotListCount = python("len(shotList)");
				for ($i=0;$i<$shotListCount;$i++){
					string $shotName = python("shotList["+$i+"].name");

					string $tokenBuffer[];
					tokenize $shotName "_" $tokenBuffer;
					string $seqName = $tokenBuffer[0];
					// add the shot group index number plus the sequence name plus the shotname
					string $shotItemName = ($i+":"+$seqName+"/"+$shotName);
					string $motherShot = python("activeJob.lgt_groups["+$index+"].mother_shot['natural_key']");

					// if the item is not the mother shot (because querying shot group members also returns the mother shot)
					//print ("comparing \""+$shotName+"\" to \""+$motherShot+"\"\n");
					if ($shotName != $motherShot){

						// if the treeview item name does not already exists then add it
						if (!`treeView -q -iex $shotItemName $listControl`){
							treeView -e -addItem $shotItemName $itemName $listControl;
							treeView -e -selectionColor $shotItemName .8 .8 .8 -lbc $shotItemName .2 .2 .2 $listControl;
							treeView -e -bti $shotItemName 1 "" -bti $shotItemName 2 "" -bti $shotItemName 3 "" -bti $shotItemName 4 "" $listControl;
							treeView -e -dl $shotItemName $shotName $listControl;
							
							//if (abxShotsFreshMaster($shotItemName))
							//	treeView -e -or $shotItemName 1 0 3 -orc $shotItemName 1 0 0 $listControl;
							if ($i%2)
								treeView -e -lbc $shotItemName .2 .2 .2 $listControl;
							else 
								treeView -e -lbc $shotItemName .24 .24 .24 $listControl;
						}
					}					
				}
			}

		}
		// if the tab is the ALL_SHOTS or PREVIS tab
		else{

			global string $abxShots_AnimFolder ;
			global string $abxShots_FXFolder;
			global string $abxShots_LgtFolder ;

			string $each = $itemName;

			string $fldPath = ($projectPath+"/scenes/"+$shotFolder+"/");
			if ($shotFolder == "") $fldPath = ($projectPath+"/scenes/");

			string $subFolders[] = `getFileList -folder ($fldPath+$each+"/")`;
			string $sortedSub[] = sort($subFolders);

			int $isShotFolder = 0;
			for ($every in $sortedSub){
				if ($isShotFolder == 0){
					if  ($every == $abxShots_AnimFolder || $every == $abxShots_LgtFolder || $every == $abxShots_FXFolder){
						$isShotFolder = 1;
					}
				}
				else {
					break;
				}
			}
			// remove existing items
			$itemsToRemove = `treeView -q -ch $each $listControl`;
			// index:0 is the actual parent item so we must hide index:1 (the loading... item)
			treeView -e -iv $itemsToRemove[1] false $listControl;
			

			// shots that belong to a sequence

			// load the rest of the items in the sequence when it is expanded
			for ($i=0;$i<size($sortedSub);$i++){
				$every = $sortedSub[$i];
				if (`filetest -d ($fldPath+$each+"/"+$every)` && $sortedSub[$i] != "old"){

					$fullname = ($each+"/"+$every);
					if (!`treeView -q -itemExists $fullname $listControl`){
						treeView -e -addItem $fullname $each $listControl;
						treeView -e -selectionColor $fullname .8 .8 .8 -lbc $fullname .2 .2 .2 $listControl;
						if ($shotFolder == $abxShots_PrevisFolder){
							treeView -e -bti $fullname 1 "P" -textColor $fullname .3 .9 .4 $listControl;
						}
						else {
							treeView -e -bti $fullname 1 "" -bti $fullname 2 "" -bti $fullname 3 "" -bti $fullname 4 "" $listControl;
						}
						treeView -e -displayLabel $fullname $every $listControl;
					}
					if ($i%2)
						treeView -e -lbc $fullname .2 .2 .2 $listControl;
					else 
						treeView -e -lbc $fullname .24 .24 .24 $listControl;
				}
			}
		}
	}
	return 1;
}

global proc int abxShotsExpandListStatus (string $itemName, int $state) {
	//print ("SETTING STATUS ON: "+$itemName+"\n");
	if ($state == 1){
		string $projectPath = `workspace -q -rd`;
		string $shotFolder = `abxShotsGetActiveShotFolder`;
		string $tabName = `abxShotsGetActiveShotTab`;
		string $listControl;
		if ($tabName == "abxShotsLibForm")
			$listControl = "abxShotsList";
		else if ($tabName == "abxPrevisLibForm")
			$listControl = "abxPrevisList";
		else 
			$listControl = "abxShotGroupsList";

		// if the tab is the shot group tab
		if ($listControl == "abxShotGroupsList"){
			global int $dbExists;
			if ($dbExists){
				string $indexToken[];
				tokenize $itemName ":" $indexToken;
				int $index = $indexToken[0];
				// load the shotList in memory
				python("shotList = activeJob.lgt_groups["+$index+"].get_shots()");

				int $shotListCount = python("len(shotList)");
				for ($i=0;$i<$shotListCount;$i++){
					string $shotName = python("shotList["+$i+"].name");

					string $tokenBuffer[];
					tokenize $shotName "_" $tokenBuffer;
					string $seqName = $tokenBuffer[0];
					// add the shot group index number plus the sequence name plus the shotname
					string $shotItemName = ($i+":"+$seqName+"/"+$shotName);
					string $motherShot = python("activeJob.lgt_groups["+$index+"].mother_shot['natural_key']");

					// if the item is not the mother shot (because querying shot group members also returns the mother shot)
					//print ("comparing \""+$shotName+"\" to \""+$motherShot+"\"\n");
					if ($shotName != $motherShot){

						//// if the treeview item name does not already exists then add it
						//if (!`treeView -q -iex $shotItemName $listControl`){
						//	//treeView -e -addItem $shotItemName $itemName $listControl;
						//	treeView -e -selectionColor $shotItemName .8 .8 .8 -lbc $shotItemName .2 .2 .2 $listControl;
						//	treeView -e -bti $shotItemName 1 "" -bti $shotItemName 2 "" -bti $shotItemName 3 "" -bti $shotItemName 4 "" $listControl;
						//	treeView -e -dl $shotItemName $shotName $listControl;
						//	
						//	if (abxShotsFreshMaster($shotItemName))
						//		treeView -e -or $shotItemName 1 0 3 -orc $shotItemName 1 0 0 $listControl;
						//	if ($i%2)
						//		treeView -e -lbc $shotItemName .2 .2 .2 $listControl;
						//	else 
						//		treeView -e -lbc $shotItemName .24 .24 .24 $listControl;
						//}
						// set the color status
						string $shotDetails[] = `abxShotsGetShotDetails ($seqName+"/"+$shotName) $shotFolder`;
						if (size($shotDetails) > 4){
							//print $shotDetails;
							int $status = 0;
							string $anmStatBuff[];
							if ($shotDetails[6] != "") {
								tokenize $shotDetails[6] "," $anmStatBuff;
								$status = int($anmStatBuff[0]);
							}

							string $setColorCmd = ("treeView -e ");
							$setColorCmd += ("-btc \""+$shotItemName+"\" 1 "+`abxShotsStatAsColor $status`+" ");
							if (size($anmStatBuff)>1)
								$setColorCmd += ("-i \""+$shotItemName+"\" 1 \""+`abxShotsStageAsLabel $anmStatBuff[1]`+ "\" ");

							$status = 0;
							if ($shotDetails[7] != "") $status = int($shotDetails[7]);
							$setColorCmd += ("-btc \""+$shotItemName+"\" 2 "+`abxShotsStatAsColor $status`+" ");

							$status = 0;
							if ($shotDetails[8] != "") $status = int($shotDetails[8]);
							$setColorCmd += ("-btc \""+$shotItemName+"\" 3 "+`abxShotsStatAsColor $status`+" ");

							$status = 0;
							if ($shotDetails[9] != "") $status = int($shotDetails[9]);
							$setColorCmd += ("-btc \""+$shotItemName+"\" 4 "+`abxShotsStatAsColor $status`+" ");

							$setColorCmd += $listControl;
							eval($setColorCmd);
						}
					}					
				}
			}

		}
		// if the tab is the ALL_SHOTS or PREVIS tab
		else{
			//print ("Setting _ALL_SHOTS OR PREVIS\n");
			string $each = $itemName;
			string $subFolders[] = `getFileList -folder ($projectPath+"/scenes/"+$shotFolder+"/"+$each+"/")`;
			string $sortedSub[] = sort($subFolders);

			int $isShotFolder = 0;
			for ($every in $sortedSub){
				if ($isShotFolder == 0){
					if  ($every == "ANM" || $every == "LGT" || $every == "FX"){
						$isShotFolder = 1;
					}
				}
				else {
					break;
				}
			}
			//// remove existing items
			//$itemsToRemove = `treeView -q -ch $each $listControl`;
			//// index:0 is the actual parent item so we must hide index:1 (the loading... item)
			//treeView -e -iv $itemsToRemove[1] false $listControl;
			

			// shots that belong to a sequence

			// load the rest of the items in the sequence when it is expanded
			for ($i=0;$i<size($sortedSub);$i++){
				$every = $sortedSub[$i];
				if (`filetest -d ($projectPath+"/scenes/"+$shotFolder+"/"+$each+"/"+$every)` && $sortedSub[$i] != "old"){
					//print ("Setting "+$every+"\n");
					$fullname = ($each+"/"+$every);
					if (`treeView -q -itemExists $fullname $listControl`){

						evalDeferred -lowestPriority ("abxShotsUpdateItem (\""+$fullname+"\",\""+$listControl+"\",\""+$shotFolder+"\")");
						//treeView -e -addItem $fullname $each $listControl;
						//treeView -e -selectionColor $fullname .8 .8 .8 -lbc $fullname .2 .2 .2 $listControl;
						//if ($shotFolder == "_PREVIS"){
						//	treeView -e -bti $fullname 1 "P" -textColor $fullname .3 .9 .4 $listControl;
						//}
						//else {
						//	treeView -e -bti $fullname 1 "" -bti $fullname 2 "" -bti $fullname 3 "" -bti $fullname 4 "" $listControl;
						//}
						//treeView -e -displayLabel $fullname $every $listControl;
						//

					}
					//if ($i%2)
					//	treeView -e -lbc $fullname .2 .2 .2 $listControl;
					//else 
					//	treeView -e -lbc $fullname .24 .24 .24 $listControl;
				}
			}
		}
	}
	return 1;
}

global proc abxShotsUpdateItem (string $fullname, string $listControl, string $shotFolder){
	if (`treeView -q -itemExists $fullname $listControl`){
		if (abxShotsFreshMaster($fullname))
			treeView -e -or $fullname 1 0 3 -orc $fullname 1 0 0 $listControl;

		//treeView -e -or $fullname 1 0 5 $listControl;
		treeView -e -bto $fullname 1 true -bto $fullname 2 true -bto $fullname 3 true $listControl;
		int $dead = false;
		
		// set the color status
		string $shotDetails[] = `abxShotsGetShotDetails $fullname $shotFolder`;
		//print ("ShotDetails Size ="+size($shotDetails)+"\n");
		if (size($shotDetails) > 4){
			//print $shotDetails;
			int $status = 0;
			string $anmStatBuff[];
			if ($shotDetails[6] != "") {
				tokenize $shotDetails[6] "," $anmStatBuff;
				$status = int($anmStatBuff[0]);
			}
			if ($status == -2) $dead = true;
			//if ($shotDetails[7] == -2) $dead = true;
			//if ($shotDetails[6] == -2) $dead = true;
			//if ($shotDetails[6] == -2) $dead = true;



			if ($dead){
				string $setColorCmd = ("treeView -e ");
				$setColorCmd += ("-btc \""+$fullname+"\" 1 "+`abxShotsStatAsColor -2`+" ");
				$setColorCmd += ("-btc \""+$fullname+"\" 2 "+`abxShotsStatAsColor -2`+" ");
				$setColorCmd += ("-btc \""+$fullname+"\" 3 "+`abxShotsStatAsColor -2`+" ");
				$setColorCmd += ("-btc \""+$fullname+"\" 4 "+`abxShotsStatAsColor -2`+" ");		
				$setColorCmd += $listControl;		
				eval($setColorCmd);		
				treeView -e -selectionColor $fullname .8 .3 .3 -tc $fullname .3 .3 .3 $listControl;
				treeView -e -lbc $fullname .12 .12 .12 $listControl;
				string $tokenBuffer[];
				tokenize $fullname "/" $tokenBuffer;
				$dl = $tokenBuffer[1];
				treeView -e -dl $fullname ($dl+ " (DEAD)") $listControl;
			}
			else{
				string $setColorCmd = ("treeView -e ");
				$setColorCmd += ("-btc \""+$fullname+"\" 1 "+`abxShotsStatAsColor $status`+" ");
				if (size($anmStatBuff)>1)
					$setColorCmd += ("-i \""+$fullname+"\" 1 \""+`abxShotsStageAsLabel $anmStatBuff[1]`+ "\" ");
				$status = 0;
				if ($shotDetails[7] != "") $status = int($shotDetails[7]);
				$setColorCmd += ("-btc \""+$fullname+"\" 2 "+`abxShotsStatAsColor $status`+" ");
				if ($shotDetails[8] != "") $status = int($shotDetails[8]);
				$setColorCmd += ("-btc \""+$fullname+"\" 3 "+`abxShotsStatAsColor $status`+" ");
				$status = 0;
				if ($shotDetails[9] != "") $status = int($shotDetails[9]);
				$setColorCmd += ("-btc \""+$fullname+"\" 4 "+`abxShotsStatAsColor $status`+" ");
				$setColorCmd += $listControl;
				eval($setColorCmd);				
			}
		}
	}
}

// prevents tree list view items from being double clicked
global proc int abxShotsTreeViewDblClk (string $itemName){
	return true;
}

// updates the tree control popup menu
global proc int abxShotsUpdateMenu (string $itemName) {
	treeView -e -cs abxShotsList;
	treeView -e -si $itemName 1 abxShotsList;
	menuItem -e -label $itemName abxShotsListPMItemTitle;
	abxShotsSetActiveShot($itemName,1);
	return true;

}

global proc int abxShotsUpdatePrevisMenu (string $itemName){
	treeView -e -cs abxPrevisList;
	treeView -e -si $itemName 1 abxPrevisList;
	menuItem -e -label $itemName abxPrevisListPMItemTitle;
	abxShotsSetActiveShot($itemName,1);
	return true;
}

global proc int abxShotsUpdateShotGroupsMenu (string $itemName){
	treeView -e -cs abxShotGroupsList;
	treeView -e -si $itemName 1 abxShotGroupsList;
	menuItem -e -label $itemName abxShotGroupsListPMItemTitle;
	abxShotsSetActiveShot($itemName,1);
	return true;
}

global proc string abxShotsEditShotLabelCB (string $oldName, string $newName){
		
	print "Shame on you! So you were just gonna rename a whole shot? just like that?\n";
	return "";
}

global proc abxShotsBuildMenu (string $shotLister) {
	string $tokenBuffer[];

	tokenize $shotLister "|" $tokenBuffer;
	string $shotListShortName = $tokenBuffer[size($tokenBuffer)-1];

	// delete the current popup menu items
	string $popupMenus[] = `treeView -q -pma $shotLister`;
	for ($each in $popupMenus){
		menuItem -parent $each -label "Shot Label" ($shotListShortName+"PMItemTitle");
		//print ("menu name:"+$shotLister+"PMItemTitle");

		
		menuItem -parent $each -divider 1;
		if ($shotListShortName == "abxShotGroupsList") { 
			menuItem -parent $each -en 0 -label "======= lightbot ======";
			menuItem -parent $each -label "Generate / Update LGT Scenes from Mother Shot" -c ("abxShotsCtxMCmd(\""+$each+"\", \"lgtShotCopyAll\")");
			menuItem -en 0 -parent $each -label "Remove from Shot Group" -c ("abxShotsCtxMCmd(\""+$each+"\", \"remove\")");
			menuItem -parent $each -divider 1;
		}
		menuItem -parent $each -label "Capture Thumbnail" -c ("abxShotsCtxMCmd(\""+$each+"\", \"captureThumb\")");
		if ($shotListShortName == "abxShotsList" || $shotListShortName == "abxPrevisList" ) menuItem -parent $each -label "Add Latest ANM work to AutoCache" -c ("abxShotsCtxMCmd(\""+$each+"\", \"addToAutoCache\")");
		if ($shotListShortName == "abxShotsList" || $shotListShortName == "abxPrevisList" ) menuItem -parent $each -label "Add Latest ANM work to Playbomb" -c ("abxShotsCtxMCmd(\""+$each+"\", \"addToPlaybomb\")");
		if ($shotListShortName == "abxShotsList" || $shotListShortName == "abxPrevisList" ) menuItem -parent $each -label "Add Latest ANM work to Uber Cam" -c ("abxShotsCtxMCmd(\""+$each+"\", \"addToUberCam\")");
		menuItem -parent $each -divider 1;
		menuItem -parent $each -label "Browse Maya Scenes" -c ("abxShotsCtxMCmd(\""+$each+"\", \"browse\")");
		menuItem -parent $each -divider 1;
		menuItem -parent $each -label "Browse ANM Renders" -c ("abxShotsCtxMCmd(\""+$each+"\", \"browse anm\")");
		menuItem -parent $each -label "Browse FX Renders" -c ("abxShotsCtxMCmd(\""+$each+"\", \"browse fx\")");
		menuItem -parent $each -label "Browse LGT Renders" -c ("abxShotsCtxMCmd(\""+$each+"\", \"browse fx\")");
		menuItem -parent $each -label "Browse PRECOMP Renders" -c ("abxShotsCtxMCmd(\""+$each+"\", \"browse fx\")");
		menuItem -parent $each -label "Browse COMP Renders" -c ("abxShotsCtxMCmd(\""+$each+"\", \"browse cmp\")");

		
	}
}

// executes commands from the popup menu while making sure they are applied to the correct asset
global proc abxShotsCtxMCmd(string $menu, string $command){
	

	//$assetPath = `menuItem -q -label abxShotsPopupMenuItemTitle`;
	string $menus[] = `menu -q -ia $menu`;
	string $assetPath = `menuItem -q -label $menus[0]`;
	//$shotName = `treeListView`;
	//$dept = ``;
	

	switch ($command){
	case "open geo work":
		//abxShotsOpenWorkScene(($assetPath+"/geo") , "latest");
		break;
	case "open geo master":
		//abxShotsOpenMasterScene($assetPath+"/geo");
		break;
	case "open rig work":
		//abxShotsOpenWorkScene(($assetPath+"/rig") , "latest");
		break;
	case "open rig master":
		//abxShotsOpenMasterScene($assetPath+"/rig");
		break;
	case "save anm work":
			// get the selected 
			//abxShotsIncrementalSave($shotName, $dept, $takeName) abxShotsIncrementalSave 0 \"\" \"auto\" \"\" \"\" \"\" \"\"
		break;
	case "save rig master":
		//abxAssetsMaster(($assetPath+"/rig"));
		break;
	case "save geo work":
		//abxAssetsIncrementalSave(($assetPath+"/geo"));
		break;
	case "save geo master":
		//abxAssetsMaster(($assetPath+"/geo"));
		break;
	case "publish":
		//abxAssetsPublish($assetPath);
		break;
	case "ref asset":
		//abxAssetsRefAsset($assetPath);
		break;
	case "refanm":
		//abxAssetsRefGeo($assetPath);
		break;
	case "addToUberCam":
		abxShotsBuildSeqUberCam ($assetPath);
		break;
	case "addToPlaybomb":
		abxShotsBuildPlaybomb ($assetPath);
		break;
	case "addToAutoCache":
		evalEcho("abxShotsBuildAutoCache \""+$assetPath+"\"");
		break;
	case "captureThumb":
		abxShotsCaptureThumbnail ($assetPath);
		break;
	case "browse":
		abxShotsBrowseShot ($assetPath, 0);
		break;
	case "browse anm":
		abxShotsBrowseShot ($assetPath, 1);
		break;
	case "browse fx":
		abxShotsBrowseShot ($assetPath, 2);
		break;
	case "browse lgt":
		abxShotsBrowseShot ($assetPath, 3);
		break;
	case "browse precmp":
		abxShotsBrowseShot ($assetPath, 4);
		break;
	case "browse cmp":
		abxShotsBrowseShot ($assetPath, 5);
		break;
	case "lgtShotCopyAll":
		string $tokenBuffer[];
		tokenize $assetPath ":" $tokenBuffer;
		$result = `confirmDialog -title "ShotBot Copy Shots" -message ("Confirm: Rebuild LGT Takes of Shot Group:\""+$tokenBuffer[1]+"\"? Maya will Close the currently Open Scene.") -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
		if ($result == "OK"){
			abxShotBotGenerateFromShotGroup($tokenBuffer[1],"lgt",1);
			confirmDialog -title "ShotBot Copy Shots" -message "Shot Copy Completed. Please open each shot to diagnose missing assets/objects and to confirm renderLayer membership of new objects" -button "OK";
		}
		break;
	}
	
	
}



global proc int abxShotsSetActiveShot (string $shotName, int $state) {
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $tabName = `abxShotsGetActiveShotTab`;

	if ($tabName == "abxPrevisLibForm")
		$treeView = "abxPrevisList";
	else if ($tabName == "abxShotsLibForm")
		$treeView = "abxShotsList";
	else 
		$treeView = "abxShotGroupsList";

	if ($state == 1){
		treeView -e -textColor $shotName .2 .2 .2 $treeView;
		string $tokenBuffer[];
		tokenize $shotName ":" $tokenBuffer;
		$nonUniqueShotName = $tokenBuffer[size($tokenBuffer)-1];
		abxShotsRefreshDetailsUI $nonUniqueShotName;
		print ("set shot to "+$nonUniqueShotName+"\n");
	}
	else{
		if ($treeView == "abxPrevisList")
			treeView -e -textColor $shotName .3 .9 .4 $treeView;
		else
			treeView -e -textColor $shotName .8 .8 .8 $treeView;
	}
	return 1;

}

global proc abxShotsCreateDetailUI (){
	
	string $ppTools = `getenv MAYA_PPTOOLS`;
	setParent abxShotsDetailsForm;

	paneLayout -configuration "horizontal2" abxShotsDetailsPane;

	scrollLayout -p abxShotsDetailsPane -bgc .2 .2 .2 -cr true abxShotsDetailsScrlLyt;

	formLayout abxShotSpecLyt;
		columnLayout -cat "both" 4 -rs 6 -adj 1 abxShotsDtlColLyt;
			frameLayout -cll 1 -bv 0 -li 0 -lv true -bgc .27 .27 .27 -l "Shot Details";
				columnLayout -bgc .4 .4 .4 -rs 5 -adj true;
					separator -h 4 -style "none";
					rowLayout -numberOfColumns 3 -rat 2 "top" 0 -adj 3;
						separator -w 4 -vis 0;
						frameLayout -lv 0 abxShotsDetailImgFrmLyt;
							columnLayout -bgc .0 .0 .0 -cat "both" 8 -rs 6 -adj 1;
								separator -h 4 -style "none";
								iconTextStaticLabel -style "iconOnly" -h 100 -w 177 -i (`getenv MAYA_PPTOOLS`+"/icons/assetThumb.png") abxShotsDetailImg;

								//image -h 100 -w 177 -i ($ppTools+"/icons/shotThumb.png") abxShotsDetailImg;
								popupMenu;
									menuItem -label "Capture Thumbnail" -c "abxShotsCaptureThumbnail \"\"";
								separator -h 4 -style "none";
							setParent..;
						setParent..;
					columnLayout -cat "both" 0 -adj true -rs 2;
						textFieldGrp -cw 1 80 -cw 2 122 -adj 2 -label "Shot Name:" -text  "" -editable false abxShotsDtlShotName;
						textFieldGrp -cw 1 80 -cw 2 122 -adj 2 -label "Focal Length:" -text  "" -editable false abxShotsDtlFocalL;
						//textFieldGrp -cw 1 80 -cw 2 122 -adj 2 -label "Resolution:" -text  "" -editable false abxShotsDtlRes;
						//textFieldGrp -cw 1 80 -cw 2 122 -adj 2 -label "Frame Rate:" -text  "" -editable false abxShotsDtlFPS;
						rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 80 -nc 4 -adj 4;
							text -l "Start/End:";
							textField -w 80 -text  "" -editable false abxShotsDtlRangeS;
							textField -w 80 -text  "" -editable false abxShotsDtlRangeE;
							separator -style "none";
						setParent..;
						//floatFieldGrp -bgc .4 .4 .4 -en1 0 -en2 0 -cw 1 80 -cw 2 60 -cw 3 60 -nf 2  -label "Start/End:" -v1 0 -v2 0 abxShotsDtlRange;
						rowLayout -numberOfColumns 2 -cw1 80 -adj 2;
							separator -style "none" -w 80;
							button -w 120 -en 0 -bgc .2 .2 .2 -ebg 0 -l "Edit Frame Range" -c "" abxShotsEditRangeBtn;
						setParent ..;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
		frameLayout -p "abxShotsDtlColLyt" -cl 0 -cll 1 -bv 0 -li 0 -bgc .27 .27 .27 -l "Activity Log (Newest At Top)";
			columnLayout -bgc .4 .4 .4 -cat "both" 2 -adj true;
				columnLayout -cat "both" 2 -adj true -rs 2;
					separator -style "none" -h 5;
					
						//frameLayout -bgc .2 .3 .4 -bs "in" -cll 0 -label "   DEPT          TAKE                                    WORK         MASTER" abxShotsLgtScnListFrme;
						//frameLayout -bs "in" -cll 0 -label "" abxShotsLogScnListFrme;
							treeView -h 150 -numberOfButtons 0 -abr false -enableKeys true -idc "" -sc "" -cmc "" abxShotsLogScnList;
						//setParent ..;
					
					setParent..;
					separator -style "none" -h 5;
				setParent..;
			setParent..;
		setParent..;
		frameLayout -p "abxShotsDtlColLyt" -cll 1 -li 0 -bv 0 -bgc .27 .27 .27 -l "Latest Modified";
			columnLayout -bgc .4 .4 .4 -cat "both" 2 -adj true;
				columnLayout  -cat "both" 0 -adj true -rs 2;
					separator -style "none" -h 5;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 110 -nc 2 -adj 2;
						text -l "Anm 'default' Master:";
						textField -text  "" -editable false abxShotsDtlAMDate;
					setParent..;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 110 -nc 2 -adj 2;
						text -label "Hair Cache:" ;
						textField -text  "" -editable false abxShotsDtlHCDate;
					setParent..;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 110 -nc 2 -adj 2;
						text -label "Cloth Cache:" ;
						textField -text  "" -editable false abxShotsDtlCCDate;
					setParent..;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 110 -nc 2 -adj 2;
						text -label "Lgt 'default' Work:";
						textField  -text  "" -editable false abxShotsDtlRndDate;
					setParent..;
					separator -style "none" -h 5;
				setParent..;
				separator -style "none" -h 2;
			setParent..;
		setParent..;
		/*frameLayout -p "abxShotsDtlColLyt" -cll 1 -li 0 -bv 0 -bgc .27 .27 .27 -l "Latest Quicktimes";
			columnLayout -bgc .4 .4 .4 -cat "both" 2 -adj true;
				rowLayout -nc 5;
					button -label "Play Sequence";
					button -label "Playblast";
					button -label "Precomp";
					button -label "Precomp";
				setParent..;
			setParent..;
		setParent..;
		*/
		frameLayout -p "abxShotsDtlColLyt" -cll 1 -li 0 -bv 0 -bgc .27 .27 .27 -l "Assets In Use";
			columnLayout -bgc .4 .4 .4 -cat "both" 2 -adj true;
				columnLayout  -cat "both" 0 -adj true -rs 2;
					separator -style "none" -h 5;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 110 -nc 2 -adj 2;
						text -l "Characters:";
						textField -text  "" -editable false abxShotsDtlAstChar;
					setParent..;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 110 -nc 2 -adj 2;
						text -l "Props:";
						textField -text  "" -editable false abxShotsDtlAstProps;
					setParent..;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 110 -nc 2 -adj 2;
						text -l "Sets:";
						textField -text  "" -editable false abxShotsDtlAstSets;
					setParent..;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 110 -nc 2 -adj 2;
						text -l "Misc:";
						textField -text  "" -editable false abxShotsDtlAstMisc;
					setParent ..;
				setParent..;
			setParent..;
		setParent..;
		frameLayout -cll 1 -li 0 -bv 0 -bgc .27 .27 .27 -l "Camera Details";
			columnLayout -bgc .4 .4 .4 -cat "both" 2 -adj true;
				rowLayout -numberOfColumns 2;
					columnLayout;
						textFieldGrp -cw 1 100 -cw 2 150 -label "Cam Version:" -editable false -text "" abxShotsDtlCamScene;
						textFieldGrp -cw 1 100 -cw 2 150 -label "Date:" -editable false -text "" abxShotsDtlCamDate;
					setParent..;
					columnLayout -cat "both" 0 -adj 1;
						button -w 140 -label "Reference Cam ->" -c "abxShotsCameraReference \"\"";
						rowLayout -numberOfColumns 2;
							button -bgc .2 .2 .2 -ebg 0 -w 70 -label "Edit Cam" -c "abxShotsCameraMakeEditable";
							button -bgc .2 .2 .2 -ebg 0 -w 70 -label "Master Cam" -c "abxShotsCameraMaster `ls -type camera -r 1 \"*renderCamShape\"`";
						setParent..;
					setParent..;
				setParent..;
			separator -style "none" -h 2;	



	setParent abxShotsDetailsPane;
	tabLayout -imw 0 -imh 0 -cc "abxShotsDeptTabChange;"  abxShotsDeptTabLyt;

	formLayout -e
		-af abxShotsDtlColLyt "left" 0
		-af abxShotsDtlColLyt "top" 0
		-af abxShotsDtlColLyt "right" 0
		-af abxShotsDtlColLyt "bottom" 0
		abxShotSpecLyt;

		
	// commands
		formLayout -bgc .24 .35 .28 abxShotsPreFrmLyt;
			//rowLayout -numberOfColumns 2 -adj 2 -ct2 "both" "both" -rat 2 "both" 0;
				columnLayout -rs 3 abxShotsPreListBtnCol;;
					button -bgc .2 .2 .2 -ebg 0 -label "Add Scene" -ann "Add a New Scene File / Take to the Shot" -w 70 -c abxShotsCreateTakeProc;
					button -bgc .2 .2 .2 -ebg 0 -label "Open" -w 70 -c "abxShotsOpenTake abxShotsPreScnList";
					button -bgc .2 .2 .2 -ebg 0 -label "Open Other" -w 70 -c "abxShotsOpenOtherFile \"\"";
					button -bgc .2 .2 .2 -ebg 0 -label "Save" -w 70 -c "abxShotsIncrementalSave 0 \"\" \"auto\" \"\" \"\" \"\" \"\";abxShotsDeptTabChange;";
					//separator -h 20;
					//button -ann "Reference selected master into your open scene" -en 1 -label "Ref Master" -w 60 -c "abxShotsReferenceMaster abxShotsPreScnList";
					separator -h 30;
					button -bgc .7 .2 .2 -ebg 0 -en 1 -ann "Master latest work scene"-label "Master" -w 70 -c "abxShotsMasterTake 1 1 abxShotsPreScnList \"master\" \"\"";

					setParent ..;	

					//treeView -numberOfButtons 0 -abr true -enk true -sc "abxAssetsSetActiveSceneAsset" -cmc "abxAssetsUpdateSceneAssetsMenu" abxAssetsAnmScnList;
				
					//textScrollList -dcc "abxShotsOpenTake abxShotsPreScnList" abxShotsPreScnList;       //
					frameLayout -bgc .24 .35 .28 -bs "in" -cll 0 -label "   DEPT          TAKE                                    WORK         MASTER" abxShotsPreScnListFrme;
						treeView -numberOfButtons 1 -abr true -enableKeys true -idc "abxShotsTakeListDblClk" -sc "abxShotsSetActiveTake " -cmc "abxShotsUpdateTakeMenu" abxShotsPreScnList;
						popupMenu abxShotsPrePUMenu;
						abxShotsBuildTakeMenu ("abxShotsPreScnList");
						setParent ..;
					setParent ..;
					
		formLayout -e 
			-af abxShotsPreScnListFrme "left" 80
			-af abxShotsPreScnListFrme "top" 3
			-af abxShotsPreScnListFrme "bottom" 3
			-af abxShotsPreScnListFrme "right" 3

			-af abxShotsPreListBtnCol "left" 3
			-af abxShotsPreListBtnCol "top" 3
 
			abxShotsPreFrmLyt;
		setParent abxShotsDeptTabLyt;


		formLayout -bgc .4 .2 .2 abxShotsAnmFrmLyt;
			//rowLayout -numberOfColumns 2 -adj 2 -ct2 "both" "both" -rat 2 "both" 010;
				columnLayout -rs 3 abxShotsAnmListBtnCol;
					button -bgc .2 .2 .2 -ebg 0 -label "Add Scene" -ann "Add a New Scene File / Take to the Shot" -w 70 -c abxShotsCreateTakeProc;
					button -bgc .2 .2 .2 -ebg 0 -label "Open" -w 70 -c "abxShotsOpenTake abxShotsAnmScnList";
					button -bgc .2 .2 .2 -ebg 0 -label "Open Other" -w 70 -c "abxShotsOpenOtherFile \"\"";
					button -bgc .2 .2 .2 -ebg 0 -label "Save" -w 70 -c "abxShotsIncrementalSave 0 \"\" \"auto\" \"\" \"\" \"\" \"\";abxShotsDeptTabChange;";
					//separator -h 20;
					//button -ann "Reference selected master into your open scene" -en 1 -label "Ref Master" -w 60 -c "abxShotsReferenceMaster abxShotsAnmScnList";
					separator -h 30;
					button -bgc .7 .2 .2 -ebg 0 -en 1 -ann "Master latest work scene"-label "Master" -w 70 -c "abxShotsMasterTake 1 1 abxShotsAnmScnList \"latest\" \"\"";

					setParent ..;					
				
				//textScrollList -dcc "abxShotsOpenTake abxShotsAnmScnList" abxShotsAnmScnList;
				frameLayout -bgc .4 .2 .2 -bs "in" -cll 0 -label "   DEPT          TAKE                                    WORK         MASTER" abxShotsAnmScnListFrme;
					treeView -numberOfButtons 1 -abr true -enableKeys true -idc "abxShotsTakeListDblClk" -sc "abxShotsSetActiveTake " -cmc "abxShotsUpdateTakeMenu" abxShotsAnmScnList;
					popupMenu abxShotsAnmPUMenu;
					abxShotsBuildTakeMenu ("abxShotsAnmScnList");


				setParent ..;
			setParent ..;
		formLayout -e 
			-af abxShotsAnmScnListFrme "left" 80
			-af abxShotsAnmScnListFrme "top" 3
			-af abxShotsAnmScnListFrme "bottom" 3
			-af abxShotsAnmScnListFrme "right" 3

			-af abxShotsAnmListBtnCol "left" 3
			-af abxShotsAnmListBtnCol "top" 3
 
			abxShotsAnmFrmLyt;
		setParent abxShotsDeptTabLyt;

		// FX
		formLayout  -bgc .26 .2 .24 abxShotsFxFrmLyt ;
			//rowLayout -numberOfColumns 2 -adj 2 -ct2 "both" "both" -rat 2 "both" 0;
				columnLayout -rs 3 abxShotsFxListBtnCol;
					button -bgc .2 .2 .2 -ebg 0 -label "Add Scene" -ann "Add a New Scene File / Take to the Shot" -w 70 -c abxShotsCreateTakeProc;
					button -bgc .2 .2 .2 -ebg 0 -label "Open" -w 70 -c "abxShotsOpenTake abxShotsFxScnList";
					button -bgc .2 .2 .2 -ebg 0 -label "Open Other" -w 70 -c "abxShotsOpenOtherFile \"\"";
					button -bgc .2 .2 .2 -ebg 0 -label "Save" -w 70 -c "abxShotsIncrementalSave 0 \"\" \"auto\" \"\" \"\" \"\" \"\";abxShotsDeptTabChange;";
					//separator -h 20;
					//button -ann "Reference selected master into your open scene" -en 1 -label "Ref Master" -w 60 -c "abxShotsReferenceMaster abxShotsFXScnList";
					separator -h 30;
					button -bgc .7 .2 .2 -ebg 0 -en 1 -ann "Master latest work scene"-label "Master" -w 70 -c "abxShotsMasterTake 1 1 abxShotsFxScnList \"latest\" \"\"";

					setParent ..;	

									
				
					//textScrollList -dcc "abxShotsOpenTake abxShotsFxScnList" abxShotsFxScnList;
					frameLayout -bgc .26 .2 .24 -bs "in" -cll 0 -label "   DEPT          TAKE                                    WORK         MASTER" abxShotsFxScnListFrme;
						treeView -numberOfButtons 1 -abr true -enableKeys true -idc "abxShotsTakeListDblClk" -sc "abxShotsSetActiveTake " -cmc "abxShotsUpdateTakeMenu" abxShotsFxScnList;
						popupMenu abxShotsFxPUMenu;
						abxShotsBuildTakeMenu ("abxShotsFxScnList");

						setParent ..;
					setParent ..;
		formLayout -e 
			-af abxShotsFxScnListFrme "left" 80
			-af abxShotsFxScnListFrme "top" 3
			-af abxShotsFxScnListFrme "bottom" 3
			-af abxShotsFxScnListFrme "right" 3

			-af abxShotsFxListBtnCol "left" 3
			-af abxShotsFxListBtnCol "top" 3
 
			abxShotsFxFrmLyt;
		setParent abxShotsDeptTabLyt;

		// lgt
		formLayout -bgc .2 .3 .4  abxShotsLgtFrmLyt;
			//rowLayout -numberOfColumns 2 -adj 2 -ct2 "both" "both" -rat 2 "both" 0;
				columnLayout -rs 3 abxShotsLgtListBtnCol;
					button -bgc .2 .2 .2 -ebg 0 -label "Add Scene" -ann "Add a New Scene File / Take to the Shot" -w 70 -c abxShotsCreateTakeProc;
					button -bgc .2 .2 .2 -ebg 0 -label "Open" -w 70 -c "abxShotsOpenTake abxShotsLgtScnList";
					button -bgc .2 .2 .2 -ebg 0 -label "Open Other" -w 70 -c "abxShotsOpenOtherFile \"\"";
					button -bgc .2 .2 .2 -ebg 0 -label "Save" -w 70 -c "abxShotsIncrementalSave 0 \"\" \"auto\" \"\" \"\" \"\" \"\";abxShotsDeptTabChange;";
					//separator -h 20;
					//button -ann "Reference selected master into your open scene" -en 1 -label "Ref Master" -w 60 -c "abxShotsReferenceMaster abxShotsLgtScnList";
					separator -h 30;
					button -bgc .7 .2 .2 -ebg 0 -en 1 -ann "Master latest work scene"-label "Master" -w 70 -c "abxShotsMasterTake 1 1 abxShotsLgtScnList \"latest\" \"\"";

					setParent ..;					
				
					//textScrollList -dcc "abxShotsOpenTake abxShotsLgtScnList" abxShotsLgtScnList;
					frameLayout -bgc .2 .3 .4 -bs "in" -cll 0 -label "   DEPT          TAKE                                    WORK         MASTER" abxShotsLgtScnListFrme;
						treeView -numberOfButtons 1 -abr true -enableKeys true -idc "abxShotsTakeListDblClk" -sc "abxShotsSetActiveTake " -cmc "abxShotsUpdateTakeMenu" abxShotsLgtScnList;
						popupMenu abxShotsLgtPUMenu;
						abxShotsBuildTakeMenu ("abxShotsLgtScnList");

						setParent ..;
					setParent ..;
		formLayout -e 
			-af abxShotsLgtScnListFrme "left" 80
			-af abxShotsLgtScnListFrme "top" 3
			-af abxShotsLgtScnListFrme "bottom" 3
			-af abxShotsLgtScnListFrme "right" 3

			-af abxShotsLgtListBtnCol "left" 3
			-af abxShotsLgtListBtnCol "top" 3
 
			abxShotsLgtFrmLyt;
		setParent abxShotsDeptTabLyt;

		//formLayout abxShotsLogFrmLyt;
		//	//rowLayout -numberOfColumns 2 -adj 2 -ct2 "both" "both" -rat 2 "both" 0;
		//			
		//	scrollField -wordWrap false -text "" -editable false abxShotsLogScnList;
		//	setParent ..;
		//	formLayout -e 
		//		-af abxShotsLogScnList "left" 3
		//		-af abxShotsLogScnList "top" 3
		//		-af abxShotsLogScnList "bottom" 3
		//		-af abxShotsLogScnList "right" 3
//
		//		abxShotsLogFrmLyt;

		setParent abxShotsDeptTabLyt;

		tabLayout -e 
			-tabLabel abxShotsAnmFrmLyt "ANM"
			-tabLabel abxShotsFxFrmLyt "FX"
			-tabLabel abxShotsLgtFrmLyt "LGT"
			-tabLabel abxShotsPreFrmLyt "PRE"
			
			 abxShotsDeptTabLyt;

		// set the ANM department tab to current
		tabLayout -e -st abxShotsAnmFrmLyt abxShotsDeptTabLyt;
		// initially set the previs tab to disabled
		formLayout -e -en 0 abxShotsPreFrmLyt;

		formLayout -e 
        		-af abxShotsDetailsPane top 0
        		-af abxShotsDetailsPane left 0
        		-af abxShotsDetailsPane bottom 0
        		-af abxShotsDetailsPane right 0
		abxShotsDetailsForm;
		paneLayout -e -paneSize 2 100 30 abxShotsDetailsPane;
}

global proc abxShotsAddLogItem (string $logString){
	int $num = size(`treeView -q -ch "" abxShotsLogScnList`);
	if (size($logString)>7){
		string $tokenBuffer[];
		tokenize $logString "\t" $tokenBuffer;
		
		$number = size(`treeView -q -ch "" abxShotsLogScnList`)+1;
		$bgc =.3;
		if (($number)%2) $bgc = .25;
		$rNum = 1;

		$name = ("li"+$number);
		$chldName = ($name+"_"+$rNum);

		$shortDept = `substring $tokenBuffer[1] 1 3`;
		$shortVers = `substring $tokenBuffer[4] 1 4`;

		if (`gmatch $tokenBuffer[3] "---*"`) $tokenBuffer[3]="default";
		
		$friendlyDate = abxShotsGetFriendlyLogDate ($tokenBuffer[0]);
		$note = "";
		if (`gmatch $tokenBuffer[2] "STATUS*"`) $note = "Status Set to ";
		if (`gmatch $tokenBuffer[2] "MASTER*"`) $note = ("Mastered "+$shortVers+": ");
		$note += $tokenBuffer[6];

		treeView -e -addItem $name "" abxShotsLogScnList;
		treeView -e -font $name "fixedWidthFont" abxShotsLogScnList;
		treeView -e -dl $name ($friendlyDate+"\t\t"+$shortDept+" "+$tokenBuffer[5]+" \""+$note+"\"") abxShotsLogScnList;
		// add sub tree children for more info
		treeView -e -addItem ($name+"_0") $name abxShotsLogScnList;
		treeView -e -font ($name+"_0") "fixedWidthFont" -dl ($name+"_0") ("Version:"+$shortVers+" Take:"+$tokenBuffer[3]+" Process:"+$tokenBuffer[2]+" Timestamp:"+$tokenBuffer[0]) abxShotsLogScnList;
		treeView -e -addItem ($name+"_1") $name abxShotsLogScnList;
		treeView -e -font ($name+"_1") "fixedWidthFont" -dl ($name+"_1") ($tokenBuffer[6]) abxShotsLogScnList;

			
		
		treeView -e -lbc ($name+"_0") $bgc $bgc $bgc abxShotsLogScnList;
		treeView -e -lbc ($name+"_1") $bgc $bgc $bgc abxShotsLogScnList;
		treeView -e -expandItem $name false -lbc $name $bgc $bgc $bgc  abxShotsLogScnList;
	}

}

global proc abxShotsBuildTakeMenu (string $shotLister) {


	// delete the current popup menu items
	string $popupMenus[] = `treeView -q -pma $shotLister`;
	string $labelMenuItem = ($shotLister+"MenuLabel");
	for ($each in $popupMenus){
		menuItem -parent $each -label ("Dept:"+"TakeName") $labelMenuItem;
		menuItem -parent $each -divider 1;
		menuItem -parent $each -en 1 -label "Open Latest Work Scene" -c ("abxShotsOpenTake  "+$shotLister);
		menuItem -parent $each -en 1 -label "Open Latest Work In Prompt Mode (no ui)" -c ("$tempScenePath  = `treeView -q -si "+$shotLister+"`;callMayaBG (1, 1, $tempScenePath[0], `workspace -q -rd`, \"\", \"\");");
		menuItem -parent $each -en 1 -label "Incremental Save Work Scene" -c "abxShotsIncrementalSave 0 \"\" \"auto\" \"\" \"\" \"\" \"\";abxShotsDeptTabChange;";
		menuItem -parent $each -divider 1;

		menuItem -parent $each -en 0 -label "Master Latest Work Scene" -c ("abxShotsMasterTake 0 0 "+$shotLister+" \"latest\" \"\"");
		menuItem -parent $each -en 1 -label "Master Latest Work Scene in Background" -c ("abxShotsMasterTake 1 1 "+$shotLister+" \"latest\" \"Background Mastering Latest Work Version\"");

		menuItem -parent $each -en 0 -label "Open Master File" -c "";
		menuItem -parent $each -divider 1;

		//menuItem -parent $each -divider 1;
		//menuItem -parent $each -en 1 -label "======== shot bot ==========";
		//menuItem -parent $each -en 1 -label "Copy Take to Another Shot" -c ("abxShotsMasterTake 0 0 "+$shotLister+" \"latest\" \"\"");

		menuItem -parent $each -en 1 -label "Reference Latest Master" -c ("abxShotsReferenceMaster "+$shotLister);
		menuItem -parent $each -en 1 -label "Update Assets in Current Master" -c ("abxShotsMasterTake 1 1 "+$shotLister+" \"latestMaster\" \"Updating Assets in Current Master\"");
		menuItem -parent $each -divider 1;
		menuItem -parent $each -en 0 -label "Archive and Remove" -c "";
		menuItem -parent $each -en 1 -label "Copy To Another Shot" -c ("{string $curFile[] = `treeView -q -si "+$shotLister+"`;abxShotBotLoad $curFile[0] \"\";}");
		menuItem -parent $each -label "Pack Scene File" -c ("abxShotsPackTake "+$shotLister);
		menuItem -parent $each -label "Add To UberCam" -c ("abxShotsBuildUberCam "+$shotLister);

		menuItem -parent $each -en 1 -label "Shave Interactive Master" -c ("abxShotsMasterTake 0 0 "+$shotLister+" \"latest\" \"\"");

		menuItem -parent $each -divider 1;

		menuItem -parent $each -en 1 -label "Rebuild Slap Comp (overwrite)" -c ("$tempScenePath  = `treeView -q -si "+$shotLister+"`;$eCmd = encodeString(\"print (\\\" slapComping:\"+$tempScenePath[0]+\"\\\");python(\\\"import slapComp;reload(slapComp);slapComp.slapCompSimple(\\\\\\\"\"+$tempScenePath[0]+\"\\\\\\\",1,1,0,0)\\\")\");callMayaBG (1, 1, $tempScenePath[0], `workspace -q -rd`, \"\", $eCmd);");
		menuItem -parent $each -en 1 -label "Open Existing Slap Comp in Nuke" -c ("$tempScenePath  = `treeView -q -si "+$shotLister+"`;$eCmd = encodeString(\"print (\\\"path=\"+$tempScenePath[0]+\"\\\");python(\\\"import slapComp;reload(slapComp);slapComp.slapCompSimple(\\\\\\\"\"+$tempScenePath[0]+\"\\\\\\\",0,1,0,0)\\\")\");callMayaBG (1, 1, $tempScenePath[0], `workspace -q -rd`, \"\", $eCmd);");
		menuItem -parent $each -en 1 -label "Render Slap Comp Quicktime for Review (in BG)" -c ("$tempScenePath  = `treeView -q -si "+$shotLister+"`;$eCmd = encodeString(\"print (\\\"path=\"+$tempScenePath[0]+\"\\\");python(\\\"import slapComp;reload(slapComp);slapComp.slapCompSimple(\\\\\\\"\"+$tempScenePath[0]+\"\\\\\\\",0,0,1,1)\\\")\");callMayaBG (1, 1, $tempScenePath[0], `workspace -q -rd`, \"\", $eCmd);");
		// menuItem -parent $each -label "Open Existing Slap Comp in Nuke" -c ("$tempScenePath  = `treeView -q -si "+$shotLister+"`;print (\"path=\"+$tempScenePath[0]+\"\\\n\");python(\"import slapComp;reload(slapComp);slapComp.slapCompSimple(\\\"\"+$tempScenePath[0]+\"\\\",0,1,0,0)\");");
		// menuItem -parent $each -label "Render Slap Comp Quicktime for Review" -c ("$tempScenePath  = `treeView -q -si "+$shotLister+"`;print (\"path=\"+$tempScenePath[0]+\"\\\n\");python(\"import slapComp;reload(slapComp);slapComp.slapCompSimple(\\\"\"+$tempScenePath[0]+\"\\\",0,0,0,1)\");");
		//menuItem -parent $each -label "Open Slap Comp in Nuke" slapCompSimple;
		//menuItem -	abxShotsWriteShotLog ($shotFolder, ($shotSequence+"/"+$shotNameGuess), ($deptGuess+" master"), $shotTakeGuess, $workVersion, $note);parent $each -label "Make Review Quicktime";
		//python ("slapCompDoIt(createComp, openNuke, includeElements, renderComp, review, sendRight, editorial, email, frameRange, notes)");

		string $SUBMIT_PATH = "C:\Program Files (x86)\Smedge2014\Submit.exe";
		int $packetSize = 1;
		int $priority = 51;
		$tempScenePath = `treeView -q -si $shotLister`;
		// print ("123456789");
		// print $tempScenePath[0];
		// print ("123456789");
		string $jobName = ("something" + "_slapComp");
		// string $renderPaused = " -paused";
		string $renderPaused = " ";
		$poolID = "a52ede97-396d-4fa5-a84f-c426c518eb0a";
		// $poolID = "33f17392-56d9-4ecf-9a5b-a8fcd107c857"; // snoopy
		int $startFrame = 1; // get from frameRange
		int $endFrame = 1;
		string $renderNodeString = "";
		string $onComplete = "";
		string $renderProxyString = "";
		// string $Command = ("python(\\\\\\\"import slapComp;reload(slapComp);slapComp.slapCompDoIt('" + scenePath + "',"+str(createComp)+",0,"+str(includeElements)+","+str(renderComp)+","+str(review)+","+str(sendRight)+","+str(editorial)+","+str(email)+",'"+str(frameRange)+"','"+str(notes)+"',1)\\\\\\\");");
		string $Command = ("python(\"import slapComp;reload(slapComp);slapComp.slapCompSimple()\")");
		print $Command;
		string $CommandString = "";
		// string $cmdText = (" script -type MayaTask -scene " + $tempScenePath[0] + " -name \"" + $jobName + "\" -priority " + $priority + $renderPaused + " -Pool " + $poolID + " -range " + $startFrame + "-" + $endFrame + " -packetsize " + $packetSize + " -writenode \"" + $renderNodeString + "\" -JobFinishedEvt \"" + $onComplete + "\" -extra \"" + $renderProxyString + "\" -Command \"" + $Command + "\" -CommandString \"" + $CommandString + "\"";
		
		// print $cmdText;
		// menuItem -parent $each -en 1 -label "Render Slap Comp Quicktime for Review (on farm)" -c ("$tempScenePath = `treeView -q -si "+$shotLister+"`;print $tempScenePath[0];system(\"start C:/Program Files (x86)/Smedge2012.1/Submit.exe script -type MayaTask -scene " + $tempScenePath[0] + " -name " + $jobName + " -priority " + $priority + $renderPaused + " -Pool " + $poolID + " -range " + $startFrame + "-" + $endFrame + " -packetsize " + $packetSize + " -writenode " + $renderNodeString + " -JobFinishedEvt " + $onComplete + " -extra " + $renderProxyString + " -Command " + $Command + " -CommandString " + $CommandString + "\");");
		// string $yo = ("yo");
		// menuItem -parent $each -en 1 -label "Render Slap Comp Quicktime for Review (on farm)" -c ("$tempScenePath = `treeView -q -si "+$shotLister+"`;$eCmd = encodeString(\"print $tempScenePath[0]\");system(\"start C:/Program Files (x86)/Smedge2012.1/Submit.exe script -type MayaTask -scene $eCmd -name " + $jobName + " -priority " + $priority + $renderPaused + " -Pool " + $poolID + " -range " + $startFrame + "-" + $endFrame + " -packetsize " + $packetSize + " -writenode " + $renderNodeString + " -JobFinishedEvt " + $onComplete + " -extra " + $renderProxyString + " -Command " + $Command + " -CommandString " + $CommandString + "\");");
		menuItem -parent $each -en 1 -label "Render Slap Comp Quicktime for Review (on farm)" -c ("$tempScenePath = `treeView -q -si "+$shotLister+"`;string $eCmd = $tempScenePath[0];system(\"start C:/Program Files (x86)/Smedge2014/Submit.exe script -type MayaTask -scene \"+$eCmd+\" -name " + $jobName + " -priority " + $priority + $renderPaused + " -Pool " + $poolID + " -range " + $startFrame + "-" + $endFrame + " -packetsize " + $packetSize + " -writenode " + $renderNodeString + " -JobFinishedEvt " + $onComplete + " -extra " + $renderProxyString + " -Command \\\"python(\\\\\\\\\\\\\\\"import slapComp;reload(slapComp);slapComp.slapCompSimple('\"+$eCmd+\"',0,0,1,1)\\\\\\\\\\\\\\\")\\\" -CommandString " + $CommandString + "\");");
        // menuItem -parent $each -en 1 -label "Render Slap Comp Quicktime for Review (on farm)" -c ("$tempScenePath = `treeView -q -si "+$shotLister+"`;print $tempScenePath[0];");
        //                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \"););
	}
}

global proc abxShotsDeptTabChange () {
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $shotTab = `abxShotsGetActiveShotTab`;
	// get the selected shot
	if (`treeView -exists abxShotsList`){
		string $shotsHighlighted[];
		if ($shotTab == "abxPrevisLibForm")
			$shotsHighlighted = `treeView -q -si abxPrevisList`;
		else if ($shotTab == "abxShotsLibForm")
			$shotsHighlighted = `treeView -q -si abxShotsList`;
		else 
			$shotsHighlighted = `treeView -q -si abxShotGroupsList`;
		string $tokenBuffer[];
		string $shotName = $shotsHighlighted[0];
		tokenize $shotName ":" $tokenBuffer;
		string $nonUniqueShotName = $tokenBuffer[size($tokenBuffer)-1];

		// refresh the details UI
		abxShotsRefreshDetailsUI $nonUniqueShotName;
	}

}

global proc string abxShotsGetShortName (string $shotName){
	
	string $tokenBuffer[];
	tokenize $shotName "/" $tokenBuffer;
	string $result = $shotName;
	if (size($tokenBuffer) > 1)
		$result = $tokenBuffer[1];

	return $result;
}

global proc string abxShotsGetActiveShotFolder () {
	global string $abxShots_ShotsFolder;
	global string $abxShots_PrevisFolder;
	if (`window -exists abxShotsWindow`){
		string $tabName = `tabLayout -q -st abxShotsListTabLyt`;
		string $result;
		if ($tabName == "abxPrevisLibForm")
			$result = $abxShots_PrevisFolder;
		else if ($tabName == "abxShotsLibForm")
			$result = $abxShots_PrevisFolder;
		else if ($tabName == "abxShotGroupsLibForm")
			$result = $abxShots_PrevisFolder;
		return $result;
	}
	else{
		return "";
	}
}

global proc string abxShotsGetActiveShotTab (){
	return `tabLayout -q -st abxShotsListTabLyt`;
}

global proc string abxShotsGetActiveDeptTab (){

	global string $abxShots_AnimFolder;
	global string $abxShots_FXFolder;
	global string $abxShots_LgtFolder ;
	global string $abxShots_PrevisFolder;

	string $dept = `tabLayout -q -st abxShotsDeptTabLyt`;
	if ($dept == "abxShotsAnmFrmLyt")
		$dept = $abxShots_AnimFolder;
	else if ($dept == "abxShotsFxFrmLyt")
		$dept = $abxShots_FXFolder;
	else if ($dept == "abxShotsLgtFrmLyt")
		$dept = $abxShots_LgtFolder;
	else if ($dept == "abxShotsPreFrmLyt")
		$dept = $abxShots_PrevisFolder;
	return $dept;
}

// main procedure called when a shot is selected. This gets the shot data and it updates the UI
global proc abxShotsRefreshDetailsUI (string $shotName){

	global string $abxShots_workFolder;

	string $ppResource = `getenv PP_RESOURCE`;
	string $ppTools =`getenv MAYA_PPTOOLS`;
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	//string $shotTab = `abxShotsGetActiveShotTab`;
	
	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
	$shotFileName = `abxShotsGetShortName $shotName`;
	
	// load current details
	string $shotDetails[] = abxShotsGetShotDetails($shotName, $shotFolder);

	// get active tab to determine which dept to show
	string $dept = `abxShotsGetActiveDeptTab`;
	if ($dept == "Log"){
		$dept = "";
	}
	
	button -e -en 1 -c ("abxShotsSetShotFrameRange \""+$shotName+"\"") abxShotsEditRangeBtn;

	//print ("department is "+$dept+"\n");
	string $fldPath = ($shotsPath+$shotFileName+"/"+$dept+"/"+$abxShots_workFolder+"/");
	if ($abxShots_workFolder == "") $fldPath = ($shotsPath+$shotFileName+"/"+$dept+"/");
	string $shotsFolder[] = `getFileList -folder fldPath`;

	string $shotImg = ($shotsPath+$shotName+"/"+$shotFileName+"_comp.png");
	if (!`filetest -r $shotImg`) $shotImg = ($shotsPath+$shotName+"/"+$shotFileName+"_lgt.png");
	if (!`filetest -r $shotImg`) $shotImg = ($shotsPath+$shotName+"/"+$shotFileName+".png");
	if (!`filetest -r $shotImg`) $shotImg = ($ppTools +"/icons/shotThumb.png");

	catch(`iconTextStaticLabel -e -image $shotImg -di $shotImg abxShotsDetailImg`);

	//iconTextStaticLabel -e -i ($ppTools +"/icons/shotThumb.png") -di ($ppTools +"/icons/shotThumb.png") abxShotsDetailImg;
	

	textFieldGrp -e -text $shotName abxShotsDtlShotName;
	string $FLtokenBuffer[];
	string $focDetails = $shotDetails[11];
	tokenize $focDetails "," $FLtokenBuffer;
	textFieldGrp -e -text  ($FLtokenBuffer[0]+"mm") -editable false abxShotsDtlFocalL;
	//textFieldGrp -e -text  $shotDetails[0] abxShotsDtlRes;
	//string $shotDetails[] = abxShotsGetShotDetails($shotName, $shotFolder);
	string $filePath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName);

	int $frRange[] = abxShotsGetFrameRange($shotName,$shotFolder);

	string $assets = $shotDetails[13];
	print ("ASSETS IN SCENE:"+$shotDetails[13]+"\n");
	string $tokenBuffer[];
	tokenize $assets "," $tokenBuffer;
	string $chars= "";
	string $props= "";
	string $sets="";
	string $misc="";
	string $each;
	for ($each in $tokenBuffer){
		string $tokenBuffer2[];
		tokenize $each "|" $tokenBuffer2;
		string $tokenBuffer3[];
		tokenize $tokenBuffer2[0] "/" $tokenBuffer3;
		if ($tokenBuffer3[1] == "characters"){
			if (size($chars) != 0) $chars += ", ";
			$chars += $tokenBuffer3[2];
		}
		else if ($tokenBuffer3[1] == "props"){
			if (size($props) != 0) $props += ", ";
			$props += $tokenBuffer3[2];
		}
		else if ($tokenBuffer3[1] == "sets"){
			if (size($sets) != 0) $sets += ", ";
			$sets += $tokenBuffer3[2];
		}
		else{
			if (size($misc) != 0) $misc += ", ";
			$misc += $tokenBuffer3[2];
		}
	}

	textField -e -text $chars abxShotsDtlAstChar;
	textField -e -text $props abxShotsDtlAstProps;
	textField -e -text $sets abxShotsDtlAstSets;
	textField -e -text $misc abxShotsDtlAstMisc;

	/*
	if ($shotName != "" && `filetest -d ($filePath+"/CAM/")`){
		int $start = 0;
		int $end = 0;

		if ($shotFolder != "_PREVIS"){

			// initialize the shot data
			//int $dbExists = pprainbow();
			//int $dbExists = python("import rainbow.utils as U; U.checkDB();");
			global int $dbExists;

			
			if ($dbExists == true){
				$fail = catch(python("activeShot = R.Shot.getFromPath('"+$filePath+"')"));
				$fail = catch($start = python("activeShot.startframe"));
				$fail = catch($end = python("activeShot.endframe"));

				if ($fail)
					print("rainbow request failed for frame range request. falling back to shot_details.txt");
			}
		}

		if ($start == 0 && $shotDetails[2] != "")
			$start = $shotDetails[2];
		if ($end == 0 && $shotDetails[3] != "")
			$end = $shotDetails[3];

		floatFieldGrp -e -v1 $start -v2 $end abxShotsDtlRange;
	}
	
	
	*/
	string $something = "";
	// get the latest animation default master
	$amFile = abxShotsGetLatestWorkVersion($shotFolder, $shotName, "anm", "", "master",1);
	string $amDate = abxShotsGetMDate($amFile);
	int $amDateS = abxShotsGetMDateS($amFile);



	$lgtWorkFile = abxShotsGetLatestWorkVersion($shotFolder, $shotName, "lgt", "", "work",1);
	print ("lgtWorkFile="+$lgtWorkFile+"\n");
	string $lwDate = abxShotsGetMDate($lgtWorkFile);
	int $lwDateS = abxShotsGetMDateS($lgtWorkFile);

	textField -e -text $amDate abxShotsDtlAMDate;
	textField -e -text $lwDate abxShotsDtlRndDate;

	// If the job is story show the custom hair and cloth cache details
	if (`workspace -q -rd` == "M:/###"){
		// get the latest cache folders
		$fxHairFile = abxShotsGetLatestWorkVersion($shotFolder, $shotName, "fx", "hairSim", "work",1);
		$fCacheFolder = abxShotsGetLatestCache($fxHairFile, "hairSim");
		string $hcDate = abxShotsGetMDate($fCacheFolder);
		int $hcDateS = abxShotsGetMDateS($fCacheFolder);

		$fxClothFile = abxShotsGetLatestWorkVersion($shotFolder, $shotName, "fx", "clothSim", "work",1);
		print ("clothFile="+$fxClothFile+"\n");
		$cCacheFolder = abxShotsGetLatestCache($fxClothFile, "clothSim");
		string $ccDate = abxShotsGetMDate($cCacheFolder);
		int $ccDateS = abxShotsGetMDateS($cCacheFolder);

		textField -e -text $hcDate abxShotsDtlHCDate;
		textField -e -text $ccDate abxShotsDtlCCDate;

		if ($hcDateS<$amDateS && $amDate != "Never")
			textField -e -bgc .7 .3 .3 -ebg 1 abxShotsDtlHCDate;
		else 
			textField -e -bgc .27 .27 .27 -ebg 0 abxShotsDtlHCDate;
		if ($ccDateS<$amDateS && $amDate != "Never")
			textField -e -bgc .7 .3 .3 -ebg 1 abxShotsDtlCCDate;
		else 
			textField -e -bgc .27 .27 .27 -ebg 0 abxShotsDtlCCDate;
	}

	if ($lwDateS<$amDateS && $amDate != "Never")
		textField -e -bgc .7 .3 .3 -ebg 1 abxShotsDtlRndDate;
	else 
		textField -e -bgc .27 .27 .27 -ebg 0 abxShotsDtlRndDate;

	textField -e -text $frRange[0] abxShotsDtlRangeS;
	textField -e -text $frRange[1] abxShotsDtlRangeE;

	textFieldGrp -e -text $shotDetails[4] abxShotsDtlCamScene;
	textFieldGrp -e -text $shotDetails[5] abxShotsDtlCamDate;

	treeView -e -ra abxShotsAnmScnList;
	treeView -e -ra abxShotsFxScnList;
	treeView -e -ra abxShotsLgtScnList;
	treeView -e -ra abxShotsPreScnList;
	
	string $sorted[] = `abxShotsGetScenes $shotName $dept`;
	//print $sorted;
	string $each = "";
	for ($i=0;$i<size($sorted);$i++){

		$each = $sorted[$i];
		if($each != ""){
			if ($dept != ""){
				$dept = capitalizeString($dept);
				//textScrollList -e -append $each abxShotsAnmScnList;


				//if ($i%2)
					//treeView -e -lbc $each .15 .15 .15 abxShotsAnmScnList;
				//else
					//treeView -e -lbc $each .18 .18 .18 abxShotsAnmScnList;
				string $takeFilePath = ($filePath+"/"+toupper($dept)+"/work/"+$each);
				treeView -e -addItem $takeFilePath "" ("abxShots"+$dept+"ScnList");
				treeView -e -selectionColor $takeFilePath .8 .8 .8 ("abxShots"+$dept+"ScnList");
				string $labelName = abxShotsGetTakeLabel($takeFilePath,$takeFilePath);
				treeView -e -font $takeFilePath "fixedWidthFont" -dl $takeFilePath $labelName ("abxShots"+$dept+"ScnList");
				
				
				if (abxLockFileGetStatus($takeFilePath,0)){
					print ("Lock File for "+$takeFilePath+"\n");
					treeView -e -textColor $takeFilePath .8 .2 .2 ("abxShots"+$dept+"ScnList");
				}
			}
		}
	}
	
	string $logData[] = abxShotsGetShotLog($shotName, $shotFolder);
	string $revLog[] = abxShotsReverseArray($logData);
	//scrollField -e -cl  abxShotsLogScnList;
	treeView -e -ra abxShotsLogScnList;
	for ($each in $revLog){
		catch(`abxShotsAddLogItem $each`);
		//textScrollList -e -a $each abxAssetsLgtScnList;
		//;scrollField -e -it $each -ip 0  abxShotsLogScnList;
	}
	
	// load previous log file
	
}

global proc string[] abxShotsReverseArray( string $array[] ){
	string $newArray[];
	int $aSize = `size $array`;

	for( $n=0;$n<$aSize;$n++ ) 
		$newArray[($aSize-1-$n)]=$array[$n];
	return $newArray;
}

global proc int[] abxShotsGetFrameRange(string $shotName, string $shotFolder){
	string $shotDetails[] = abxShotsGetShotDetails($shotName, $shotFolder);
	string $filePath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName);
	int $start = -1;
	int $end = -1;
	if ($shotName != "" && `filetest -d ($filePath+"/CAM/")`){


		if ($shotFolder != "_PREVIS"){

			// initialize the shot data
			//int $dbExists = pprainbow();
			//int $dbExists = python("import rainbow.utils as U; U.checkDB();");
			global int $dbExists;

			
			if ($dbExists == true){
				$fail = catch(python("activeShot = R.Shot.getFromPath('"+$filePath+"')"));
				$fail = catch($start = python("activeShot.startframe"));
				$fail = catch($end = python("activeShot.endframe"));

				if ($fail)
					print("rainbow request failed for frame range request. falling back to shot_details.txt");
			}
		}

		if ($start <= 0 && $shotDetails[2] != "")
			$start = $shotDetails[2];
		if ($end <= 0 && $shotDetails[3] != "")
			$end = $shotDetails[3];

	}
	return {$start,$end};

}

// processes a scene file name into a table of data for nicer lists
global proc string abxShotsGetTakeLabel (string $takeName,string $filePath){

	string $shotFolder = `abxShotsGetActiveShotFolder`;
	// DEPT  TAKE          VER   MASTER
	string $noExt = `basenameEx $takeName`;
	string $tokenBuffer[];
	string $shotName;
	string $shotFileName;

	string $takeName = "";
	string $dept = "";
	tokenize $noExt "_" $tokenBuffer;

	string $version = $tokenBuffer[(size($tokenBuffer)-1)];
	if (size($tokenBuffer)>2){
		$shotName = ($tokenBuffer[0]+"/"+$tokenBuffer[0]+"_"+$tokenBuffer[1]);
		$shotFileName = $tokenBuffer[1];
		if ($tokenBuffer[(size($tokenBuffer)-2)] == "anm" || $tokenBuffer[(size($tokenBuffer)-2)] == "fx" || $tokenBuffer[(size($tokenBuffer)-2)] == "lgt" || $tokenBuffer[(size($tokenBuffer)-2)] == "pre"){
			$takeName = "default";
			$dept = $tokenBuffer[(size($tokenBuffer)-2)];
		}
	
		else {
			$takeName = $tokenBuffer[(size($tokenBuffer)-2)];
			$dept = $tokenBuffer[(size($tokenBuffer)-3)];
		}
	}

	// if its a locked file add the user name to the take name
	string $user = abxLockFileGetUser($filePath);
	string $takeNameL = $takeName;
	
	if ($user != ""){
		$takeNameL += ("("+$user+")");

	}
	
	if (size($takeNameL)>20){
		string $cropName = $takeNameL;
		$takeNameL = `substring $cropName 1 16`;
		$takeNameL += "...";
	}
	

	//string $deptUpper = toupper($dept);
	string $latestMasterVersion = "";
	if ($takeName == "default")
		$latestMasterVersion = abxShotsGetLatestWorkVersion($shotFolder,$shotName, $dept, "", "master",0);
	else 
		$latestMasterVersion = abxShotsGetLatestWorkVersion($shotFolder,$shotName, $dept, $takeName, "master",0);

	if ($latestMasterVersion == "v000"){
		$latestMasterVersion = "----";
	}
	// find master and print the version if found
	//$masterDirGuess = (`workspace -q -rd`+"/scenes/"+$shotFolder+"/"+$shotName+"/"+$deptUpper+"/master/");
	//$masterFilePath = ($masterDirGuess+$shotNameGuess+"_"+$deptGuess+"_master_"+$workVersion+".mb");

	while (size($dept)<8){
		$dept += " ";
	}
	while (size($takeNameL)<20){
		$takeNameL += " ";
	}
	while (size($version)<9){
		$version += " ";
	}

	while (size($latestMasterVersion) < 8){
		$latestMasterVersion += " ";
	}
	return ($dept+$takeNameL+$version+$latestMasterVersion);
}
/*
global proc abxShotsUpdateTakeMenu (string $dept) {

	string $selectedTake[] = `treeView -q -si ("abxShots"+$dept+"ScnList")`;
	menuItem -e -label $selectedTake[0] ("abxShots"+$dept+"MenuItemTitle");
}
*/

global proc int abxShotsUpdateTakeMenu (string $itemName) {
	$dept = `abxShotsGetActiveDeptTab`;
	$dept = capitalizeString($dept);
	treeView -e -cs ("abxShots"+$dept+"ScnList");
	treeView -e -si $itemName 1 ("abxShots"+$dept+"ScnList");
	string $menuLabel = basename($itemName,"");
	menuItem -e -label $menuLabel ("abxShots"+$dept+"ScnListMenuLabel");
	abxShotsSetActiveTake ($itemName,1);
	return true;

}

global proc int abxShotsSetActiveTake (string $shotName, int $state) {

	$dept = `abxShotsGetActiveDeptTab`;
	$dept = capitalizeString($dept);
	$treeView = ("abxShots"+$dept+"ScnList");
	if ($state == 1){
		treeView -e -textColor $shotName .2 .2 .2 $treeView;
	}
	else{
		treeView -e -textColor $shotName .8 .8 .8 $treeView;
	}
	return 1;
}

global proc int abxShotsTakeListDblClk (string $sceneName){
	string $shotTab = `abxShotsGetActiveShotTab`;
	$dept = `abxShotsGetActiveDeptTab`;
	$dept = capitalizeString($dept);
	abxShotsOpenTake ("abxShots"+$dept+"ScnList");
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $shotName[];
	if ($shotTab == "abxPrevisLibForm")
		$shotName = `treeView -q -si abxPrevisList`;
	else if ($shotTab == "abxShotsLibForm")
		$shotName = `treeView -q -si abxShotsList`;
	else 
		$shotName = `treeView -q -si abxShotGroupsList`;

	string $shotToken[];
	tokenize $shotName[0] ":" $shotToken;
	if (size($shotToken)>1)
		$shotName[0] = $shotToken[size($shotToken)-1];

	abxShotsRefreshDetailsUI($shotName[0]);
	return 1;
}


global proc abxShotsPackTake(string $sourceList ){

	string $shotFolder = `abxShotsGetActiveShotFolder`;

	// get active tab to determine which dept to show
	string $dept = `abxShotsGetActiveDeptTab`;

	string $takeSceneName[] = `treeView -q -si $sourceList`;
	$takeSceneName[0] = basename($takeSceneName[0],"");
	if (size($takeSceneName)>0){
		string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
		string $shotName[];
		if ($shotFolder == "_PREVIS")
			$shotName = `treeView -q -si abxPrevisList`;
		else 
			$shotName = `treeView -q -si abxShotsList`;
		//string $shotFileName = `abxShotsGetShortName $shotName[0]`;
		string $takeFullPath = ($shotsPath+$shotName[0]+"/"+toupper($dept)+"/work/"+$takeSceneName[0]);
		string $takeProjPath= `workspace -pp $takeFullPath `;
		
		string $packScriptSource = (`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Misc/ppPackScene.mel");
		
		if (!`exists ppPackScene`){
			eval("source \""+$packScriptSource+"\"");
		}
		if (!`window -ex ppPackSceneWindow`)
			ppPackScene;
		string $scenePath = "";
		textScrollList -e -append $takeProjPath ppPackSceneFLScrlLst;
	}
}

global proc abxShotsBuildSeqUberCam (string $seqName){
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $seqChildren[];
	string $dept = "";
	if ($shotFolder == "_PREVIS"){
		$seqChildren = `treeView -q -ch $seqName abxPrevisList`;
		$dept = "pre";
	}
	else {
		$seqChildren = `treeView -q -ch $seqName abxShotsList`;
		$dept = "anm";
	}
	string $packScriptSource = (`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Misc/uberCam.mel");
	eval("source \""+$packScriptSource+"\"");
	uberCam;

	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
	// get a list of the shots listed in the tree view
	//print ("starting\n");
	for ($shotName in $seqChildren){
		string $shotFileName = `abxShotsGetShortName $shotName`;
		// get the latest work scene
		string $latestWorkVersion = abxShotsGetLatestWorkVersion($shotFolder, $shotName, $dept, "", "work",0);
		string $takeSceneName = ($shotFileName+"_"+$dept+"_"+$latestWorkVersion+".ma");
		string $takeFullPath = ($shotsPath+$shotName+"/"+toupper($dept)+"/work/"+$takeSceneName);
		string $masterCamFullPath = ($shotsPath+$shotName+"/CAM/master/"+$shotFileName+"_cam_master.ma");
		print ($takeFullPath+"\n");
		string $addPath = $takeFullPath;

		//if (`filetest -r $masterCamFullPath`){
		//	$addPath = $masterCamFullPath;
		//}
		//else if (`filetest -r $takeFullPath`){
		//	$addPath = $takeFullPath;
		//}

		if (`filetest -r $addPath`){
			
			if (`window -ex uberCamGUIWindow`){
				if (`textScrollList -ex uberCamGUITScrlList`){
					textScrollList -e -append $addPath uberCamGUITScrlList;
				}
			}
		}
	}
}

global proc abxShotsBuildAutoCache (string $seqName) {
	print ("WHY DOESN'T IT EXECUTE\n");
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $seqChildren[];
	string $dept = "";

	if ($shotFolder == "_PREVIS"){
		$seqChildren = `treeView -q -ch $seqName abxPrevisList`;
		$dept = "pre";
	}

	else {
		$seqChildren = `treeView -q -ch $seqName abxShotsList`;
		$dept = "anm";
	}
	
	string $packScriptSource = (`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Misc/autoCache.mel");
	eval("source \""+$packScriptSource+"\"");
	
	evalEcho("autoCache");
	
	
	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
	// get a list of the shots listed in the tree view
	//print ("starting\n");
	for ($shotName in $seqChildren){
		string $shotFileName = `abxShotsGetShortName $shotName`;
		// get the latest work scene
		string $latestWorkVersion = abxShotsGetLatestWorkVersion($shotFolder, $shotName, "anm", "", "master",0);
		string $takeSceneName = ($shotFileName+"_anm_master_"+$latestWorkVersion+".mb");
		string $takeFullPath = ($shotsPath+$shotName+"/"+toupper($dept)+"/master/"+$takeSceneName);
		string $masterCamFullPath = ($shotsPath+$shotName+"/CAM/master/"+$shotFileName+"_cam_master.ma");
		print ($takeFullPath+"\n");
		string $addPath = $takeFullPath;

		if (`filetest -r $addPath`){
			if (`window -ex autoCacheWindow`){
				if (`textScrollList -ex autoCacheTScrlList`){
					textScrollList -e -append $addPath autoCacheTScrlList;
				}
			}
		}
	}
	
}


global proc abxShotsBuildPlaybomb (string $seqName) {

	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $seqChildren[];
	string $dept = "";
	if ($shotFolder == "_PREVIS"){
		$seqChildren = `treeView -q -ch $seqName abxPrevisList`;
		$dept = "pre";
	}
	else {
		$seqChildren = `treeView -q -ch $seqName abxShotsList`;
		$dept = "anm";
	}
	string $packScriptSource = (`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Misc/playbomb.mel");
	eval("source \""+$packScriptSource+"\"");
	playbomb;

	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
	// get a list of the shots listed in the tree view
	//print ("starting\n");
	for ($shotName in $seqChildren){
		string $shotFileName = `abxShotsGetShortName $shotName`;
		// get the latest work scene
		string $latestWorkVersion = abxShotsGetLatestWorkVersion($shotFolder, $shotName, "anm", "", "work",0);
		string $takeSceneName = ($shotFileName+"_anm_"+$latestWorkVersion+".ma");
		string $takeFullPath = ($shotsPath+$shotName+"/"+toupper($dept)+"/work/"+$takeSceneName);
		string $masterCamFullPath = ($shotsPath+$shotName+"/CAM/master/"+$shotFileName+"_cam_master.ma");
		print ($takeFullPath+"\n");
		string $addPath = $takeFullPath;

		if (`filetest -r $addPath`){
			if (`window -ex playbombWindow`){
				if (`textScrollList -ex playbombTScrlList`){
					textScrollList -e -append $addPath playbombTScrlList;
				}
			}
		}
	}
}

global proc abxShotsBuildUberCam (string $sourceList){
	string $shotFolder = `abxShotsGetActiveShotFolder`;

	// get active tab to determine which dept to show
	string $dept = `abxShotsGetActiveDeptTab`;

	string $takeSceneName[] = `treeView -q -si $sourceList`;
	$takeSceneName[0] = basename($takeSceneName[0],"");
	if (size($takeSceneName)>0){
		string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
		string $shotName[];
		if ($shotFolder == "_PREVIS")
			$shotName = `treeView -q -si abxPrevisList`;
		else 
			$shotName = `treeView -q -si abxShotsList`;
		string $shotFileName = `abxShotsGetShortName $shotName[0]`;

		string $takeFullPath = ($shotsPath+$shotName[0]+"/"+toupper($dept)+"/work/"+$takeSceneName[0]);
		string $masterCamFullPath = ($shotsPath+$shotName[0]+"/CAM/master/"+$shotFileName+"_cam_master.ma");
		string $takeProjPath= `workspace -en $takeFullPath `;

		string $packScriptSource = (`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Misc/uberCam.mel");
		eval("source \""+$packScriptSource+"\"");

		string $addPath = "";

		if (`filetest -r $masterCamFullPath`){
			$addPath = $masterCamFullPath;
		}
		else if (`filetest -r $takeFullPath`){
			$addPath = $takeFullPath;
		}

		if (`filetest -r $addPath`){
			uberCam;
			if (`window -ex uberCamGUIWindow`){
				if (`textScrollList -ex uberCamGUITScrlList`){
					textScrollList -e -append $addPath uberCamGUITScrlList;
				}
			}
		}
	}
}


// TODO more detailed UI for adding Take/Scene
/*
global proc abxShotsShowAddTakeUI (string $shotFolderTab) {

	if (!`window -exists abxShotsAddTakeWindow`){
		window -t "Add Scene" -width 500 -height 200 abxShotsAddTakeWindow;
		formLayout abxShotsAddTakeUIFrmLyt;
		frameLayout -lv 0 -borderStyle "out" abxShotsAFrmeLyt;
		columnLayout;

		
		optionMenuGrp -label "Location:" -columnWidth 2 80 -cw 3 100 -cc abxShotsUpdateNewShotUI abxShotsCreateTypeOM;
			menuItem -label "_PREVIS";
			menuItem -label "_ALL_SHOTS";
		optionMenuGrp -e -sl 2 abxShotsCreateTypeOM;
		rowLayout -numberOfColumns 2 -columnWidth2 250 100 -columnAttach 1 "both" 0 -columnAttach 2 "both" 0 abxShotsNewSeqRL;
			optionMenuGrp -label "Sequence:"  -columnWidth 2 80 -cw 3 100 -cc abxShotsUpdateNewShotUI abxShotsCreateOMTmpl;	
				menuItem -label "none";
				string $loc =  `optionMenuGrp -q -value abxShotsCreateTypeOM`;
				string $foundSeq[] = `abxShotsGetSequences $loc`;
				for ($each in $foundSeq){
					menuItem -label $each;
				}	
			button -label "New Sequence..." -c "abxShotsNewSequence `optionMenuGrp -q -v abxShotsCreateTypeOM`";
			setParent ..;
		// asset name
		textFieldGrp -label "Shot Name:" -text  "S1_010"  abxShotsCreateTFName;

		// asset method

		setParent abxShotsAddTakeUIFrmLyt;

		rowLayout -numberOfColumns 3 -columnWidth3 160 160 160 -columnAttach 1 "both" 0 -columnAttach 2 "both" 0 -columnAttach 3 "both" 0 abxShotsNewShotRL;
		button -label "Add" -h 25 -c "" ;
		button -label "Apply" -h 25 -c "";
		button -label "Cancel" -h 25 -c "";


		formLayout -e 
			-af abxShotsNewShotFrmeLyt "left" 3
			-af abxShotsNewShotFrmeLyt "top" 3
			-af abxShotsNewShotFrmeLyt "bottom" 34
			-af abxShotsNewShotFrmeLyt "right" 3

			-af abxShotsNewShotRL "left" 0
			-ac abxShotsNewShotRL  "top" 0 abxShotsNewShotFrmeLyt
			-af abxShotsNewShotRL "bottom" 3
			-af abxShotsNewShotRL "right" 3
			abxShotsAddTakeUIFrmLyt;
			
		if ($shotFolderTab == "abxShotsLibForm"){
			optionMenuGrp -e -value "_ALL_SHOTS" abxShotsCreateTypeOM;
			abxShotsUpdateNewShotUI;
		}
		else if ($shotFolderTab == "abxPrevisLibForm"){
			optionMenuGrp -e -value "_PREVIS" abxShotsCreateTypeOM;
			abxShotsUpdateNewShotUI;
		}
		showWindow abxShotsAddTakeWindow;
	}
	else {
		showWindow abxShotsAddTakeWindow;
	}
}
*/
global proc abxShotsOpenTake (string $sourceList) {
	// set a global string to mark which dept the open take was called from. this helps the reference locking proc know how to lock the file
	global string $deptOpen;

	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $shotTab = `abxShotsGetActiveShotTab`;

	// get active tab to determine which dept to show
	string $dept = `abxShotsGetActiveDeptTab`;

	//string $takeSceneName[] = `textScrollList -q -si $sourceList`;
	string $takeSceneName[] = `treeView -q -si $sourceList`;
	$takeSceneName[0] = basename($takeSceneName[0],"");
	if (size($takeSceneName)>0){
		string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
		string $shotName[];
		if ($shotTab == "abxPrevisLibForm")
			$shotName = `treeView -q -si abxPrevisList`;
		else if ($shotTab == "abxShotsLibForm")
			$shotName = `treeView -q -si abxShotsList`;
		else 
			$shotName = `treeView -q -si abxShotGroupsList`;
		string $shotToken[];
		tokenize $shotName[0] ":" $shotToken;
		if (size($shotToken)>1)
			$shotName[0] = $shotToken[size($shotToken)-1];
		//print ("set shotname to "+$shotName[0]+"\n");

		$shotFileName = `abxShotsGetShortName $shotName[0]`;
		string $mayaFormat = `fileExtension $takeSceneName[0]`;
		if ($mayaFormat == "ma")
			$mayaFormat = "mayaAscii";
		else if ($mayaFormat == "mb")
			$mayaFormat = "mayaBinary";

		string $fileToOpen = $shotsPath+$shotName[0]+"/"+toupper($dept)+"/work/"+$takeSceneName[0];
		print ("$fileToOpen="+$fileToOpen+"\n");

		// check for file lock and prompt if locked
		$lockStatus = abxLockFileGetStatus($fileToOpen,1);
		if ($lockStatus == 1){
			return;
		}
		// set the global var to the dept so that reference locking can guess how to lock the file we are about to open.
		$deptOpen = $dept;
		abxShotsLoadHUDStatus($fileToOpen);
		string $cmd = "";

		// if the user chose to not change ownership and open as read-only instead
		if ($lockStatus != 2)
			$cmd = ("saveChanges(\"abxLockFileCheckOut(\\\"\\\");file -f -o \\\""+$fileToOpen+"\\\";abxLockFileCheckIn(\\\""+$fileToOpen+"\\\");\");");
		else
			$cmd = ("saveChanges(\"abxLockFileCheckOut(\\\"\\\");file -f -o \\\""+$fileToOpen+"\\\";\");");

		$cmd += ("addRecentFile(\""+$fileToOpen+"\", \""+$mayaFormat+"\");");
		evalEcho $cmd;

		//print ("//\n//THE DEPT IS "+$dept+"\n//\n");
		if ($dept == "anm" || $dept == "pre"){

			// check for props needed by set assembly
			//print ("//\n// CHECKING FOR PROps "+$dept+"\n//\n");
			abxAssetsCheckForProps({""});
			abxAssetsUpdatePropInstances {""} 0;
			//renderThumbnailUpdate true;

			
			catch(`abxShotsUseAudioMaster`);

			abxShotsFixStoryNeonRefs;
			// add a deleteSet
			if (!`objExists deleteSet`) sets -empty -n deleteSet;
			// add a _PREVIS_ group
			if (!`objExists "_PREVIS_"`) 
				createNode transform -skipSelect -name "_PREVIS_";
			// add a _PREVIS_ group
			if (!`objExists "_CUSTOM_"`) 
				createNode transform -skipSelect -name "_CUSTOM_";

			string $outlinerNodes[] = {"_PREVIS_","_CUSTOM_","_SETS_","_PROPS_","_CHARACTERS_","side","front","top","persp"};
			for ($each in $outlinerNodes){
				if (!`objExists $each`) {
					createNode transform -skipSelect -name $each;
				}
				reorder -front $each;
				catch(`setAttr ($each+".overrideEnabled") 1`);
				if ($each == "_ENVIRONMENT_")
					catch(`setAttr ($each+".overrideColor") 11`);
				else if ($each == "_PROPS_")
					catch(`setAttr ($each+".overrideColor") 28`);
				else if ($each == "_PREVIS_")
					catch(`setAttr ($each+".overrideColor") 8`);
			}

			// code to handle the depricated _ENVIRONMENT_ group so that it is now called "_SETS_"
			if (`workspace -q -rd` != "M:/STORY2012_PP10088/3D/STORY2012_maya/"){
				if (`objExists "_ENVIRONMENT_"`){
					if (!`objExists "_SETS_"`){
						rename "_ENVIRONMENT_" "_SETS_";
					}
					else {
						$envChildren = `listRelatives -children _ENVIRONMENT_`;
						for ($each in $envChildren){
							catch(eval("parent "+$each+" _SETS_"));
						}
						catch(eval("delete _ENVIRONMENT_"));
					}
				}
				if (`objExists "_SETS_1"`){
					$envChildren = `listRelatives -children "_SETS_1"`;
					for ($each in $envChildren){
						catch(eval("parent "+$each+" _SETS_"));
					}
					catch(eval("delete _SETS_1"));
				}
			}
			
			// makes sure camera is set to off-axis mode for stereo checks
			if (`objExists master:stereoCam`){
				setAttr ("master:stereoCamCenterCamShape.stereo") 2;
			}
			else if (`objExists stereoCam`){
				setAttr ("stereoCamCenterCamShape.stereo") 2;
			}
		}

		// check for references in scene file that need updating
		if ($dept == "lgt" || $dept == "fx"){
			// ad set current layer here
			//renderThumbnailUpdate false;

			editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;
			if (!`objExists deleteSet`) sets -empty -n "deleteSet";
			print ("Checking Take References\n");
			abxShotsCheckAllRefsForUpdate;
			// list references


		}

		// check for updates to shaders - lighting only for now
		if ($dept == "lgt")  {
			//cbxShotsCheckAllAssetsForShaderUpdates();

			// find and setup latest hair / cloth caches
			//autoCacheFindLatest "clothSim";
			//autoCacheFindLatest "hairSim";
		}
		
	}
	$deptOpen = "";
}

// for all geo or ctrl, lock anything called control's TRS
global proc abxShotsLockTRS(){

	// lock all transforms
	$xforms = `ls -exactType transform`;
	for ($each in $xforms){
		// unlock node
		catch(`lockNode -l 0 $each`);
		$attrsToLock = {"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
		$ignore = {"persp","top","front","side"};
		if (!stringArrayContains($each, $ignore)){
			for ($attrs in $attrsToLock){
				// if the attr is connected then dont lock it
				//if (size(`listConnections -d off -s on ($each+"."+$attrs)`)==0){
					catch(`setAttr -lock true ($each+"."+$attrs)`);
				//}
			}
		}
	}
}

global proc abxShotsUnLockTRS(){

	// lock all transforms
	$xforms = `ls -exactType transform`;
	for ($each in $xforms){
		// unlock node
		catch(`lockNode -l 0 $each`);
		$attrsToLock = {"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
		for ($attrs in $attrsToLock){
			catch(`setAttr -lock false ($each+"."+$attrs)`);
		}
	}
}

global proc abxShotsCheckAllRefsForUpdate(){
	
	string $referencePath[] = `file -q -r`;
	for ($each in $referencePath){
		// if it contains a master file as a reference 
		if (`gmatch $each "*master*"`){
			print ("checking: "+$each+"\n");
			abxShotsCheckRefForUpdate($each);
		}
	}	
}

global proc abxShotsCheckRefForUpdate (string $referencePath){
	// get the version number
	string $shotFolder;
	string $filename = `basenameEx $referencePath`;
	string $masterFolderPath = `dirname $referencePath`;
	string $rnNode = `referenceQuery -rfn $referencePath`;
	
	string $tokenBuffer[];
	tokenize $filename "_" $tokenBuffer;
	$curVersion = $tokenBuffer[size($tokenBuffer)-1];

	if (size($curVersion) > 0){
		// get the latest version number
		string $fileFormat = "mayaBinary";
		string $shotName = "";
		string $shotFileName = "";
		string $dept = "";
		string $takeName = "";
		if (size($tokenBuffer)>3){
			$shotName = ($tokenBuffer[0]+"/"+$tokenBuffer[0]+"_"+$tokenBuffer[1]);
			$shotFileName = ($tokenBuffer[0]+"_"+$tokenBuffer[1]);
			if ($tokenBuffer[(size($tokenBuffer)-3)] == "anm" || $tokenBuffer[(size($tokenBuffer)-3)] == "fx" || $tokenBuffer[(size($tokenBuffer)-3)] == "lgt" || $tokenBuffer[(size($tokenBuffer)-3)] == "pre"){
				$dept = $tokenBuffer[(size($tokenBuffer)-3)];
			}
		
			else {
				$takeName = $tokenBuffer[(size($tokenBuffer)-3)];
				$dept = $tokenBuffer[(size($tokenBuffer)-4)];
			}
		}

		// need to fix masterFolderPath which has a whitespace in front of it for some reason
		string $tokenBuffer2[];
		print ("workspace -pp \""+$masterFolderPath+"\"\n");
		string $projPath = `workspace -pp $masterFolderPath`;
		tokenize $masterFolderPath "/" $tokenBuffer2;
		if (size($tokenBuffer2)>1)
			$shotFolder = $tokenBuffer2[5];

		string $latestMasterVersion = abxShotsGetLatestWorkVersion($shotFolder, $shotName, $dept, $takeName, "master",0);
		print ("abxShotsGetLatestWorkVersion("+$shotFolder+", "+$shotName+", "+$dept+", "+$takeName+", \"master\",0)"+"\n");
		string $newPath = $masterFolderPath;
		string $fullnewPath;
		if ($takeName != "")
			$newPath += ("/"+$shotFileName+"_"+$dept+"_"+$takeName);
		else 
			$newPath += ("/"+$shotFileName+"_"+$dept);

		if ($latestMasterVersion != "v000")
			$fullnewPath = $newPath + ("_master_"+$latestMasterVersion+".mb");
		else 
			$fullnewPath = $newPath + ("_master.mb");

		// if mb doesn't exist then try .ma
		if (!`filetest -r $fullnewPath`){
			$fileFormat = "mayaAscii";
			if ($latestMasterVersion != "v000")
				$fullnewPath = $newPath + ("_master_"+$latestMasterVersion+".ma");
			else 
				$fullnewPath = $newPath + ("_master.ma");
		}

		// if the latest version number is greater than the reference
		if (int(`match "[0-9]+" $latestMasterVersion`) > int(`match "[0-9]+" $curVersion`)){
			$result = `confirmDialog -title "Shot Manager: Update Master?" -message ("There appears to be a new master for "+$shotFileName+"_"+$dept+"_"+$takeName+".") -button "Reload with Latest Master" -button "Keep Current Version" -button "Cancel" -defaultButton "Reload with Latest Master" -cancelButton "Cancel" -dismissString "Cancel"`;
			if ($result == "Reload with Latest Master"){
				evalEcho ("file -loadReference \""+$rnNode+"\" -type \""+$fileFormat+"\" -options \"v=0\" \""+$fullnewPath+"\"");
					
				// replace the reference file to the new one
			}
			else if ($result == "Keep Current Version"){
				
			}
		}
	}
}


string $cbxShotsCheckAssetForShaderUpdatesAllChoice = "";
global proc cbxShotsCheckAllAssetsForShaderUpdates ()  {

	/// add local source
	eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Lighting/abxExportShaderMel.mel\"");
	eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Production/abxAssets.mel\"");
	global string $cbxShotsCheckAssetForShaderUpdatesAllChoice;

	print("Checking for shader updates on assets\n");
	$cbxShotsCheckAssetForShaderUpdatesAllChoice = "";
	string $assets[] = abxAssetsGetAssetsInScene();
	for ($asset in $assets)  {
		print("Checking asset: " + $asset + " for updated shaders\n");
		cbxShotsCheckAssetForShaderUpdates($asset);

		if ($cbxShotsCheckAssetForShaderUpdatesAllChoice == "No To All")
			break;
	}
}

// asset will be something referenced in from the anim master
// examples: anm:EonTest anm:KaosShaderTest
global proc cbxShotsCheckAssetForShaderUpdates (string $asset)  {
	global string $cbxShotsCheckAssetForShaderUpdatesAllChoice;

	eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Lighting/abxExportShaderMel.mel\"");


	string $assetShapes[] = `listRelatives -allDescendents -type mesh -type nurbsSurface -noIntermediate ($asset + ":ROOT")`;
	for ($sh in $assetShapes)  {
		string $sgs[] = `listSets -t 1 -o $sh`;
		if (size($sgs) > 0)  {
			string $sg = $sgs[0];
			string $curShaderVersion = `getAttr ($sg + ".shaderVersion")`;

			string $assetPath = `getAttr ($sg + ".assetPath")`;
			string $latestShaderInfo[] = cbxShotsGetLatestAssetShaderInfo($assetPath);
			string $latestShaderVersion = $latestShaderInfo[0];
			string $latestShaderFolder = $latestShaderInfo[1];

			if ($curShaderVersion != $latestShaderVersion)  {
				string $result = "Yes";

				if ($cbxShotsCheckAssetForShaderUpdatesAllChoice != "Yes To All")  {
					$result = `confirmDialog -title "abxShots Confirm"
						-message ("Asset: " + $asset + " has newer shaders available (current: " + $curShaderVersion + " latest: " + $latestShaderVersion + ")\nUpdate Shaders?")
						-button "Yes" -button "Yes To All" -button "No" -button "No To All" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
					if ($result == "Yes To All")  {
						$cbxShotsCheckAssetForShaderUpdatesAllChoice = $result;
						$result = "Yes";
					}
					if ($result == "No To All")  {
						$cbxShotsCheckAssetForShaderUpdatesAllChoice = $result;
						return;
					}
				}

				if ($result == "Yes")  {
					string $shaderFolder = (`workspace -q -rd` + "/" + $assetPath + "/shaders/master/" + $latestShaderFolder + "/");
					string $melShaderFiles[] = `getFileList -folder $shaderFolder`;
					for ($i = 0; $i < size($melShaderFiles); ++$i)
							$melShaderFiles[$i] = ($shaderFolder + $melShaderFiles[$i]);
					// need to get rid of old shader nodes, or import will ask to rename new one
					importShadingNetworkMEL($melShaderFiles, 3);
				}
			}

			break;	// just need to test one SG on one object in asset
		}
	}
}

global proc string[] cbxShotsGetLatestAssetShaderInfo (string $assetPath)  {

	string $shaderTopFolder = (`workspace -q -rd` + "/" + $assetPath + "/shaders/master/"); // must have / at end!
	string $shaderFolders[] = `getFileList -folder $shaderTopFolder`;
	string $versMaxStr = "";
	string $versMaxShaderFolderStr = "";
	int $versMax = -100000000;
	for ($sf in $shaderFolders)  {
		string $versStr = endString($sf, 4);
		if (isValidString($versStr, "v[0-9][0-9][0-9]"))  {
			int $versInt = int(endString($versStr, 3));
			if ($versInt > $versMax)  {
				$versMaxStr = $versStr;
				$versMaxShaderFolderStr = $sf;
				$versMax = $versInt;
			}
		}
	}
	return {$versMaxStr, $versMaxShaderFolderStr};
}

/*
global proc abxShotsSaveAsTake (string $sourceList){

	string $shotFolder = `abxShotsGetActiveShotFolder`;
	// get the scene name, if it doesn't match then confirm with the user that they want save into the shot
	string $currentScenePath = `file -q -sn`;
	string $sceneFileName = basenameEx($currentScenePath);

	// get active tab to determine which dept to show
	string $dept = `abxShotsGetActiveDeptTab`;

	string $takeSceneName[] = `textScrollList -q -si $sourceList`;
	if (size($takeSceneName)>0){

		string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
		string $selectedItems[] = `treeView -q -si abxShotsList`;
		string $shotName = `abxShotsGetSceneShotName $takeSceneName[0]`;
		string $takeName = `abxShotsGetSceneTakeName $takeSceneName[0]`;

		string $sceneShotName = `abxShotsGetSceneShotName $

	}

	// rename the scene

	// incremental save the scene
}
*/

/////////////////////////////////////////////////////////////////////////////////
///////////////////TAKE MASTERING////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

global proc abxShotsMasterTake(int $force, int $inBG, string $sourceList, string $version, string $note){

	string $shotFolder = `abxShotsGetActiveShotFolder`;

	// get active tab to determine which dept to show
	string $dept = `abxShotsGetActiveDeptTab`;

	string $takeSceneName[] = `treeView -q -si $sourceList`;
	$takeSceneName[0] = basename($takeSceneName[0],"");
	if (size($takeSceneName)>0){
	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
	string $selectedItems[] = `treeView -q -si abxShotsList`;
	string $shotName = $selectedItems[0] ;//`abxShotsGetSceneShotName $takeSceneName[0]`;
	string $takeName = `abxShotsGetSceneTakeName $takeSceneName[0]`;

	if ($version == "")
		$version = "latest";
	if ($version == "latestMaster"){
		print ("abxShotsGetLatestWorkVersion(\""+$shotFolder+"\" \""+$shotName+"\", \""+$dept+"\", \""+$takeName+"\", \"master\",0);\n");
		$version = abxShotsGetLatestWorkVersion($shotFolder, $shotName, $dept, $takeName, "master",0);
	}


	string $cmd = ("abxShotsMaster "+$force+" 0 \""+$shotFolder+"\" \""+$shotName+"\" \""+$dept+"\" \""+$takeName+"\" \""+$version+"\" \""+$note+"\"");
	string $eCmd = `encodeString $cmd`;
	//callMayaBG 1 1 `file -q -sn` `workspace -q -rd` "" "abxShotsMaster \"TEST\TEST_010\" "";
	if ($inBG){

		string $oldPluginPath = `getenv MAYA_PLUG_IN_PATH`;
		// set the shave plugin to load by adding it to plugin paths
		putenv "MAYA_PLUG_IN_PATH" (`getenv PP_RESOURCE`+"\\bin\\win32\\shaveHaircut\\maya2012\\plug-ins;"+$oldPluginPath);

		//$eCmd2 = (`encodeString "source \"//monkey/resources/maya/2012-x64/scripts/production/abxShots_dev.mel\";"`+$eCmd);
		callMayaBG (1, 1, "", `workspace -q -rd`, "", $eCmd);

		// restore the plugin path so shave doesn't load while this maya is open.
		putenv "MAYA_PLUG_IN_PATH" $oldPluginPath;
	}
	else{
		evalEcho($cmd);	
	}

	abxShotsDeptTabChange;

	}

}

global proc abxShotsOpenMaster(string $sourceList){

	string $shotFolder = `abxShotsGetActiveShotFolder`;

	// get active tab to determine which dept to show
	string $dept = `abxShotsGetActiveDeptTab`;

	string $takeSceneName[] = `treeView -q -si $sourceList`;
	$takeSceneName[0] = basename($takeSceneName[0],"");
	if (size($takeSceneName)>0){
	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
	string $selectedItems[] = `treeView -q -si abxShotsList`;
	string $shotName = `abxShotsGetSceneShotName $takeSceneName[0]`;
	string $takeName = `abxShotsGetSceneTakeName $takeSceneName[0]`;

	string $masterFile = "";

	if ($takeName == "")
		$masterFile = ($shotName+"_"+$dept+"_master.mb");
	else
		$masterFile = ($shotName+"_"+$dept+"_"+$takeName+"_master.mb");

	// if the mb isn't found then try ascii
	if (!`filetest -r $masterFile`){
		if ($takeName == "")
			$masterFile = ($shotName+"_"+$dept+"_master.ma");
		else
			$masterFile = ($shotName+"_"+$dept+"_"+$takeName+"_master.ma");		
	}
	
	string $cmd = ("saveChanges(\"abxLockFileCheckOut(\\\"\\\");file -f -o \\\""+$shotsPath+$shotName+"/"+toupper($dept)+"/master/"+$masterFile+"\\\";abxLockFileCheckIn(\\\""+$shotsPath+$shotName+"/"+toupper($dept)+"/master/"+$masterFile+"\\\");\")");
	evalEcho $cmd;
	}

}

global proc abxShotsReferenceMaster (string $sourceList){

	string $shotFolder = `abxShotsGetActiveShotFolder`;

	// get active tab to determine which dept to show
	string $dept = `abxShotsGetActiveDeptTab`;

	string $takeSceneName[] = `treeView -q -si $sourceList`;
	$takeSceneName[0] = basename($takeSceneName[0],"");
	if (size($takeSceneName)>0){
		string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
		string $shotName= "";
		string $shotNames[];
		// get the selected shot
		if (`treeView -exists abxShotsList`){
		
			if ($shotFolder == "_PREVIS")
				$shotNames = `treeView -q -si abxPrevisList`;
			else 
				$shotNames = `treeView -q -si abxShotsList`;
		}
		$shotName = $shotNames[0];

		string $takeName = `abxShotsGetSceneTakeName $takeSceneName[0]`;
		string $shotFileName = `abxShotsGetShortName $shotName`;
		string $masterFile = "";

		string $latestMasterVersion = abxShotsGetLatestWorkVersion($shotFolder, $shotName, $dept, $takeName, "master",0);

		if ($takeName == "")
			$masterFile = ($shotFileName+"_"+$dept+"_master_"+$latestMasterVersion +".mb");
		else
			$masterFile = ($shotFileName+"_"+$dept+"_"+$takeName+"_master_"+$latestMasterVersion +".mb");

		
		string $masterFilePath = ($shotsPath+$shotName+"/"+toupper($dept)+"/master/"+$masterFile);
		print ("First Trying (.mb): "+$masterFilePath+"\n");
		// try finding an ascii file instead
		if (!`filetest -r $masterFilePath`){
			if ($takeName == "")
				$masterFile = ($shotFileName+"_"+$dept+"_master_"+$latestMasterVersion +".ma");
			else
				$masterFile = ($shotFileName+"_"+$dept+"_"+$takeName+"_master_"+$latestMasterVersion +".ma");
		}


		$masterFilePath = ($shotsPath+$shotName+"/"+toupper($dept)+"/master/"+$masterFile);
		print ("Settled On: "+$masterFilePath+"\n");

		if (`filetest -r $masterFilePath`){
			$takeNameUpper = toupper(`substring $takeName 1 1`);
			int $takeNameLen = size($takeName);
			$takeNameUpper = ($takeNameUpper + `substring $takeName 2 $takeNameLen`);
			$wrkspcPath = `workspace -pp $masterFilePath`;
			$result = `confirmDialog -title "Shot Manger: Create Reference Confirm" -message ("Confirm: Create a Reference to "+$wrkspcPath) -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
			if ($result == "OK"){
				abxShotsCreateReference $masterFilePath ($dept+$takeNameUpper) "namespace" 0;
			}
			else {
				error ("User Canceled Create Reference");
			}
		}
		else{
			$result = `confirmDialog -title "Shot Manger: Master Error" -message "Master File Does Not Exist For this Scene." -button "OK" -defaultButton "OK" -cancelButton "OK" -dismissString "OK"`;
			error ("Master File Not Found");
		}
	}
}

global proc abxShotsCreateReference (string $refFile, string $prefix, string $type, int $lock){
		
	string $lockFlag = "";
	if ($lock)
		$lockFlag = "-lck ";

	if ($type == "rename"){
		namespace -set ":";
		//evalEcho ("file -r -gl -loadReferenceDepth \"all\" -rpr \""+$prefix+"\" -options \"v=0\" \""+$refFile+"\"");
		evalEcho ("file -r "+$lockFlag+"-gl -loadReferenceDepth \"all\" -rpr \""+$prefix+"\" -options \"v=0\" \""+$refFile+"\"");
		namespace -set ":";
	}
	else if ($type == "namespace"){
		namespace -set ":";
		//evalEcho ("file -r -type \"mayaAscii\" -gl -loadReferenceDepth \"all\" -namespace \""+$prefix+"\" -options \"v=0\" \""+$refFile+"\"");
		evalEcho ("file -r "+$lockFlag+"-gl -loadReferenceDepth \"all\" -namespace \""+$prefix+"\" -options \"v=0\" \""+$refFile+"\"");
		namespace -set ":";
	}
}

global proc string[] abxShotsGetScenes (string $shotName, string $dept) {

	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
	
	$shotFileName = `abxShotsGetShortName $shotName`;

	string $shotPrefix = ($shotFileName+"_"+$dept+"_");
	string $shotsFolder[] = `getFileList -fs ($shotPrefix+"*") -folder ($shotsPath+$shotName+"/"+toupper($dept)+"/work/")`;
	//print ($shotsPath+$shotName+"/"+toupper($dept)+"/work/\n");
	//print $shotsFolder;

	string $sorted[] = sort($shotsFolder);


	string $foundTakeName[];
	string $foundExtension[];
	int $highestVersionInt[];
	string $highestVersion[];

	string $foundTakes[];
	string $foundVersions[];
	
	for ($each in $sorted){

		if (`gmatch $each ($shotPrefix+"*")`){

			string $nameOnly = `basenameEx $each`;
			string $extension = `fileExtension $each`;
			int $prefixSize = size($shotPrefix)+1;
			int $nameOnlySize = size($nameOnly);
			string $noShotName = `substring $nameOnly $prefixSize $nameOnlySize`;
			int $noShotNameSize = size($noShotName);

			string $tokenBuffer[];
			tokenize $noShotName "_" $tokenBuffer;
			string $version = $tokenBuffer[size($tokenBuffer)-1];

			//int $vSize = size($version);
			//int $versionInt = int(`substring $version 2 $vSize`);
			
			
			int $takeNameSize = $noShotNameSize - size($version) - 1;
			string $takeName = `substring $noShotName 1 $takeNameSize`;
			if (size($tokenBuffer) == 1){
				$takeName="default";
				$takeNameSize = 7;
			}
			//print ($takeName+":"+$version+"\n");



			if (!`stringArrayContains $takeName $foundTakes`){
				$foundTakes[size($foundTakes)] = $takeName;
				if ($takeName != "default"){
					$foundVersions[size($foundVersions)] = abxShotsGetLatestWorkVersion($shotFolder, $shotName, $dept, $takeName, "work",0);
					//print ("abxShotsGetLatestWorkVersion(\""+$shotName+"\", "+$dept+", \""+$takeName+"\", \"work\",0)");
				}
				else {
					$foundVersions[size($foundVersions)] = abxShotsGetLatestWorkVersion($shotFolder, $shotName, $dept, "", "work",0);
					//print ("abxShotsGetLatestWorkVersion(\""+$shotName+"\", "+$dept+", \"\", \"work\",0)");
				}
				//print ("FoundVersion = "+$foundVersions[size($foundVersions)-1]+"\n");	
			}


		}
		//print $foundTakes;
	}

	string $results[];
	int $defaultTake = -1;
	//print ("sizeOfTakes"+size($foundTakes)+"\n");
	for ($i=0;$i<size($foundTakes);$i++){
		if ($foundTakes[$i] != "default"){
			
			$results[$i] = ($shotPrefix+$foundTakes[$i]+"_"+$foundVersions[$i]+".ma");
			//print ("foundTakeName="+$foundTakes[$i]+" highestVersion="+$foundVersions[$i]+"\n");
			//$results[$i] = ($shotPrefix+$foundTakeName[$i]+"_"+$highestVersion[$i]+".ma");
			//print ("foundTakeName="+$foundTakeName[$i]+" highestVersion="+$highestVersion[$i]+"\n");
		}
		else {
			$defaultTake = $i;
			$results[$i] = ($shotPrefix+$foundVersions[$i]+".ma");
			//print ("foundTakeName="+$foundTakes[$i]+" highestVersion="+$foundVersions[$i]+"\n");
			//$results[$i] = ($shotPrefix+$highestVersion[$i]+".ma");
			//print ("noTake. foundTakeName="+$foundTakeName[$i]+" highestVersion="+$highestVersion[$i]+"\n");
		}
	}

	// make the default take the first item in the array
	if ($defaultTake > -1){
		string $defaultTakeName = $results[$defaultTake];
		stringArrayRemoveAtIndex($defaultTake ,$results);
		stringArrayInsertAtIndex(0, $results, $defaultTakeName);
	}

	return $results;

}

global proc abxShotsNewTakeDialog (){

    // Get the dialog's formLayout.
    //
    string $form = `setParent -q`;

    // layoutDialog's are not resizable, so hard code a size here,
    // to make sure all UI elements are visible.
    //
    int $start = `textField -q -text abxShotsDtlRangeS`;
    int $end = `textField -q -text abxShotsDtlRangeE`;


    formLayout -e -width 300 -height 125 $form;


    //string $t = `floatFieldGrp -en1 1 -en2 1 -cw 1 80 -cw 2 100 -cw 3 100 -nf 2 -label "Start/End:" -v1 $start -v2 $end frangeEditFFG`;
    string $t = `columnLayout -adjustableColumn true`;
    	radioCollection abxShotsNewTakeRC;
    	rowLayout -nc 2 -cw 1 70;
    		separator -style "none";
			radioButton -sl -label "Make Default Scene/Take" -cc "textFieldGrp -e -en 0 -text \"\" abxShotsNewTakeRCAName" abxShotsNewTakeRCD;
			setParent ..;
    	rowLayout -nc 2 -cw 1 70;
    		separator -style "none";
    		radioButton -label "Make Alternate Scene/Take" -cc "textFieldGrp -e -en 1 abxShotsNewTakeRCAName" abxShotsNewTakeRCA;
    		setParent ..;
    	
    textFieldGrp -en 0 -label "Alternate Name:" abxShotsNewTakeRCAName;

    setParent $form;

    string $b1 = `button -l "Use Open Scene" -c "layoutDialog -dismiss (\"SaveAs:\"+`textFieldGrp -q -text abxShotsNewTakeRCAName`);"`;
    string $b2 = `button -l "Use New Scene" -c "layoutDialog -dismiss (\"New:\"+`textFieldGrp -q -text abxShotsNewTakeRCAName`);"`;
    string $b3 = `button -l "Cancel"     -c "layoutDialog -dismiss \"Cancel\""`;


    int $spacer = 5;
    int $top = 5;
    int $edge = 5;

    formLayout -edit
        -attachForm            $t   "top"    ($top+10)
        -attachForm            $t   "left"   $edge
        -attachNone            $t   "bottom"
        -attachForm            $t   "right"  $edge

        -attachOppositeForm    $b1  "top" (-25-$spacer)
        -attachForm            $b1  "left"   $edge
        -attachNone            $b1  "bottom"
        -attachPosition        $b1  "right"  $spacer 33

        -attachOppositeForm    $b2  "top"    (-25-$spacer)
        -attachPosition        $b2  "left"   $spacer 33
        -attachNone            $b2  "bottom"
        -attachPosition        $b2  "right" $spacer 66

        -attachForm            $b3  "right" $edge
        -attachOppositeForm    $b3  "top"    (-25-$spacer)
        -attachPosition        $b3  "left"   $spacer 66
        -attachNone            $b3  "bottom"
        -attachForm            $b3  "right" $edge

    $form;

	// use default radio button
	// use alternate radio button with a text field for the alternate name
	// OK button 
	// Cancel button

}

// create a prompt for the name of the new take
// user can choose to either save the current scene file as the new take, or to create a new take, or cancel
global proc abxShotsCreateTakeProc (){

	string $result = `layoutDialog -title "New Scene / Take" -ui "abxShotsNewTakeDialog"`;
	print ($result+"\n");
	if ($result != "Cancel") {
		string $text = "";
		string $tokenBuffer[];
		tokenize $result ":" $tokenBuffer;
		if (size($tokenBuffer) == 2)
			$text = $tokenBuffer[1];

		string $mode = $tokenBuffer[0];
		
		//if ($result == "Make Alternate Scene/Take") $text = `promptDialog -query -text`;
		//string $tokenBuffer[];
	
		//$text = tolower($text);
		clear ($tokenBuffer);

		// turn underscores into interCaps
		tokenize $text "_" $tokenBuffer;
		if (size($tokenBuffer)> 1){
			$text = $tokenBuffer[0];
			int $i = 0;
			for ($i=1;$i<size($tokenBuffer);$i++){
				int $l = size($tokenBuffer[$i]);
				string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
				string $rest = `substring $tokenBuffer[$i] 2 $l`;
				$text += ($capLetter+$rest);
			}
		}

		// turn spaces into intercaps
		tokenize $text " " $tokenBuffer;
		if (size($tokenBuffer)> 1){
			$text = $tokenBuffer[0];
			int $i = 0;
			for ($i=1;$i<size($tokenBuffer);$i++){
				int $l = size($tokenBuffer[$i]);
				string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
				string $rest = `substring $tokenBuffer[$i] 2 $l`;
				$text += ($capLetter+$rest);
			}
		}
		string $shotFolder = `abxShotsGetActiveShotFolder`;

		// get active tab to determine which dept to show
		string $dept = `abxShotsGetActiveDeptTab`;

		// string $takeSceneNames[] = `textScrollList -q -ai $sourceList`;

		// get a list of take names from this for checking for duplicate names
		


		string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");

		string $foundShotName[];
		if ($shotFolder == "_PREVIS") {
			$foundShotName = `treeView -q -si abxPrevisList`;
		}
		else{
			$foundShotName = `treeView -q -si abxShotsList`;
		}
		evalEcho("abxShotsCreateTake \""+$foundShotName[0]+"\" \""+$dept+"\" \""+$text+"\" \""+$mode+"\"");

	}
}


global proc abxShotsCreateTake (string $shotName, string $dept, string $takeName, string $mode){

	print ("CREATING SHOT: "+$shotName+" "+$dept+" "+$takeName+" "+$mode+"\n");
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");

	$shotFileName = `abxShotsGetShortName $shotName`;

	// prompt to save current scene as this new take, create a new scene and save it, or cancel

	//$result = `confirmDialog -title "Create Take" -message "Save this scene as new take?" -button "Save This As" -button "New Scene File" -button "Cancel" -defaultButton "Save This As" -cancelButton "Cancel" -dismissString "Cancel"`;
	$result = $mode;
	if ($result == "SaveAs" || $result == "New"){
		string $takeFilePath = "";
		if ($takeName != "")
			$takeFilePath = ($shotsPath+$shotName+"/"+toupper($dept)+"/work/"+$shotFileName+"_"+$dept+"_"+$takeName+"_v001.ma");
		else 
			$takeFilePath = ($shotsPath+$shotName+"/"+toupper($dept)+"/work/"+$shotFileName+"_"+$dept+"_v001.ma");
		string $cmd = "";

		if ($result == "New"){	
			//$cmd = ("saveChanges(\"file -f -new\");");
			if (`exists ppDoNewScene`){
				if ($dept == "anm" || $dept == "pre"){
					$cmd = ("ppDoNewScene \"anm\";");
				}
				else if ($dept == "lgt"){
					$cmd = ("ppDoNewScene \"lgt\";");
				}
			}	
			else{
				$cmd = ("saveChanges(\"abxLockFileCheckOut(\\\"\\\");file -f -new;\");");
			}
		}
		abxLockFileCheckOut("");
		$cmd += ("file -rn \""+$takeFilePath+"\";");
		$cmd += ("abxShotsIncrementalSave 0 \"\" \"auto\" \"\" \"\" \"\" \"\";");
		$cmd += ("abxShotsRefreshDetailsUI \""+$shotName+"\";");
		//$cmd += ("string $shotName[] = `treeView -q -si abxShotsList`;abxShotsRefreshDetailsUI $shotName[0];");
		evalEcho ($cmd);


				// set the shot frame range if it exists in the db already
		string $shotDetails[] = abxShotsGetShotDetails($shotName, $shotFolder);
		string $filePath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName);

		print ("FilePath="+$filePath+"   shotName="+$shotName+"\n");
		if ($shotName != "" && `filetest -d ($filePath+"/CAM/")`){
			int $start = 0;
			int $end = 0;

			if ($shotFolder != "_PREVIS"){
				$fail = catch(python("activeShot = R.Shot.getFromPath('"+$filePath+"')"));
				$fail = catch($start = python("activeShot.startframe"));
				$fail = catch($end = python("activeShot.endframe"));

				if ($fail)
					print("rainbow request failed for frame range request. falling back to shot_details.txt");
			}

			if ($start == 0 && $shotDetails[2] != "")
				$start = $shotDetails[2];
			if ($end == 0 && $shotDetails[3] != "")
				$end = $shotDetails[3];
			if ($start == 0 && $end == 0){
				
			}
			else{
				playbackOptions -e -min $start -max $end;
				playbackOptions -e -ast $start -aet $end; 
			}
		}
		string $target = "Shot";
		string $targetPath = $takeFilePath;
		string $event = "created" ;
		string $message = ("Take Created: "+`basenameEx $takeFilePath`);
		evalEcho("abxShotsSendNotification(\""+$target+"\",\""+$targetPath+"\", \""+$event+"\", \""+$message+"\", 0)");
	}
	else {
		print ("New Take Cancelled\n");
	}
}

// creates a new sequence folder that allows sub folders to be added
global proc abxShotsNewSequence (string $shotFolder){
	string $result = `promptDialog -title "New Sequence Name" -message "Enter Sequence Name (No Underscores)" -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
	if ($result == "OK") {
		string $text = `promptDialog -query -text`;
		string $tokenBuffer[];
		$text = toupper($text);

		// remove any underscores in the sequence name
		tokenize $text "_" $tokenBuffer;
		if (size($tokenBuffer)> 1){
			$text = $tokenBuffer[0];
			int $i = 0;
			for ($i=1;$i<size($tokenBuffer);$i++){
				int $l = size($tokenBuffer[$i]);
				string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
				string $rest = `substring $tokenBuffer[$i] 2 $l`;
				$text += ($capLetter+$rest);
			}
		}

		// remove spaces from the name and do intercaps instead (although everything is made uppercase for now)
		tokenize $text " " $tokenBuffer;
		if (size($tokenBuffer)> 1){
			$text = $tokenBuffer[0];
			int $i = 0;
			for ($i=1;$i<size($tokenBuffer);$i++){
				int $l = size($tokenBuffer[$i]);
				string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
				string $rest = `substring $tokenBuffer[$i] 2 $l`;
				$text += ($capLetter+$rest);
			}
		}
		string $renderFolder = (`workspace -q -rd`+"../../RENDER/"+$shotFolder+"/"+$text);
		string $path = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$text);
		evalEcho("sysFile -makeDir \""+$path+"\"");

		string $target = "Job";
		string $targetPath = $path;
		string $event = "created" ;
		string $message = ("Sequence Created: "+`basenameEx $path`);
		evalEcho("abxShotsSendNotification(\""+$target+"\",\""+$targetPath+"\", \""+$event+"\", \""+$message+"\", 0)");

		if (`window -exists abxShotsCreateWindow`){
			abxShotsUpdateNewShotUI;
		}

		// add items to list without calling a full refresh
		if ($shotFolder == "_PREVIS"){
			treeView -e -hb -addItem $text "" abxPrevisList;
			treeView -e -textColor $text .3 .9 .4 abxPrevisList;
		}
		else {
			treeView -e -hb -addItem $text "" abxShotsList;
		}
	}

}

global proc abxShotsShowNewShotUI (string $shotFolderTab) {
	$shotsFolder = `abxShotsGetActiveShotFolder`;
	if (!`window -exists abxShotsCreateWindow`){
		window -t "New Shot" -width 500 -height 200 abxShotsCreateWindow;
		formLayout abxShotsNewShotUIFrmLyt;
		frameLayout -lv 0 -borderStyle "out" abxShotsNewShotFrmeLyt;
		columnLayout -rowSpacing 3;
		separator -h 20 -style "none";
		optionMenuGrp -label "Location:" -columnWidth 2 80 -cw 3 100 -cc abxShotsUpdateNewShotUI abxShotsCreateTypeOM;
			menuItem -label "_PREVIS";
			menuItem -label "_ALL_SHOTS";
			optionMenuGrp -e -v $shotsFolder abxShotsCreateTypeOM;
		optionMenuGrp -e -sl 2 abxShotsCreateTypeOM;
		rowLayout -numberOfColumns 2 -columnAttach 1 "both" 0 -columnAttach 2 "both" 0 abxShotsNewSeqRL;
			optionMenuGrp -label "Sequence:"  -columnWidth 2 80 -cw 3 100 -cc abxShotsUpdateNewShotUI abxShotsCreateOMTmpl;	
				menuItem -label "none";
				string $loc =  `optionMenuGrp -q -value abxShotsCreateTypeOM`;
				string $foundSeq[] = `abxShotsGetSequences $loc`;
				for ($each in $foundSeq){
					menuItem -label $each;
				}
				if (`optionMenuGrp -q -ni abxShotsCreateOMTmpl` > 1)
					optionMenuGrp -e -sl 2 abxShotsCreateOMTmpl;
			button -label "New Sequence..." -c "abxShotsNewSequence `optionMenuGrp -q -v abxShotsCreateTypeOM`";
			setParent ..;
		// asset name
		rowLayout -numberOfColumns 4 -columnWidth 1 141 -columnAttach 1 "right" 0 abxShotsShotNameRL;
			text -label "Shot Name:";
			text -label "<none>" abxShotsSeqLbl;
			textField -cc "abxShotsUpdateNewShotUI" -text "010" abxShotsCreateTFName;
			button -label "Validate" -ann "Removes Invalid Characters like spaces and underscores. (same as pressing enter after typing the shot name)" -c "abxShotsUpdateNewShotUI";
		setParent ..;

		rowLayout -numberOfColumns 2 -columnWidth 1 141 -columnAttach 1 "right" 0;
			text -label "Path:";
			text -label ("scenes/"+`optionMenuGrp -q -v abxShotsCreateTypeOM`+"/"+`textField -q -text abxShotsCreateTFName`+"/") abxShotsNewShotPath;
		//textFieldGrp -label "Shot Name:" -text  "S1_010"  abxShotsCreateTFName;

		// asset method

		setParent abxShotsNewShotUIFrmLyt;

		rowLayout -numberOfColumns 3 -columnWidth3 160 160 160 -columnAttach 1 "both" 0 -columnAttach 2 "both" 0 -columnAttach 3 "both" 0 abxShotsNewShotRL;
		button -label "Create" -h 25 -c "abxShotsCreateShotUI `optionMenuGrp -q -v abxShotsCreateTypeOM` (`optionMenuGrp -q -v abxShotsCreateOMTmpl`+\"/\"+`optionMenuGrp -q -v abxShotsCreateOMTmpl`+\"_\"+`textField -q -text abxShotsCreateTFName`);window -e -vis 0 abxShotsCreateWindow;" ;
		button -label "Apply" -h 25 -c "abxShotsCreateShotUI `optionMenuGrp -q -v abxShotsCreateTypeOM` (`optionMenuGrp -q -v abxShotsCreateOMTmpl`+\"/\"+`optionMenuGrp -q -v abxShotsCreateOMTmpl`+\"_\"+`textField -q -text abxShotsCreateTFName`);";
		button -label "Cancel" -h 25 -c "window -e -vis 0 abxShotsCreateWindow";

		formLayout -e 
			-af abxShotsNewShotFrmeLyt "left" 5
			-af abxShotsNewShotFrmeLyt "top" 5
			-af abxShotsNewShotFrmeLyt "bottom" 34
			-af abxShotsNewShotFrmeLyt "right" 5

			-af abxShotsNewShotRL "left" 5
			-ac abxShotsNewShotRL  "top" 5 abxShotsNewShotFrmeLyt
			-af abxShotsNewShotRL "bottom" 5
			-af abxShotsNewShotRL "right" 5
			abxShotsNewShotUIFrmLyt;
			
		if ($shotFolderTab == "abxShotsLibForm"){
			optionMenuGrp -e -value "_ALL_SHOTS" abxShotsCreateTypeOM;
			abxShotsUpdateNewShotUI;
		}
		else if ($shotFolderTab == "abxPrevisLibForm"){
			optionMenuGrp -e -value "_PREVIS" abxShotsCreateTypeOM;
			abxShotsUpdateNewShotUI;
		}
		showWindow abxShotsCreateWindow;
	}
	else {
		showWindow abxShotsCreateWindow;
	}
}

global proc abxShotsUpdateNewShotUI () {
	string $loc = `optionMenuGrp -q -value abxShotsCreateTypeOM`;
	string $seq = `optionMenuGrp -q -value abxShotsCreateOMTmpl`;
	string $oldSeqNames[] = `optionMenuGrp -q -ils abxShotsCreateOMTmpl`;
	for ($each in $oldSeqNames){
		string $label = `menuItem -q -l $each`;
		if ($label != "none"){
			deleteUI -menuItem $each;
		}
	}
	string $foundSeq[] = `abxShotsGetSequences $loc`;
	int $i = 1;
	int $selIndex = 1;
	for ($each in $foundSeq){
		$i++;
		if ($each == $seq)
			$selIndex = $i;
		setParent abxShotsCreateOMTmpl;
		menuItem  -label $each;
	}
	
	optionMenuGrp -e -sl $selIndex abxShotsCreateOMTmpl;
	string $text = `textField -q -text abxShotsCreateTFName`;
	string $tokenBuffer[];
	// remove any space
	tokenize $text " " $tokenBuffer;
	if (size($tokenBuffer)> 1){
		$text = $tokenBuffer[0];
		int $i = 0;
		for ($i=1;$i<size($tokenBuffer);$i++){
			int $l = size($tokenBuffer[$i]);
			string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
			string $rest = `substring $tokenBuffer[$i] 2 $l`;
			$text += ($capLetter+$rest);
		}
	}
	
	tokenize $text "_" $tokenBuffer;
	if (size($tokenBuffer)> 1){
		$text = $tokenBuffer[0];
		int $i = 0;
		for ($i=1;$i<size($tokenBuffer);$i++){
			int $l = size($tokenBuffer[$i]);
			string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
			string $rest = `substring $tokenBuffer[$i] 2 $l`;
			$text += ($capLetter+$rest);
		}
	}
	$text = toupper($text);
	textField -e -text $text abxShotsCreateTFName;


	if (`optionMenuGrp -q -value abxShotsCreateOMTmpl` != "none"){
		string $shotNameUp = `textField -q -text abxShotsCreateTFName`;
		$shotNameUp = toupper($shotNameUp);
		text -e -label (`optionMenuGrp -q -value abxShotsCreateOMTmpl`+"_") abxShotsSeqLbl;
		text -e -label ("scenes/"+`optionMenuGrp -q -v abxShotsCreateTypeOM`+"/"+`optionMenuGrp -q -value abxShotsCreateOMTmpl`+"/"+`optionMenuGrp -q -value abxShotsCreateOMTmpl`+"_"+$shotNameUp+"/") abxShotsNewShotPath;
		//textField -e -text  (`optionMenuGrp -q -value abxShotsCreateOMTmpl`+"_")  abxShotsCreateTFName;
	}
	else{
		text -e -label "" abxShotsSeqLbl;
		string $shotNameUp = `textField -q -text abxShotsCreateTFName`;
		$shotNameUp = toupper($shotNameUp);
		text -e -label ("scenes/"+`optionMenuGrp -q -v abxShotsCreateTypeOM`+"/"+$shotNameUp+"/") abxShotsNewShotPath;
	}

	
	//evalDeferred("setFocus abxShotsCreateTFName");
	
}

global proc abxShotsCreateShotUI (string $shotFolder, string $shotName){

	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
	
	string $shotFileName = `abxShotsGetShortName $shotName`;
	//string $result = `promptDialog -title "New Shot Name" -message "Enter Shot Name: (S#_###)" -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
	//if ($result == "OK") {
	//string $text = `promptDialog -query -text`;
	string $tokenBuffer[];
	string $sequenceName = "";
	tokenize $shotName "/" $tokenBuffer;
	if (size ($tokenBuffer) > 1){
		if ($tokenBuffer[0] == "none"){
			string $tokenBuffer2[];
			tokenize $tokenBuffer[1] "_" $tokenBuffer2;
			$shotName = $tokenBuffer2[1];
		}
		$sequenceName = $tokenBuffer[0];
	}

	$text = toupper($shotName);

	// remove any more than 1 underscores from the shot name. only sequce_shot may exist for now
	
	tokenize $text "_" $tokenBuffer;
	if (size($tokenBuffer)> 2){
		$text = ($tokenBuffer[0]+"_"+$tokenBuffer[1]);
		int $i = 0;
		for ($i=2;$i<size($tokenBuffer);$i++){
			int $l = size($tokenBuffer[$i]);
			string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
			string $rest = `substring $tokenBuffer[$i] 2 $l`;
			$text += ($capLetter+$rest);
		}
	}

	// remove any space
	tokenize $text " " $tokenBuffer;
	if (size($tokenBuffer)> 1){
		$text = $tokenBuffer[0];
		int $i = 0;
		for ($i=1;$i<size($tokenBuffer);$i++){
			int $l = size($tokenBuffer[$i]);
			string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
			string $rest = `substring $tokenBuffer[$i] 2 $l`;
			$text += ($capLetter+$rest);
		}
	}

	$shotFileName = toupper($shotFileName);
	//print ($shotName+"\n");

	// ADD THE SHOT TO THE DATABASE HERE USING $PATH as the shotpath
	
	string $filepath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$text);
		
	//if (!`filetest -d $filepath`){
	if ($shotFolder != "_PREVIS"){
		// add the shot to the web database
		//pprainbow();
		//int $dbExists = python("import rainbow.utils as U; U.checkDB();");
		global int $dbExists;
		if ($dbExists){
			$fail = catch(python("R.Shot.createFromPath('"+$filepath+"')"));
			//print ("DB Create Shot FilePath ="+$filepath+"\n");
			if ($fail)
				warning("Rainbow Database failed to add shot. Skipping Database creating shot folders anyway");
		}
	}

	abxShotsCreateShot $shotFolder $text;

	if ($shotFolder == "_ALL_SHOTS"){
		string $target = "Sequence";
		string $targetPath = $filepath;
		string $event = "created" ;
		string $message = ("Shot Created: "+`basenameEx $filepath`);
		evalEcho("abxShotsSendNotification(\""+$target+"\",\""+$targetPath+"\", \""+$event+"\", \""+$message+"\", 1)");
	}
	
	// add the shot to the list view
	if ($shotFolder == "_PREVIS"){
		if (!`treeView -q -itemExists $shotName abxPrevisList`){
			treeView -e -addItem $shotName $sequenceName abxPrevisList;
			treeView -e -selectionColor $shotName .8 .8 .8 -lbc $shotName .2 .2 .2 abxPrevisList;

			treeView -e -displayLabel $shotName $shotFileName abxPrevisList;
			treeView -e -bti $shotName 1 "P" abxPrevisList;
			treeView -e -textColor $shotName .3 .9 .4 abxPrevisList;
		}
	}
	else {
		if (!`treeView -q -itemExists $shotName abxShotsList`){
			treeView -e -addItem $shotName $sequenceName abxShotsList;
			treeView -e -selectionColor $shotName .8 .8 .8 abxShotsList;

			treeView -e -displayLabel $shotName $shotFileName abxShotsList;
			treeView -e -bti $shotName 1 "A" -bti $shotName 2 "F" -bti $shotName 3 "L" -bti $shotName 4 "C" abxShotsList;
		}
	}
	//}
	//else {
	//	confirmDialog -title "Confirm" -message ("Shot scenes/"+$shotFolder+"/"+$text+"  Already Exists.") -button "OK" -defaultButton "OK" -cancelButton "OK" -dismissString "OK";		
	//	error ("Already Exists:"+$filepath);
	//}
	/////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////
}

global proc abxShotsCreateShot (string $shotFolder, string $shotName){

	string $shotsFolder = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
	string $renderFolder = (`workspace -q -rd`+"../../RENDER/"+$shotFolder+"/");
	string $compFolder = (`workspace -q -rd`+"../../COMP/"+$shotFolder+"/");
	string $sourceFolder = (`workspace -q -rd`+"../../SOURCE/"+$shotFolder+"/");
	string $styleFramesFolder = (`workspace -q -rd`+"../../STYLEFRAMES/"+$shotFolder+"/");


	string $shotFileName = `abxShotsGetShortName $shotName`;

	
	string $paths[] = {$shotsFolder,$renderFolder,$compFolder,$sourceFolder, $styleFramesFolder};
	for ($path in $paths){
		
		// if its previs only make previs folder for 3D/Scenes and RENDER and COMP
		if ($shotFolder == "_PREVIS"){
			if (`gmatch $path "*scenes*"` || `gmatch $path "*RENDER*"` || `gmatch $path "*COMP*"`){
				print $path;
				if (!`filetest -d $path`){
					evalEcho("sysFile -makeDir \""+$path+"\"");	
				}
				$path += ($shotName+"/");
				if (!`filetest -d $path`){
					sysFile -makeDir $path;	
				}
				// only make the PRE folder for 3D/scenes and RENDER
				if (`gmatch $path "*scenes*"` || `gmatch $path "*RENDER*"`){
					if ($shotFolder == "_PREVIS"){
						string $subPath = ($path+"PRE/");
						print $subPath;
						if (!`filetest -d $subPath`){
							evalEcho("sysFile -makeDir \""+$subPath+"\"");
							sysFile -makeDir ($subPath+"/work");
							sysFile -makeDir ($subPath+"/master");
						}
						if (`gmatch $path "*scenes*"`){
							$subPath = ($path+"CAM/");
							if (!`filetest -d $subPath`){
								sysFile -makeDir $subPath;
								sysFile -makeDir ($subPath+"/master");
							}
						}
					}
				}
			}
		}
		// if its _ALL_SHOTS
		else{
			print $path;
			if (!`filetest -d $path`){
				evalEcho("sysFile -makeDir \""+$path+"\"");	
			}
			$path += ($shotName+"/");
			if (!`filetest -d $path`){
				sysFile -makeDir $path;	
			}
			if (`gmatch $path "*scenes*"` || `gmatch $path "*RENDER*"`){
				string $subPath = ($path+"COMP/");
				print $subPath;
				if (!`filetest -d $subPath`){
					sysFile -makeDir $subPath;
					sysFile -makeDir ($subPath+"/PRECOMP");
				}
		
				string $subPath = ($path+"ANM/");
				print $subPath;
				if (!`filetest -d $subPath`){
					sysFile -makeDir $subPath;
					if (`gmatch $path "*scenes*"`){
						sysFile -makeDir ($subPath+"/work");
						sysFile -makeDir ($subPath+"/master");
					}
				}
				$subPath = ($path+"FX/");
				if (!`filetest -d $subPath`){
					sysFile -makeDir $subPath;
					if (`gmatch $path "*scenes*"`){
						sysFile -makeDir ($subPath+"/work");
						sysFile -makeDir ($subPath+"/master");
					}
				}
				$subPath = ($path+"LGT/");
				if (!`filetest -d $subPath`){
					sysFile -makeDir $subPath;
					if (`gmatch $path "*scenes*"`){
						sysFile -makeDir ($subPath+"/work");
						sysFile -makeDir ($subPath+"/master");
					}
				}
				if (`gmatch $path "*scenes*"`){
					$subPath = ($path+"CAM/");
					if (!`filetest -d $subPath`){
						sysFile -makeDir $subPath;
						if (`gmatch $path "*scenes*"`){
							sysFile -makeDir ($subPath+"/master");
						}
					}
				}
			}
			else if (`gmatch $path "*COMP*"`){
				$subPath = ($path+"PRECOMP/");
				if (!`filetest -d $subPath`){
					sysFile -makeDir $subPath;	
				}				
			}
		}
	}
}







































global proc abxShotsAutoIncrementSave (int $force, string $note){
	// 0:Server 1:Job 2:ShotFolder 3:Seq 4:Shot 5:dept 6:subDept 7:take 8:version 9:ext
	string $shotInfo[] = abxShotsGetFromPath(`file -q -sn`);
	if ($shotInfo[2]!= "_ALL_SHOTS" && $shotInfo[2] != "_PREVIS")
		error("The Current Scene is not properly saved into our pipeline. Incremental Save Aborted!");
	else
		evalEcho("abxShotsIncrementalSave "+$force+" \""+$shotInfo[2]+"\" \""+$shotInfo[3]+"_"+$shotInfo[4]+"\" \""+$shotInfo[5]+"\" \""+$shotInfo[7]+"\" \""+$shotInfo[8]+"\" \""+$note+"\"");
}




global proc abxShotsIncrementalSave(int $force, string $shotFolder, string $shotName, string $dept, string $takeName, string $version, string $note){
	//string $note = "";

	// 0:Server 1:Job 2:ShotFolder 3:Seq 4:Shot 5:dept 6:subDept 7:take 8:version 9:ext
	string $shotInfo[] = abxShotsGetFromPath(`file -q -sn`);

	if ($shotFolder == "")
		$shotFolder = $shotInfo[2];//`abxShotsGetActiveShotFolder`;

	string $shotSequence = "";
	string $sceneFileName = "";
	string $shotNameGuess = "";
	string $shotTakeGuess = "";
	string $subDeptGuess = "";
	string $deptGuess = "";
	string $shotFolderGuess = "";
	string $shotsFolder = "";//"scenes/"+$shotFolder+"/";

	$shotFileName = `abxShotsGetShortName $shotName`;

	// get the scene name
	string $currentScene = `file -q -sn`;
	string $extension = `fileExtension $currentScene`;
	string $currentSceneName = `basenameEx $currentScene`;

	// tokenize the scene name for automatic incremental save
	string $tokenBuffer[];
	tokenize $currentScene "/" $tokenBuffer;

	$sceneFileName = $tokenBuffer[size($tokenBuffer)-1];

	int $latestFoundVersion = -1;

	// collects audio files that are not in the local server
	

	// assume this path <workspace>/scenes/<shotFolder>/<shotName>/<dept>/<take><version>
	// tokenize backwards through the current scene path to guess details about the file

	if (size($tokenBuffer) > 1){
		$subDeptGuess = $tokenBuffer[size($tokenBuffer)-2];
		if (size($tokenBuffer) > 2 ) {
			$deptGuess = tolower($tokenBuffer[size($tokenBuffer)-3]);
			if (size($tokenBuffer) > 3 ) {
				$shotNameGuess = $tokenBuffer[size($tokenBuffer)-4];
				if (size($tokenBuffer) > 4){
					if ($tokenBuffer[size($tokenBuffer)-5] != "_ALL_SHOTS" && $tokenBuffer[size($tokenBuffer)-5] != "_PREVIS"){
						$shotSequence = $tokenBuffer[size($tokenBuffer)-5];
						if (size($tokenBuffer) > 5){
							if ($tokenBuffer[size($tokenBuffer)-6] == "_ALL_SHOTS" || $tokenBuffer[size($tokenBuffer)-6] == "_PREVIS"){
								$shotFolderGuess = $tokenBuffer[size($tokenBuffer)-6];
								$shotsFolder = ("scenes/"+$tokenBuffer[size($tokenBuffer)-6]+"/");
							}
						}
					}
					else {
						$shotFolderGuess = $tokenBuffer[size($tokenBuffer)-5];
						$shotsFolder = ("scenes/"+$tokenBuffer[size($tokenBuffer)-5]+"/");
					}
				}
			}
		}
	}
	if ($shotsFolder == ""){
		if (!$force)
			$result = `confirmDialog -title "abxShots: Save Increment Failed" -message "Could Not Guess where to save this file. Use \"Save As\" option in the Shot Manager" -button "Ok" -defaultButton "Ok" -dismissString "Ok"`;
		return;
	}

	int $shotNameSize = size($shotNameGuess)+1+size($deptGuess)+1;
	int $currentSceneNameSize = size($currentSceneName);
	string $noShotName = `substring $currentSceneName $shotNameSize $currentSceneNameSize `;
	
	string $tokenBuffer[];
	tokenize $noShotName "_" $tokenBuffer;
	if (size($tokenBuffer) > 1){
		$shotTakeGuess = $tokenBuffer[0];
	}
	print ($shotNameGuess+","+$shotTakeGuess+","+$deptGuess+"\n");

	// automatic incremental save, guesses based on your current scene where to incrementally save it
	if ($shotName != "auto"){
		string $result = "Yes";
		if ($shotName != $shotNameGuess || $takeName != $shotTakeGuess || $dept != $deptGuess){
			$result = `confirmDialog -title "Confirm" -message "This scene doesn't appear to belong here? Are you sure?" -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;		
		}
		if ($result == "Yes"){
			$shotNameGuess = $shotName;
			$shotTakeGuess = $takeName;
			$subDeptGuess = "work";
			$deptGuess = $dept;
		}	
		else {
			return;
		}	
	}

	string $pathGuess = "";
	if ($shotSequence != ""){
		$pathGuess = (`workspace -q -rd`+$shotsFolder+$shotSequence+"/"+$shotNameGuess+"/"+toupper($deptGuess)+"/"+$subDeptGuess+"/");
	}
	else {
		$pathGuess = (`workspace -q -rd`+$shotsFolder+$shotNameGuess+"/"+toupper($deptGuess)+"/"+$subDeptGuess+"/");
	}
	print ("pathGuess="+$pathGuess+"\n");

	// turn off shading and hw texturing
	$panels = `getPanel -type modelPanel`;
	for ($each in $panels){
    	modelEditor -e -da "wireframe" -displayTextures false $each;
	}

	// test to see if we guessed the correct shot path by comparing the found scene file path details with the details 
	// sumbited by the user 
	string $cleanup = "Perform Cleanup Checks and Save";

	if ($force)
		$cleanup = "Save Without Checking";
	// check for clashing renderCam
	if ($deptGuess == "anm"){
		if (!$force)
			$cleanup = `confirmDialog -title "Shot Manager Cleanup Check" -message ("Perform Cleanup Checks?. This checks for clashes and numerous other safety checks. DO NOT SKIP UNLESS YOU HAVE A REASON.") -button "Perform Cleanup Checks and Save" -button "Save Without Checking" -cancelButton "Perform Cleanup Checks" -defaultButton "Perform Cleanup Checks"`;
		else
			$cleanup = "Save Without Checking";

		//abxShotsGatherAudio;
		catch(`abxShotsUseAudioMaster`);


		if ($cleanup == "Perform Cleanup Checks and Save"){
			// check for multiple renderCams and cancel if more than one is found.
			string $renderCams[] = `ls -long -r 1 -type camera "renderCamShape"`;
			if (size($renderCams)>1){
				print ("// DUPLICATES FOUND renderCamShape: //\n");
				for ($each in $renderCams){
					print ("// "+$each+"\n");
				}
				print ("// END DUPLICATES FOUND //\n");
				string $result = `confirmDialog -title "Incremental Save Error" -message ("File Not Saved. You have multiple cameras named renderCam. Only one is allowed. Rename other renderCam to something else. See Script Editor for details.") -button "OK"`;
				return;
			}
		}
	}
	if ($deptGuess == "lgt"){
		// set to the default render layer before saving
		editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;

	}
	int $failure = 0;
	if ($cleanup == "Perform Cleanup Checks and Save"){
		// frame rate check
		// check the frame rate for skylanders
		string $prjDetails[] = abxProjectGetShotDetails(`workspace -q -rd`);
		if (`fpsNumeric` != $prjDetails[1]){
			$result = `confirmDialog -title "abxShots Confirm" -message ("File is not at project default Frame Rate of "+$prjDetails[1]+". Auto Convert it now?") -button "Convert" -button "Skip" -defaultButton "Convert" -cancelButton "Convert" -dismissString "Convert"`;
			if ($result == "Convert"){
				abxShotsSetFrameRate ($prjDetails[1]);
			}
		}


		// remove fur plugin if its not in use
		if (`pluginInfo -q  -loaded Fur`){
			if (size(`ls -type FurFeedback`)==0){
				if (`objExists defaultFurGlobals`){
					delete defaultFurGlobals;
				}
			}
		}

		// remove shave and arnold if its skylanders2013
		print ("//\n//\n// DOING THE PLUGIN CHECK\n//\n//\n");
		if (`workspace -q -rd` == "M:/Skylanders2013_PP10102/3D/Skylanders2013_maya/"){
			string $pluginsToDel[] = {"mtoa","shaveNode"};
			for ($each in $pluginsToDel){
				if (evalEcho("pluginInfo -q -loaded "+$each)){
					string $pluginTypes[] = `pluginInfo -q -dependNode $each`;
					string $lsCmd = "ls ";
					for ($every in $pluginTypes){
						$lsCmd += ("-type "+$every+" ");
					}
					string $pluginNodes[] = evalEcho($lsCmd);
					if (size($pluginNodes)>0){
						$result = `confirmDialog -title "Plugin Police" -message ("Nodes from the plugin: "+$each+" were found. These will be forcibly deleted before saving.") -button "Remove Nodes" -button "Leave" -button "Abort Save" -defaultButton "Remove Nodes" -cancelButton "Abort Save" -dismissString "Abort Save"`;
						if ($result == "Remove Nodes"){
							for ($every in $pluginNodes){
								catch(eval("lockNode -l 0 "+$every));
								catch(eval("delete "+$every));
							}
						}
						else if ($result == "Abort Save"){
							error ("User Aborted Save due to questionable plugin nodes in scene.");
						}
					}
				}
			}
		}

		if ($deptGuess == "anm"){

			// check that _ENVIRONMENT is name _ENVIRONMENT_ and _PREVIZ is named _PREVIS_
			string $blacklistObjs[] = {"_ENVIRONMENT", "_PREVIZ", "_PREVIS","_PROPS","_CHARACTERS"};
			string $correctObjs[] = {"_ENVIRONMENT_", "_PREVIS_", "_PREVIS_","_PROPS_","_CHARACTERS_"};
			for ($i=0;$i<size($blacklistObjs);$i++){
			    //print ("objExists "+$blacklistObjs[$i]+";\n");
				if (`objExists $blacklistObjs[$i]`){
					if (!`objExists $correctObjs[$i]`) {
                		//print ("object created\n");
                		createNode transform -n $correctObjs[$i];
					}
					string $objChildren[] =  `listRelatives -children $blacklistObjs[$i]`;
					for ($each in $objChildren) 
						parent $each $correctObjs[$i];
					delete $blacklistObjs[$i];
				}
			}

			// organize the _GROUPS_ to the top of the outliner
			string $outlinerNodes[] = {"_CUSTOM_","_PREVIS_","_SETS_","_PROPS_","_CHARACTERS_","side","front","top","persp"};
			for ($each in $outlinerNodes){
				if (`objExists $each`) reorder -front $each;
			}


			// check that ROOT nodes are not left under the scene world
			string $ungroupedAssets[] = `ls -assemblies -r 1 "ROOT"`;
			if (size($ungroupedAssets)){
				string $ungrouped = stringArrayToString ($ungroupedAssets, ",");
				confirmDialog -title "Incremental Save Error" -message ("The Following Assets are not organized under the appropriate _GROUP_ node. "+$ungrouped+" Please organize them and save again.") -button "Abort Incremental Save";
				error ("User Aborted Incremental Save");
			}

			// ask if they want to master the camera
			// make this check to see if master ref exists
			//string $result = `confirmDialog -title "Incremental Save Reminder" -message ("Does your camera need remastering?") -button "Master Camera" -button "Skip Master Camera"`;
			//if ($result == "Master Camera"){
			//	abxShotsCameraMaster `ls -type camera -r 1 "*renderCamShape"`;
			//}		
		}

		// do a name clash check
		string $ppTools = `getenv MAYA_PPTOOLS`;
		if (`exists checkNameClash`==0) 
			//evalEcho ("source \""+$ppTools+"/scripts/Toolbox/Misc/checkNameClash.mel\"");
		if (`exists checkNameClash`) {
			//print ("Running Check Name Clash\n");
			//$failure = catch(`checkNameClash`);
		}
	}
	if ($failure == 0){

		if (`filetest -d $pathGuess`){
			string $workVersion ="";

			if ($shotSequence == "")
				$workVersion = abxShotsGetLatestWorkVersion($shotFolder, $shotNameGuess,$deptGuess,$shotTakeGuess, "work",0);
			else 
				$workVersion = abxShotsGetLatestWorkVersion($shotFolder,($shotSequence+"/"+$shotNameGuess),$deptGuess,$shotTakeGuess, "work",0);


			if($workVersion == ""){
				$workVersion = "v000";
			}

			else if ($workVersion != ""){
				string $numOnly = substring($workVersion,2,size($workVersion));
				int $wVersionInt = int($numOnly);
				$wVersionInt = $wVersionInt + 1;
				string $newWorkVersion = "";
				if ($wVersionInt > 99){
					$newWorkVersion = ("v"+$wVersionInt);
				}
				else if ($wVersionInt > 9){
					$newWorkVersion = ("v0"+$wVersionInt);
				}
				else {
					$newWorkVersion = ("v00"+$wVersionInt);
				}

				string $filePath = "";
				if ($shotTakeGuess == ""){
					$filePath = ($pathGuess+$shotNameGuess+"_"+$deptGuess+"_"+$newWorkVersion+".ma");
				}
				else {
					$filePath = ($pathGuess+$shotNameGuess+"_"+$deptGuess+"_"+$shotTakeGuess+"_"+$newWorkVersion+".ma");
				}
				
				string $mayaFormat = `fileExtension $filePath`;
				if ($mayaFormat == "ma")
					$mayaFormat = "mayaAscii";
				else if ($mayaFormat == "mb")
					$mayaFormat = "mayaBinary";

				// be sure to delete the lock file for the currently open scene.
				abxLockFileCheckOut("");	
				evalEcho("file -rn \""+$filePath+"\";");
				evalEcho("file -f -save  -options \"v=0\" -type \""+$mayaFormat+"\"; abxLockFileCheckIn(\""+$filePath+"\")");
				evalEcho("addRecentFile(\""+$filePath+"\", \""+$mayaFormat+"\");");
				string $result = "";

				// if no note was specified as an argument then we must prompt the user for a note and status update
				if ($note == ""){
					if (!$force){
						string $notesDept = $deptGuess;
						if ($notesDept == "pre")
							$notesDept = "anm";
						$note = abxShotsStatusWindowShowUI (($shotSequence+"/"+$shotNameGuess), $shotFolder, $notesDept, 1);
						// abxShotsLoadHUDStatus(($shotSequence+"/"+$shotNameGuess), $shotFolder,$dept);
						// warn them again if they don't leave a note
						if ($note == "Cancel" || $note == ""){
							$note = abxShotsStatusWindowShowUI (($shotSequence+"/"+$shotNameGuess), $shotFolder, $notesDept, 2);
						}
					}
				}

				abxShotsUpdateDetailsFromScene(($shotSequence+"/"+$shotNameGuess),$shotFolder, "all","");
				abxShotsWriteShotLog  ($shotFolder, ($shotSequence+"/"+$shotNameGuess), ($deptGuess+" work"), $shotTakeGuess, $newWorkVersion, $note);

				// check if the user wants to be added to the shot database
				abxShotsAddUserCheck ($shotFolder, ($shotSequence+"/"+$shotNameGuess), $deptGuess);
				
				string $target = "Shot";
				string $targetPath = $filePath;
				string $event = "incremental save" ;
				string $message = ("Incremental Save On: "+`basenameEx $filePath`);
				//evalEcho("abxShotsSendNotification(\""+$target+"\",\""+$targetPath+"\", \""+$event+"\", \""+$message+"\") 0");
				

			}
			else {
				warning ("Could not Guess where to save this. Please Save using Shots Manager");
			}
			if (`window -exists abxShotsWindow`) abxShotsDeptTabChange;
		}
		else {
			$result = `confirmDialog -title "abxShots: Save Increment Failed" -message "Could Not Guess where to save this file. Use \"Save As\" option in the Shot Manager" -button "Ok" -defaultButton "Ok" -dismissString "Ok"`;
			return;
		}
		if (`window -exists abxShotsWindow`) abxShotsDeptTabChange;
	}
	else {
		string $result = `confirmDialog -title "Incremental Save Error" -message ("Incremental Save Aborted. File Not Saved.") -button "OK"`;
		return;
	}
}

global proc abxShotsOpenWorkScene (string $shotName, string $dept, string $takeName, string $version, int $skipLock) {
	string $shotFolder;
	string $shotsPath = (`workspace -q -rd`+"/scenes/_ALL_SHOTS/");
	if ($version == "" || $version == "latest" )
		$version = abxShotsGetLatestWorkVersion($shotFolder, $shotName, $dept, $takeName,"work",0);

	string $takeSceneName = "";

	$shotFileName = `abxShotsGetShortName $shotName`;

	if ($takeName == ""){
		$takeSceneName = ($shotFileName+"_"+$dept+"_"+$version+".ma");
	}
	else {
		$takeSceneName = ($shotFileName+"_"+$dept+"_"+$takeName+"_"+$version+".ma");
	}

	// if skiplock is true then don't actually check-in the file
	string $cmd = ("saveChanges(\"abxLockFileCheckOut(\\\"\\\");file -f -o \\\""+$shotsPath+$shotName+"/"+toupper($dept)+"/work/"+$takeSceneName+"\\\";");
	if ($skipLock != 1){
		$cmd += ("abxLockFileCheckIn(\\\""+$shotsPath+$shotName+"/"+toupper($dept)+"/work/"+$takeSceneName+"\\\");");
	}
	$cmd += ("\")");
	int $success = evalEcho($cmd);
	if (!$success)
		error("User Aborted File Open");

}






















// runs checks on scenes / takes
global proc abxShotsQCCheck(){

	// turns on all display layers
	// turns on all polygon/nurbs/hair/fluid shapes 
	// goes to the master layer
	// make sure all refs are local to project
	// makes sure all refs are set to "full" mode
	// loads all deferred references
	// prompts to run a review playblast


}


// need to add a quality control check sheet which analyzes scene checks and rates their fidelity
// need to add "flags" to shots to identify them
// master should remove all but renderCam shapes


// interdepartmental proc for saving the latest master file
// mode =0: import references and save as binary
// mode =1: keep references and save as ascii
global proc abxShotsMaster(int $force, int $mode, string $shotFolder, string $shotName, string $dept, string $takeName, string $version, string $note){
	//string $note = "";

	string $shotSequence = "";
	string $sceneFileName = "";
	string $shotNameGuess = "";
	string $shotTakeGuess = "";
	string $subDeptGuess = "";
	string $deptGuess = "";
	string $shotFolderGuess = "";
	//string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $shotsFolder = "scenes/"+$shotFolder+"/";
	string $masterExt = "mb";
	string $masterFormat = "mayaBinary";


	print ("mode="+$mode+"\n");
	if ($mode == 1){
		$masterExt = "ma";
		$masterFormat = "mayaAscii";		
	}

	// get the scene name
	string $currentScene = `file -q -sn`;
	if ($currentScene == "" && $shotName == "auto"){
		error ("Maya can't determine what scene file this is. Aborting Auto Master\n");
	}
	string $extension = `fileExtension $currentScene`;
	string $currentSceneName = `basenameEx $currentScene`;


	// tokenize the scene name for automatic incremental save
	string $tokenBuffer[];
	tokenize $currentScene "/" $tokenBuffer;

	$sceneFileName = $tokenBuffer[size($tokenBuffer)-1];

	int $latestFoundVersion = -1;

	// assume this path <workspace>/scenes/<shotFolder>/<shotName>/<dept>/<take><version>

	if (size($tokenBuffer) > 1){
		$subDeptGuess = $tokenBuffer[size($tokenBuffer)-2];
		if (size($tokenBuffer) > 2 ) {
			$deptGuess = tolower($tokenBuffer[size($tokenBuffer)-3]);
			if (size($tokenBuffer) > 3 ) {
				$shotNameGuess = $tokenBuffer[size($tokenBuffer)-4];
				if (size($tokenBuffer) > 4){
					if ($tokenBuffer[size($tokenBuffer)-5] != "_ALL_SHOTS" && $tokenBuffer[size($tokenBuffer)-5] != "_PREVIS"){
						$shotSequence = $tokenBuffer[size($tokenBuffer)-5];
						if (size($tokenBuffer) > 5){
							if ($tokenBuffer[size($tokenBuffer)-6] == "_ALL_SHOTS" || $tokenBuffer[size($tokenBuffer)-6] == "_PREVIS"){
								$shotFolderGuess = ($tokenBuffer[size($tokenBuffer)-6]);
								$shotsFolder = ("scenes/"+$tokenBuffer[size($tokenBuffer)-6]+"/");
							}
						}						
					}
					else {
						$shotFolderGuess = ($tokenBuffer[size($tokenBuffer)-5]);
						$shotsFolder = ("scenes/"+$tokenBuffer[size($tokenBuffer)-5]+"/");
					}
				}
			}
		}
	}

	print ("sceneFileName="+$sceneFileName+" shotNameGuess="+$shotNameGuess+" deptGuess ="+$deptGuess+"\n");

	int $shotNameSize = size($shotNameGuess)+1+size($deptGuess)+1;
	int $currentSceneNameSize = size($currentSceneName);
	string $noShotName = `substring $currentSceneName $shotNameSize $currentSceneNameSize `;
	
	string $tokenBuffer[];
	tokenize $noShotName "_" $tokenBuffer;
	if (size($tokenBuffer) > 1){
		$shotTakeGuess = $tokenBuffer[0];
	}
	

	if ($shotName != "auto" && $shotName != "ghetto"){
		$shotNameGuess = `abxShotsGetShortName $shotName`;
		string $tokenBuffer[];
		tokenize $shotName "/" $tokenBuffer;
		if (size($tokenBuffer)>1)
			$shotSequence = $tokenBuffer[0];
		else 
			$shotSequence = "";
		$shotTakeGuess = $takeName;
		$deptGuess = $dept;

	}
	//print ($shotNameGuess+","+$shotTakeGuess+","+$deptGuess+"\n");

	string $workDirGuess = "";
	string $masterDirGuess = "";

	string $workVersion = $version;
	string $masterVersion = "";

	//print ("shot sequence ="+$shotSequence+"\n");

	if ($shotSequence == ""){
		$workDirGuess = (`workspace -q -rd`+$shotsFolder+$shotNameGuess+"/"+toupper($deptGuess)+"/"+$subDeptGuess+"/");
		$masterDirGuess = (`workspace -q -rd`+$shotsFolder+$shotNameGuess+"/"+toupper($deptGuess)+"/master/");
		if ($workVersion == "" || $workVersion == "latest"){
			$workVersion= abxShotsGetLatestWorkVersion($shotFolder,$shotNameGuess,$deptGuess,$shotTakeGuess,"work",0);
			$masterVersion = abxShotsGetLatestWorkVersion($shotFolder,$shotNameGuess,$deptGuess,$shotTakeGuess,"master",0);
		}
	}
	else {
		$workDirGuess = (`workspace -q -rd`+$shotsFolder+$shotSequence+"/"+$shotNameGuess+"/"+toupper($deptGuess)+"/"+$subDeptGuess+"/");
		$masterDirGuess = (`workspace -q -rd`+$shotsFolder+$shotSequence+"/"+$shotNameGuess+"/"+toupper($deptGuess)+"/master/");
		if ($workVersion == "" || $workVersion == "latest"){
			$workVersion= abxShotsGetLatestWorkVersion($shotFolder,($shotSequence+"/"+$shotNameGuess),$deptGuess,$shotTakeGuess,"work",0);
			$masterVersion= abxShotsGetLatestWorkVersion($shotFolder,($shotSequence+"/"+$shotNameGuess),$deptGuess,$shotTakeGuess,"master",0);	
		}
	}

	print ("$version="+$version+":$work="+$workVersion+":master="+$masterVersion+"\n");
	

	string $filePath = "";
	string $masterFilePath = "";
	string $tempMasterFilePath = "";


	// if its the default take name
	if ($shotTakeGuess == ""){
		string $result = "OK";
		if (!$force){
			$result = `confirmDialog -title "Confirm" -message ("Mastering "+$shotNameGuess+"_"+$deptGuess+"_master."+$masterExt) -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancle"`;
		}
		if ($result == "Cancel"){		
			warning "User Cancelled Mastering Process";
			return;
		}

		$filePath = ($workDirGuess+$shotNameGuess+"_"+$deptGuess+"_"+$workVersion+".ma");
		$masterFilePath = ($masterDirGuess+$shotNameGuess+"_"+$deptGuess+"_master_"+$workVersion+"."+$masterExt);
		$tempMasterFilePath = ($masterDirGuess+"TMP"+$shotNameGuess+"_"+$deptGuess+"_master_"+$workVersion+"."+$masterExt);
	}
	// if it has an alternate take name
	else {

		string $result = "OK";
		if (!$force){
			$result = `confirmDialog -title "Confirm" -message ("Mastering "+$shotNameGuess+"_"+$deptGuess+"_"+$takeName+"_master."+$masterExt) -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancle"`;
		}
		if ($result == "Cancel"){		
			warning "User Cancelled Mastering Process";
			return;
		}
		// filepath should be new work version not work version
		$filePath = ($workDirGuess+$shotNameGuess+"_"+$deptGuess+"_"+$shotTakeGuess+"_"+$workVersion+".ma");
		$masterFilePath = ($masterDirGuess+$shotNameGuess+"_"+$deptGuess+"_"+$shotTakeGuess+"_master_"+$workVersion+"."+$masterExt);
		$tempMasterFilePath = ($masterDirGuess+"TMP"+$shotNameGuess+"_"+$deptGuess+"_"+$shotTakeGuess+"_master_"+$workVersion+"."+$masterExt);
	}

	// else if the open file is not the latest workshop
	if ($currentScene != $filePath) {
		string $result = "Open";
		// prompt the user to open the latest workshop
		if (!$force){
			$result = `confirmDialog -title "Confirm" -message ("Must Open "+$workVersion+" Workshop to Continue") -button "Open" -button "Cancel" -defaultButton "Open" -cancelButton "Cancel" -dismissString "Cancel"`;
		}
		if ($result == "Open")  {
			// open latest workshop file
			//abxShotsOpenWorkScene(($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess+"/"+$deptGuess), "");
			if ($shotSequence == "")
				abxShotsOpenWorkScene($shotNameGuess,$deptGuess,$shotTakeGuess,$workVersion,$force);
			else 
				abxShotsOpenWorkScene(($shotSequence+"/"+$shotNameGuess),$deptGuess,$shotTakeGuess,$workVersion,$force);
			$sceneFileName = $filePath;
			$currentScene = `file -q -sn`;
			$sceneFileName = `file -q -shn -sn`;
			$filePath = `file -q -sn`;
			file -mf false;
		}
		else {
			warning "User Cancelled Mastering Process";
			return;

		}
	}


	// if the latest workshop is already open 
	print ("currentScene"+$currentScene+"\n");
	print ("filePath    "+$filePath+"\n");
	print ("$version="+$version+":$work="+$workVersion+":master="+$masterVersion+"\n");
	if ($currentScene == $filePath){
		// if the file version to master is overwriting an existing master then warn the user
		string $result = "";
		if ($version == "latest"){
			if ($workVersion == $masterVersion || `file -q -mf`){
				$result = "Skip Save and Continue";
				if (!$force){
					$result = `confirmDialog -title "Shot Manager" -message ("Your Latest Work Scene Appears to Need Saving") -button "Save" -button "Increment Save" -button "Skip Save and Continue" -button "Cancel" -defaultButton "Save" -cancelButton "Cancel" -dismissString "Cancel"`;
				}
			}
		}

		// if the file needs saving
		if ($result == "Increment Save"){
			// incrementally save the workshop
			abxShotsIncrementalSave( 1,"","auto", "", "", "","Versioning up Work scene to prevent master version overwriting");
			if ($version != "" && $version != "latest" && $version != "latestMaster"){
				int $ver = `match "[1-9]+" $version`;
				$ver++;
				if ($ver<10)
					$version = ("v00"+$ver);
				else if ($ver<100)
					$version = ("v0"+$ver);
				else if ($ver<1000)
					$version = ("v"+$ver);
			}
			//$currentScene = `file -q -sn`;
			//$sceneFileName = `file -q -shn -sn`;
			//$filePath = `file -q -sn`;
			file -mf false;
			// re call the shot mastering after the icremental save so that it is incremented and reprocessed
			print ("INCREMENTING BEFORE MASTER\n");
			abxShotsMaster($force, 1,$shotFolder, $shotName, $dept, $takeName, $version, $note);

			file -mf false;
			return;
		}
		else if ($result == "Save"){
			file -f -save;
		}
		else if ($result == "Cancel"){
			return;
		}
	}




	//////////////////////////////////////////////////////////////////////////////
	// perform mastering procedures///////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////


	// check for shave plugin being loaded and warn if it isn't
	/*
	if (!`pluginInfo -q -loaded "shaveNode"`){
		global int $mayaBGError;
		$mayaBGError = 1;
		print ("Could Note Load Shave Plugin\n");
		return;
	}
	*/

	abxShotsCheckDeferredRefs;

	// remove unknown nodes that may prevent masters from saving




	// if dept is lgt
	if ($deptGuess == "lgt"){

		// delete any loaded or unloaded references
		// abxAssetsRemoveAllReferences;

		// remove items in the deleteSet
		//if (`objExists deleteSet`){
		//	select deleteSet;
		//	lockNode -l 0;
		//	delete `ls -sl`;
		//	if (`objExists deleteSet`){
		//		lockNode -l 0 deleteSet;
		//		delete deleteSet;
		//	}
		//}
		// delete history on geo
		//select `ls -type "mesh" -type "nurbsSurface" -type "nurbsCurve"`;
		//delete -ch;

		

		// flatten hierarchies		

		// remove unused shaders
		// remove all namespaces
		//abxAssetsRemoveAllNamespaces;
		
		// optionally export shading networks along with a shader map file

		// delete render layers
		//abxAssetsDeleteAllRenderLayers;

		// delete display layers
		//abxAssetsDeleteAllDisplayLayers;
		
	}
	else if ($deptGuess == "fx"){
		// remove any references called anm*
		string $tempReferences[] = `ls -type reference "anm*"`;
		for ($each in $tempReferences){
			string $filePath = `referenceQuery -f $each`;
			file -rr $filePath;

		}		
	}
	// if dept is animation or fx
	else if ($deptGuess == "anm" || $deptGuess == "fx"){

		// sets the stereo cam to parallel mode in master so that lighting dept gets the proper config
		if (`objExists master:stereoCam`){
			setAttr ("master:stereoCamCenterCamShape.stereo") 3;
		}
		else if (`objExists stereoCam`){
			setAttr ("stereoCamCenterCamShape.stereo") 3;
		}

		// clear any failed reference edits before importing references
		// this causes allot of crashing while importing references
		abxShotsClearFailedEdits;

		// swap proxy rigs to full res rigs
		abxShotsProxyToFull;

		// remove any references called tmp*
		//string $tempReferences[] = `ls -type reference "tmp*" "temp*"`;
		$refs = `file -q -r`;
		for ($each in $refs){
			string $namespace = `file -q -namespace $each`;
			if (`gmatch $namespace "tmp*"` || `gmatch $namespace "temp*"`){
				//string $filePath = `referenceQuery -f $each`;
				file -rr $each;
			}

		}
		abxShotsRemoveGeoEdits $force;
		abxShotsRestoreDeformedShader {} $force;

		// 
		if ($mode == 0){
			//confirmDialog -title "Confirm" -message "Importing References";

			// remove any reference locking before importing
			abxShotsUnlockAllReferences $force;

			abxShotsImportAllReferences $force;
			//confirmDialog -title "Confirm" -message "Removing RN nodes";

			abxDeleteAllRN;
		}
		
		//confirmDialog -title "Confirm" -message "deleting other ref junk";

		// remove unknown ref nodes
		if ($mode == 0){
			abxDeleteUnknownRefNodes;
			abxDeleteSharedRefNodes;
		}

		$lights = `ls -l -type light`;
		$lightsP = `listRelatives -f -p $lights`;
		if (size($lightsP)) catch(evalEcho("delete \""+$lightsP+"\""));

		// remove items in deleteSet
		string $deleteSetNames[] = {"deleteSet","DeleteSet","deleteset","DeleteSet","delete_set","Delete_Set"};
		for ($each in $deleteSetNames){
			if (`objExists $each`){
				select -ne $each;
				if (size(`ls -sl`) > 0){
					lockNode -l 0;
					delete `ls -sl`;
				}
				if (`objExists $each`){
					lockNode -l 0 $each;
					delete $each;
				}
			}
		}

		string $previsGroup[] = {"_PREVIS_", "_Previs_","_PREVIZ_","_Previz_","_previs_"};
		for ($each in $previsGroup){
			if (`objExists $each`){
				$children = `listRelatives -allDescendents $each`;
				for ($every in $children){
		            catch(`lockNode -l 0 $every`);
	        	}
	        }
			if (`objExists $each`) delete $each;
		}


		if ($mode == 0)
			abxShotsDeleteAllRefNodes;

		abxShotsDeleteAllRenderLayers;
		abxShotsDeleteAllDisplayLayers ;

		// make sure paths are set to MOON

		// This is done in LGT scenes instead to keep camera names small
		//// bake camera 
		//if (`objExists stereoCam`){
		//	//source ("/Resources/Maya/scripts/Toolbox/Pipeline/ppStereoCam.mel");
		//	ppStereoCamMaster("renderCam_L","renderCam_R");
		//	// remove render cam and stereo camera
		//	if (`objExists stereoCam`)
		//		delete "stereoCam";
		//	if (`objExists renderCam`)
		//		delete "renderCam";
		//}



		// delete junk left from old references
		delete `ls -r 1 -type transform "*fosterParent" "fosterParent*" "*fosterParent*"`;

		// delete unknown nodes
		if ($mode == 0){
			$unknowns = `ls -type unknown -type unknownDag -type unknownTransform`;
			for ($each in $unknowns){
				if (`pluginInfo -q -loaded "shaveNode"`){
					// if shave globals is showing as unknown we must delete it but then rebuild it.
					int $rebuildShaveGlobals = false;
					if ($each == "shaveGlobals") $rebuildShaveGlobals = false;

					lockNode -l 0 $each;
					catch(`delete $each`);

					if ($rebuildShaveGlobals == true) shaveGlobalsEditor;
				}
				else{
					catch(`lockNode -l 0 $each`);
					catch(`delete $each`);
				}
			}
		}

		// lock the renderCam shape attributes
		if (`objExists renderCam`){
			setAttr -lock true "renderCamShape.hfa";
			setAttr -lock true "renderCamShape.vfa";
			setAttr -lock true "renderCamShape.fl";
			setAttr -lock true "renderCamShape.lsr";
			setAttr -lock true "renderCamShape.fs";
			setAttr -lock true "renderCamShape.fd";
			setAttr -lock true "renderCamShape.sa";
			setAttr -lock true "renderCamShape.coi";
		}
		// lock all transforms
		abxShotsLockTRS();

		// add vray subd attrs to any geo that doesn't have it
		abxShotsVraySubDCheck();


		eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Lighting/texRezSwitchButt.mel\"");
		texRezSwitchButt("HI");

		// 
	}

		

	// archive the current master file

	if (!`filetest -d $masterDirGuess`){
		sysFile -makeDir $masterDirGuess;
	}
	

	// save the file as a temp file first
	evalEcho("abxLockFileCheckOut(\"\"); file -rename \""+$tempMasterFilePath+"\"");
	evalEcho("file -f -save  -options \"v=0\" -type \""+$masterFormat+"\"");
	//evalEcho("file -save");


	// if the save was successful to the temp file
	if (`filetest -r $tempMasterFilePath`){

		if (`filetest -w $masterFilePath`){
			// archive the older master file
			abxShotsArchiveFile ($masterFilePath, "master");
		}
			
		// rename the current temp master file
		sysFile -rename $masterFilePath $tempMasterFilePath ;
		evalEcho("file -rename \""+$masterFilePath+"\"");

		string $result = "";
		//if ($note == ""){
		//	$result = `promptDialog -title "Shot Manager Notes" -message "Describe what you changed" -button "OK" -button "Skip" -defaultButton "OK" -cancelButton "Skip" -dismissString "Skip"`;
		//}

		if ($result == "OK") {
			$note = `promptDialog -query -text`;
		}


		string $target = "Shot";
		string $targetPath = $filePath;
		string $event = "mastered" ;
		string $message = ("Shot Mastered: "+`basenameEx $filePath`);
		evalEcho("abxShotsSendNotification(\""+$target+"\",\""+$targetPath+"\", \""+$event+"\", \""+$message+"\", 1)");
				

		abxShotsWriteShotLog ($shotFolder, ($shotSequence+"/"+$shotNameGuess), ($deptGuess+" master"), $shotTakeGuess, $workVersion, $note);
	}
	else {
		error ("mastering failed: Unable to Save:"+$tempMasterFilePath);
	}	

	if ($shotSequence == ""){
		//print ("Updating Shot Details for "+$shotNameGuess+"\n");
		//abxShotsUpdateDetailsFromScene($shotNameGuess, $shotFolderGuess, "all", ""); 	
	}
	else {
		//print ("Updating Shot Details for "+$shotSequence+"/"+$shotNameGuess+"\n");
		//abxShotsUpdateDetailsFromScene(($shotSequence+"/"+$shotNameGuess),$shotFolderGuess, "all", ""); 
	}

	//$result = `confirmDialog -title "Confirm" -message ($deptGuess+" Master Successful.") -button "Re-open Work" -button "New Scene" -button "Inspect Master" -defaultButton "Open Work" -cancelButton "New Scene" -dismissString "New Scene"`;
	$result = "Inspect Master";
	if (!$force)
		$result = `confirmDialog -title "Confirm" -message ($deptGuess+" Master Successful.")  -button "New Scene" -button "Inspect Master" -defaultButton "Open Work" -cancelButton "New Scene" -dismissString "New Scene"`;
	if ($result == "Open Work"){
		//abxShotsOpenWorkScene($assetPath , "latest");
	}
	else if ($result == "New Scene"){
		 ppDoNewScene "anm";
		//file -f -new;
	}
	else if ($result == "Inspect Master"){
		headsUpMessage -time 3600  "THIS IS MASTER FILE. DO NOT MODIFY!";
	}
}

















































global proc abxShotsCameraMaster (string $cameraName[]) {

	
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $shotName= "";
	string $shotNames[];
	// get the selected shot
	if (`treeView -exists abxShotsList`){
		
		if ($shotFolder == "_PREVIS")
			$shotNames = `treeView -q -si abxPrevisList`;
		else 
			$shotNames = `treeView -q -si abxShotsList`;
	}
	$shotName = $shotNames[0];

	// check for sequence name
	string $sequenceName = "";
	string $tokenBuffer[];
	tokenize $shotName "/" $tokenBuffer;
	if (size($tokenBuffer)>1)
		$sequenceName = $tokenBuffer[0];
	
	string $sceneName = basenameEx(`file -q -sn`);
	string $fullScnName = `file -q -sn`;
	
	if ($sequenceName != ""){
		$sceneName = ($sequenceName +"/"+ $sceneName);
	}
	string $sceneShotName = `abxShotsGetSceneShotName $sceneName`;
	if (`abxShotsGetSceneShotName $sceneName` != $shotName){
		string $buttonName = ("Master As "+$sceneShotName+" Camera");
		string $result = `confirmDialog -title "Confirm" -message ("This scene file does not appear to be "+$shotName+".") -button $buttonName -button "Force" -button "Cancel"`;
		if ($result == "Cancel"){
			return;
		}
		else if ($result == $buttonName){
			$shotName = $sceneShotName;
		} 
	}
	
	string $shotFileName = `abxShotsGetShortName $shotName`;

	// check for multiple renderCams and cancel if more than one is found.
	string $renderCams[] = `ls -long -r 1 -type camera "renderCamShape"`;
	if (size($renderCams)>1){
		print ("// DUPLICATES FOUND renderCamShape: //\n");
		for ($each in $renderCams){
			print ("// "+$each+"\n");
		}
		print ("// END DUPLICATES FOUND //\n");
		string $result = `confirmDialog -title "Camera Master Error" -message ("You have multiple cameras named renderCam. Only one is allowed. Rename other renderCam to something else. See Script Editor for details. Camera Master Cancelled.") -button "OK"`;
		return;
	}

	//if (`currentUnit -q -time` != "ntsc"){
	//	string $result = `confirmDialog -title "Camera Master Error" -message ("Your Scene is not at 30 FPS. Camera Mastering Cancelled. Please adjust your frame rate to 30 using the abxFPS.mel found in StudioName->Scripts->Animation to adjust your frame rate correctly!!!") -button "OK"`;
	//	return;		
	//}

	string $cameraMasterPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName+"/CAM/master/"+$shotFileName+"_cam_master.ma");
	if (`objExists "renderCamShape"` || `objExists "master:renderCamShape"`){

		// remove the cam namespace from the scene
		if (`namespace -exists "master"`){
			if (`objExists "master:renderCamShape"`){

				if (!`attributeExists "shotName" "master:renderCam"`)
					addAttr -ln "shotName"  -dt "string"  "master:renderCam";
				if (!`attributeExists "startFrame" "master:renderCam"`)
					addAttr -ln "startFrame"  -at double  "master:renderCam";
				if (!`attributeExists "endFrame" "master:renderCam"`)
					addAttr -ln "endFrame"  -at double  "master:renderCam";
				if (!`attributeExists "fromScene" "master:renderCam"`)
					addAttr -ln "fromScene"  -dt "string"  "master:renderCam";

				setAttr -e -type "string" "master:renderCam.shotName" $shotName;
				setAttr -e -keyable true "master:renderCam.startFrame" `playbackOptions -q -min`;
				setAttr -e -keyable true "master:renderCam.endFrame" `playbackOptions -q -max`;

				setAttr -e -type "string" "master:renderCam.fromScene" `workspace -pp $fullScnName`;


				select "master:renderCamShape";
				select -add "master:renderCam";
				if (`objExists sceneConfigurationScriptNode`)
					select -add "sceneConfigurationScriptNode";

				// if the node is NOT referenced
				if (`referenceQuery -inr "master:renderCamShape"` == 0){
					$result = `confirmDialog -title "Confirm" -message ("Master "+$shotName+" Cam with master:renderCamShape?") -button "Yes" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
					if ($result == "Cancel"){		
						warning "User Cancelled Camera Master";
						return;
					}
					abxShotsArchiveFile($cameraMasterPath, "master");
				
					// remove the cam namespace before exporting and re-referencing
					namespace -f -mv "master" ":";
					namespace -rm "master";
					namespace -set ":";

					file -type "mayaAscii" -options "v=0" -es $cameraMasterPath;

					// log the camera master
					string $note = ("Camera Mastered from "+$sceneName);
					evalEcho("abxShotsWriteShotLog \""+$shotFolder+"\" \""+$shotName+"\" \"cam master\" \"---\" \"---\" \""+$note+"\"");					

					$result = `confirmDialog -title "Confirm" -message ("Camera Master Complete. Would You like to Reference the Master Now?") -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
					if ($result == "Yes"){		
						if (size(`ls -sl`) != 0){
							delete `ls -sl`;
						}
						abxShotsCameraReference($shotName);					
					}

					
				
				}
				// master:renderCamShape is a referenced node
				else {
					confirmDialog -title "Confirm" -message "master:renderCamShape is referenced and cannot be mastered. Import the cam reference, then remaster";
					//string $refNode[] = `referenceQuery -f "master:renderCamShape"`;
					//file -rr $refNode;
				}
			}
			else {
				$result = `confirmDialog -title "Confirm" -message ("Master "+$shotName+" Cam with renderCamShape?") -button "Yes" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
				if ($result == "Cancel"){		
					warning "User Cancelled Camera Master";
					return;
				}
				if (!`attributeExists "shotName" "renderCam"`)
					addAttr -ln "shotName"  -dt "string"  "renderCam";
				if (!`attributeExists "startFrame" "renderCam"`)
					addAttr -ln "startFrame"  -at double  "renderCam";
				if (!`attributeExists "endFrame" "renderCam"`)
					addAttr -ln "endFrame"  -at double  "renderCam";
				if (!`attributeExists "fromScene" "renderCam"`)
					addAttr -ln "fromScene"  -dt "string"  "renderCam";

				setAttr -e -type "string" "renderCam.shotName" $shotName;
				setAttr -e -keyable true "renderCam.startFrame" `playbackOptions -q -min`;
				setAttr -e -keyable true "renderCam.endFrame" `playbackOptions -q -max`;
				setAttr -e -type "string" "renderCam.fromScene" `workspace -pp $fullScnName`;

				select "renderCamShape";
				select -add "renderCam";
				if (`objExists sceneConfigurationScriptNode`)
					select -add "sceneConfigurationScriptNode";

				abxShotsArchiveFile($cameraMasterPath, "master");
				namespace -f -mv "master" ":";
				namespace -rm "master";
				namespace -set ":";

				file -force -type "mayaAscii" -options "v=0" -es $cameraMasterPath;

				$result = `confirmDialog -title "Confirm" -message ("Camera Master Complete. Would You like to Reference the Master Now?") -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
				if ($result == "Yes"){		
					if (size(`ls -sl`) != 0){
						delete `ls -sl`;
					}
					abxShotsCameraReference($shotName);					
				}
				
			}
		}
		else {
			$result = `confirmDialog -title "Confirm" -message ("Master "+$shotName+" Cam with renderCamShape?") -button "Yes" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
			if ($result == "Cancel"){		
				warning "User Cancelled Camera Master";
				return;
			}
			if (!`attributeExists "shotName" "renderCam"`)
				addAttr -ln "shotName"  -dt "string"  "renderCam";
			if (!`attributeExists "startFrame" "renderCam"`)
				addAttr -ln "startFrame"  -at double  "renderCam";
			if (!`attributeExists "endFrame" "renderCam"`)
				addAttr -ln "endFrame"  -at double  "renderCam";
			if (!`attributeExists "fromScene" "renderCam"`)
				addAttr -ln "fromScene"  -dt "string"  "renderCam";

			setAttr -e -type "string" "renderCam.shotName" $shotName;
			setAttr -e -keyable true "renderCam.startFrame" `playbackOptions -q -min`;
			setAttr -e -keyable true "renderCam.endFrame" `playbackOptions -q -max`;

			setAttr -e -type "string" "renderCam.fromScene" `workspace -pp $fullScnName`;

			select "renderCamShape";
			select -add "renderCam";
			if (`objExists sceneConfigurationScriptNode`)
				select -add "sceneConfigurationScriptNode";
			abxShotsArchiveFile($cameraMasterPath, "master");
			file -force -type "mayaAscii" -options "v=0" -es $cameraMasterPath;

			$result = `confirmDialog -title "Confirm" -message ("Camera Master Complete. Would You like to Reference the Master Now?") -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
			if ($result == "Yes"){		
				if (size(`ls -sl`) != 0){
					delete `ls -sl`;
				}
				abxShotsCameraReference($shotName);					
			}
		}	
		abxShotsUpdateDetailsFromScene($shotName,$shotFolder, "camDetails","");
	}
	else {
		confirmDialog -title "Confirm" -message "No renderCam or master:renderCam found in scene. Please rename your primary camera to renderCam and retry";

	}

	

}

// Masters the camera into the shot's CAM folder. 
global proc abxShotsCheckCamera () {

	



}


global proc abxShotsCameraMakeEditable () {

	string $shotNames[] = `treeView -q -si abxShotsList`;
	string $shotName = $shotNames[0];

	// check for sequence name
	string $sequenceName = "";
	string $tokenBuffer[];
	tokenize $shotName "/" $tokenBuffer;
	if (size($tokenBuffer)>1)
		$sequenceName = $tokenBuffer[0];
	
	string $sceneName = basenameEx(`file -q -sn`);
	
	if ($sequenceName != ""){
		$sceneName = ($sequenceName +"/"+ $sceneName);
	}
	
	string $sceneShotName = `abxShotsGetSceneShotName $sceneName`;
	if (`abxShotsGetSceneShotName $sceneName` != $shotName){
		string $buttonName = ("Edit "+$sceneShotName+" Camera");
		string $result = `confirmDialog -title "Confirm" -message ("This scene file does not appear to be "+$shotName+".") -button $buttonName -button "Cancel"`;
		if ($result == "Cancel"){
			return;
		}
		else if ($result == $buttonName){
			$shotName = $sceneShotName;
		} 
	}
	
	string $shotFileName = `abxShotsGetShortName $shotName`;
	
	// if reference exists 
	if (`objExists "master:renderCamShape"`){
		if (`referenceQuery -inr "master:renderCamShape"` == 1){

			$result = `confirmDialog -title "Confirm" -message ("This will Import the Referenced Camera so you can edit it.") -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancle"`;
			if ($result == "Cancel"){		
				warning "User Cancelled Camera Edit";
				return;
			}

			// unload the reference
			$refNode = `referenceQuery -rfn "master:renderCamShape"`;
			// file -unloadReference $refNode;
			// set the lock state to 0
			// setAttr ($refNode+".locked") 0;

			// load the reference
			// file -loadReference $refNode;
			// import the reference
			string $refFile = `referenceQuery -f $refNode`;
			file -ir $refFile;
		}
		else {
			confirmDialog -title "Confirm" -message "The Camera (master:renderCam) is already imported into this scene and editable.";
		}
	}
	else {
		confirmDialog -title "Confirm" -message "This Scene does not reference the master camera. (master:renderCamShape). Please reference the camera master in your scene and try again";
	}

}

global proc abxShotsCameraReference (string $shotName){

	if ($shotName == ""){
		string $shotFolder= `abxShotsGetActiveShotFolder`;
		string $shotNames[];
		// get the selected shot
		if (`treeView -exists abxShotsList`){
			
			if ($shotFolder == "_PREVIS")
				$shotNames = `treeView -q -si abxPrevisList`;
			else 
				$shotNames = `treeView -q -si abxShotsList`;
		}
		$shotName = $shotNames[0];
	}
	//if ($shotName == ""){
	//	string $shotNames[] = `treeView -q -si abxShotsList`;
	//	$shotName = $shotNames[0];
	//}

	// check for sequence name
	string $sequenceName = "";
	string $tokenBuffer[];
	tokenize $shotName "/" $tokenBuffer;
	if (size($tokenBuffer)>1)
		$sequenceName = $tokenBuffer[0];
	
	string $sceneName = basenameEx(`file -q -sn`);
	string $prefix = "master";
	
	if ($sequenceName != ""){
		$sceneName = ($sequenceName +"/"+ $sceneName);
	}

	string $shotFileName = `abxShotsGetShortName $shotName`;

	string $sceneShotName = `abxShotsGetSceneShotName $sceneName`;
	if (`abxShotsGetSceneShotName $sceneName` != $shotName){
		string $buttonName = ("Use "+$sceneShotName+" Camera Instead");
		string $button2Name = ("Reference "+$shotFileName+" Master Cam Anyway");
		string $result = `confirmDialog -title "Confirm" -message ("This scene file does not appear to be "+$shotName+".") -button $buttonName -button $button2Name -button "Cancel"`;
		if ($result == "Cancel"){
			return;
		}
		else if ($result == $buttonName){
			$shotName = $sceneShotName;
			$shotFileName = $shotName;
		} 
		else if ($result == $button2Name){
			$prefix = $shotFileName;
		}
	}

	$shotFileName = `abxShotsGetShortName $shotName`;
	string $shotFolder = `abxShotsGetActiveShotFolder`;

	string $cameraMasterPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName+"/CAM/master/"+$shotFileName+"_cam_master.ma");

	if (`filetest -r $cameraMasterPath`){
	if (`namespace -exists $prefix`){
		if (`referenceQuery -inr ($prefix+":renderCamShape")` == 1){
			string $refNode = `referenceQuery -f ($prefix+":renderCamShape")`;
			//file -rr $refNode;
			file -loadReference "camRN" -type "mayaAscii" -options "v=0" $cameraMasterPath;


		}
		else {
			if (`namespace -exists $prefix`){
				namespace -f -mv $prefix ":";
				namespace -rm $prefix;
			}
		
			namespace -set ":";
			file -r -type "mayaAscii" -gl -loadReferenceDepth "all" -namespace $prefix -options "v=0" $cameraMasterPath;
		}
		
	}
	else {
		file -r -type "mayaAscii" -gl -loadReferenceDepth "all" -namespace $prefix -options "v=0" $cameraMasterPath;
	}
	}
	else {
		confirmDialog -title "Confirm" -message ("There is no camera master for this shot: "+$shotName+".");
	}
}


global proc string abxShotsGetSceneShotName (string $sceneFile){

	
	string $tokenBuffer[];
	tokenize $sceneFile "_" $tokenBuffer;
	if (size($tokenBuffer) > 2)
		return ($tokenBuffer[0]+"_"+$tokenBuffer[1]);
	else 
		return "";
	
}

global proc string abxShotsGetSceneTakeName (string $sceneFile) {

	string $tokenBuffer[];
	tokenize $sceneFile "_" $tokenBuffer;

	string $takeName = "";
	int $takeIndex = (size($tokenBuffer)-2);
	if ($tokenBuffer[$takeIndex] != "anm" && $tokenBuffer[$takeIndex] != "fx" && $tokenBuffer[$takeIndex] != "lgt" && $tokenBuffer[$takeIndex] != "pre"){
		$takeName = $tokenBuffer[$takeIndex];
	}
	if (size($tokenBuffer) > 2)
		return $takeName;
	else 
		return "";

}


global proc string abxShotsGetLatestWorkVersion (string $shotFolder, string $shotName, string $dept, string $takeName, string $whichOne, int $getFullPath) {


		global string $abxShots_MasterSuffix;// = "<shotName>_<dept>_<version>.<ext>";

		//print ("abxGetVesion ShotName Param="+$shotName+"\n");
		string $shotFileName = `abxShotsGetShortName $shotName`;
		//string $shotFolder = `abxShotsGetActiveShotFolder`;
		//print ("abxGetVesion $takeName="+$takeName+"\n");
		

		string $workPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName+"/"+$dept+"/"+$whichOne+"/");
		if ($shotFolder == "") $workPath = (`workspace -q -rd`+"scenes/"+$shotName+"/"+$dept+"/"+$whichOne+"/");
		// get the contents of the work directory
		//print ("latest version workPath="+$workPath+"\n");

		string $filePrefix = ($shotFileName+"_"+$dept+"_");
		if($takeName != "")
			$filePrefix += ($takeName+"_");

		if ($whichOne == "master")
			$filePrefix += ($abxShots_MasterSuffix);

		string $workFolderFiles[] = `getFileList -fs ($filePrefix+"*") -folder $workPath`;
		string $workScenes[];
		string $latestFoundVersion = "v000";
		string $latestFoundFileName = "";
		int $highestVersion = 0;

		//print ("filePrefix="+$filePrefix+"\n");
			
		// iterate through the files to find the latest version number
		for ($each in $workFolderFiles){
			// match to the file naming structure
			if (`gmatch $each ($filePrefix+"*")`){
				$workScenes[size($workScenes)] = $each;
				string $wholeFileName = basenameEx($each);
				// added a plus 1
				int $prefixSize = size($filePrefix)+1;
				int $filenameSize = size($wholeFileName);
				string $fileName = `substring $wholeFileName $prefixSize $filenameSize`;
				//print ("FoundFilename="+$fileName+"\n");
				string $tokenBuffer2[];
				tokenize $fileName "_" $tokenBuffer2;
				if ($takeName != "" || size($tokenBuffer2) == 1){

					string $workVersion = "";
					$workVersion = $tokenBuffer2[size($tokenBuffer2)-1];
					
					// cut off the 'v' from the string for conversion to integer
					string $numOnly = substring($workVersion,2,size($workVersion));
					int $wVersionInt = 0;
					if (`match "[0-9]+" $numOnly` != "")
						$wVersionInt = int(`match "[0-9]+" $numOnly`);
					if ($wVersionInt > $highestVersion){
						$highestVersion = $wVersionInt;
						$latestFoundVersion = $workVersion;
						$latestFoundFileName = $each;
					}
				}
			}
		}

		if ($latestFoundVersion != ""){
			//print ($latestFoundVersion+"\n");
			if ($getFullPath)
				if ($latestFoundFileName != "")
					return ($workPath+$latestFoundFileName);
				else 
					return "";
			else
				return $latestFoundVersion;
		}
		else {
			return "";
		}
	
}

global proc abxShotsArchiveFile (string $filePath, string $type) {

	string $pathOnly = dirname($filePath);
	
	string $extension = fileExtension($filePath);
	string $sceneName= basename($filePath,("."+$extension));
	


	// create an archive of the current file

	// if there is a log file, record its workshop version and append it to the file name

	// 

	if ($type == "publish"){
		

	}
	else if ($type == "master") {
		// check to see if there is an archive folder
		string $archFolder = ($pathOnly+"/archive/");
		if (!`filetest -d $archFolder`)
			sysFile -md $archFolder;
		if (`filetest -d $archFolder`){			
			$archiveFiles = `getFileList -folder $archFolder`;
			int $latestVersion = 0;
			string $each;
			for ($each in $archiveFiles){
				string $tokenBuffer[];
				tokenize $each "." $tokenBuffer;
				if (size($tokenBuffer) == 2){
					string $tokenBuffer2[];
					tokenize $tokenBuffer[0] "_" $tokenBuffer2;
					//if (size($tokenBuffer2) == 4){
						string $foundVersionStr =  $tokenBuffer2[size($tokenBuffer2)-1];
						int $strSize = size($foundVersionStr);
						int $foundVersion = int(`substring $foundVersionStr 2 $strSize`);
						if ($latestVersion < $foundVersion){
							$latestVersion = $foundVersion;
							print ("foundVersion = "+$foundVersion+"\n");
						}
					//}
				}
			}
			$latestVersion++;
			string $latestVersionStr = "";
			if ($latestVersion < 10)
				$latestVesionStr = ("v00"+$latestVersion);
			else if ($latestVersion < 100)
				$latestVesionStr = ("v0"+$latestVersion);
			else 
				$latestVesionStr = ("v"+$latestVersion);

			
			string $archivePath = ($pathOnly+"/archive/"+$sceneName+"_"+$latestVesionStr+"."+$extension);
			print ("Archiving to :"+$archivePath+"\n");
			sysFile -move $archivePath $filePath ;
		}
	}
	

}

global proc abxShotsCaptureThumbnail (string $shotName) {


	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");
	if ($shotName == ""){
	
		string $shotNames[];
		if ($shotFolder == "_PREVIS")
			$shotNames = `treeView -q -si abxPrevisList`;
		else 
			$shotNames = `treeView -q -si abxShotsList`;
		$shotName = $shotNames[0];
	}

	string $shotFileName = `abxShotsGetShortName $shotName`;

	$result = `confirmDialog -title "Confirm" -message ("Overwrite Existing Thumbnail?") -button "Yes" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancle"`;
	if ($result == "Cancel"){		
		warning "User Cancelled Thumbnail Capture";
		return;
	}

	string $pbPath = ($shotsPath+$shotName+"/"+$shotFileName+".png");
	print ("thumbnailPath="+$pbPath+"\n");

	// set render globals
	//setAttr "defaultRenderGlobals.animation" 1;
	//setAttr defaultRenderGlobals.outFormatControl 0;
	//setAttr "defaultRenderGlobals.extensionPadding" 4;

	int $imgFormat = `getAttr defaultRenderGlobals.imageFormat`;

	// PNG image format
	setAttr defaultRenderGlobals.imageFormat 32;
	float $curFrame = `currentTime -q`;
	int $imgWidth = 500;
	int $imgHeight = 282;

	abxShotsUpdateDetailsFromScene($shotName,$shotFolder,"thumbframe","");
	
	print (`playblast -ae`+"\n");

	// setup the playblast as a command string for deferred evaluation
	
	string $cmd = ("playblast  -format iff -completeFilename \""+$pbPath+"\" -frame "+$curFrame+" -forceOverwrite -sequenceTime 0 -clearCache 1 -viewer 0 -showOrnaments 0 -percent 100 -widthHeight "+$imgWidth+" "+$imgHeight+";\n");
	
	if (`about -version` == "2012 x64" || `about -version` == "2012"){
		$cmd = ("playblast  -format iff -filename \""+$pbPath+"\" -frame "+$curFrame+" -fp 0 -forceOverwrite -sequenceTime 0 -clearCache 1 -viewer 0 -showOrnaments 0 -percent 100 -compression \"png\" -widthHeight "+$imgWidth+" "+$imgHeight+";\n");
		$cmd += ("sysFile -rename \""+$pbPath+"\" \""+$pbPath+".0.png\";");
	}
 
	// add to the deferred command to return the render global image format to sgi
	$cmd += ("setAttr defaultRenderGlobals.imageFormat "+$imgFormat+";\n");
	$cmd += ("abxShotsRefreshDetailsUI \""+$shotName+"\";\n") ;
	// run the playblast command as deferred evaluation
	//print ($cmd);
	evalDeferred ($cmd);

	
}

global proc abxShotsWriteShotDetails (string $shotName, string $shotFolder, string $shotDetails[]){

	string $shotFileName = `abxShotsGetShortName $shotName`;
	string $shotFolder = `abxShotsGetActiveShotFolder`;

	string $detailsFile = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName+"/"+$shotFileName+"_details.txt");

		// make sure status is set to 0;
	for ($i=6;$i<10;$i++){
		if ($shotDetails[$i] == ""){
			$shotDetails[$i] = "0";
		}
	}
	
	if (size($shotDetails) > 9){

		$fileId=`fopen $detailsFile "w"`;

		fprint $fileId ("abxShotsVersion=1.0\n");
		fprint $fileId ("shotName="+$shotName+"\n");
		fprint $fileId ("resolution="+$shotDetails[0]+"\n");
		fprint $fileId ("frameRate="+$shotDetails[1]+"\n");
		fprint $fileId ("startFrame="+$shotDetails[2]+"\n");
		fprint $fileId ("endFrame="+$shotDetails[3]+"\n");
		fprint $fileId ("camVersion="+$shotDetails[4]+"\n");
		fprint $fileId ("camDate="+$shotDetails[5]+"\n");
		fprint $fileId ("anmStatus="+$shotDetails[6]+"\n");
		fprint $fileId ("fxStatus="+$shotDetails[7]+"\n");
		fprint $fileId ("lgtStatus="+$shotDetails[8]+"\n");
		fprint $fileId ("cmpStatus="+$shotDetails[9]+"\n");
		if (size($shotDetails) > 10)
			fprint $fileId ("notes="+$shotDetails[10]+"\n");
		if (size($shotDetails) > 11)
			fprint $fileId ("lens="+$shotDetails[11]+"\n");
		if (size($shotDetails) > 12)
			fprint $fileId ("thumbframe="+$shotDetails[12]+"\n");
		if (size($shotDetails) > 13)
			fprint $fileId ("assets="+$shotDetails[13]+"\n");
		if (size($shotDetails) > 14)
			fprint $fileId ("flags="+$shotDetails[14]+"\n");		
		fclose $fileId;

	}
	else {
		print ("Shot details not written, incorrect number of elements in shotDetail array\n");
	}

}

global proc string[] abxShotsGetShotDetails (string $shotName, string $shotFolder) {
	
	string $shotFileName = `abxShotsGetShortName $shotName`;
	//string $shotFolder = `abxShotsGetActiveShotFolder`;	

	string $detailsFile = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName+"/"+$shotFileName+"_details.txt");
	string $shotDetails[14];
	string $headerData="";
	string $nextLine="";
	string $tokenBuffer[];
	

	if (`filetest -f ($detailsFile)`){
		 $fileId=`fopen $detailsFile "r"`;
			
			$nextLine = `fgetline $fileId`;
			tokenize $nextLine "=" $tokenBuffer;
			string $abxShotsVersion = strip($tokenBuffer[1]);
			//print ("ver is "+$abxShotsVersion+"\n");
	
			
			$nextLine = `fgetline $fileId`;
			tokenize $nextLine "=" $tokenBuffer;
			string $abxShotsName = strip($tokenBuffer[1]);
			//print ("shotName is "+$abxShotsName+"\n");

			int $index = 0;
			while (size($nextLine) > 0){
				
 				$nextLine = `fgetline $fileId`;
				tokenize $nextLine "=" $tokenBuffer;
				$shotDetails[$index] = strip($tokenBuffer[1]);
				$index++;
			}
 		fclose $fileId;
		return $shotDetails;
	}
	else{
		//print ($detailsFile+" File not Found. Ignoring.\n");
		return {""};
	}
	
	

}

global proc abxShotsBrowseShot (string $shotName, int $mode){

	string $shotsPath = (`workspace -q -rd`+"scenes/_ALL_SHOTS/");
	if ($mode > 0 && $mode < 6)
		 $shotsPath = (`workspace -q -rd`+"../../RENDER/_ALL_SHOTS/");

	$projPath = toNativePath($shotsPath+$shotName); 

	if ($mode == 1)
		$projPath = toNativePath($shotsPath+$shotName+"/ANM/"); 
	else if ($mode == 2)
		$projPath = toNativePath($shotsPath+$shotName+"/FX/"); 
	else if ($mode == 3)
		$projPath = toNativePath($shotsPath+$shotName+"/LGT/"); 
	else if ($mode == 4)
		$projPath = toNativePath($shotsPath+$shotName+"/PRECOMP/"); 
	else if ($mode == 5)
		$projPath = toNativePath($shotsPath+$shotName+"/COMP/"); 

	if (`about -os ` == "mac")
		exec ("open -a finder \""+$projPath+"\"");
	else 
		system(("start explorer "+$projPath));
}

global proc abxShotsCheckDeferredRefs (){
	string $refNodes[] = `file -q -r`;
	string $deferredRefNodes[];
	int $foundDeferred = false;
	string $result = "";

	for ($each in $refNodes){
		if (!`referenceQuery -isLoaded $each`){

			if ($foundDeferred == false){
				$result = `confirmDialog -title "Shot Manager: Master" -message ("You have unloaded references in your scene.") -button "Load All References" -button "Skip Unloaded References" -defaultButton "Skip Unloaded References" -button "Abort" -cancelButton "Abort" -dismissString "Abort"`;
				$foundDeferred = true;
			}
			if ($result == "Load All References"){
				string $refNode = `referenceQuery -rfn $each`;
				evalEcho ("file -loadReference \""+$each+"\"");
				file -ir $each;
			}
			else if ($result == "Skip Unloaded References"){
				string $refNode = `referenceQuery -rfn $each`;
				evalEcho ("file -removeReference \""+$each+"\"");
			}
			else if ($result == "Abort"){
				error ("Mastering Aborted due to unloaded file references that need resolving.");
			}

			//$deferredRefNodes[size($deferredRefNodes)] = $each;

		}		
	}
}

global proc abxShotsUnlockAllReferences (int $force){
string $refNodes[] = `file -q -r`;
	// turn off error prompts
	file -pmt false;
	for ($each in $refNodes){
		string $refNode = `referenceQuery -rfn $each`;
		string $filepath = `referenceQuery -f -wcn $refNode`;
		$isLocked = `getAttr ($refNode + ".locked")`;
		if ($isLocked == true){
			string $refNode = `referenceQuery -rfn $each`;
			string $filepath = `referenceQuery -f -wcn $refNode`;
			if (`referenceQuery -isLoaded $each`){
				
				file -unloadReference $refNode;
				setAttr ($refNode + ".locked") 0;
				file -pmt false -loadReference $refNode;

			}
			else {
				setAttr ($refNode + ".locked") 0;
			}
		}
	}
	// turn on error prompts
	file -pmt true;
}

global proc abxShotsImportAllReferences (int $force) {
	file -pmt false;
	string $refNodes[] = `file -q -r`;
	// loop until all references and sub references are imported
	while (size($refNodes) != 0){
		for ($each in $refNodes){
			string $refNode = `referenceQuery -rfn $each`;
			string $filepath = `referenceQuery -f -wcn $refNode`;
			referenceEdit -failedEdits true -successfulEdits false -removeEdits $each;
			// not sure why but some references crash while importing and quering the edit strings seems to fix it
			referenceQuery -editStrings $each;
			if (`referenceQuery -isLoaded $each`){
				// need to unlock a reference first (this means reloading the reference so this may cost time on heavy scenes)

				// replace locked reference with the same reference but not locking
				//file -unloadReference $refNode;
				//setAttr ($refNode + ".locked") 0;
				//file -loadReference $refNode $filepath; 
				//file -loadReference $refNode;

				//import the reference without being locked
				
				file -ir $each;
			}

			else {
				warning ("Loading all deferred references");
				// make sure it isnt locked
				//setAttr ($refNode + ".locked") 0;
				string $refNode = `referenceQuery -rfn $each`;

				evalEcho ("file -loadReference \""+$refNode+"\"");
				file -ir $each;
			}
		}
		$refNodes = `file -q -r`;
	}
	file -pmt true;
}

global proc abxShotsImportScene (string $impFile, string $prefix, string $type){

	if ($type == "rename"){
		namespace -set ":";

		if ($prefix == "CLASH"){

			// import the geo with a TEMP namespace to prevent clashes
			evalEcho ("file -import -loadReferenceDepth \"all\" -namespace \""+$prefix+"\" -pr -options \"v=0\" \""+$impFile+"\"");

			// find reference namespaces within the TEMP namespace that might clash
			string $refFiles[] = `file -q -r`;
			string $parentNamespace[];
			string $origNamespace[];
			string $newNamespace[];
			string $clashNamespace[];
			for ($i=0;$i<size($refFiles);$i++){

				// get the reference node parent namespaces
				string $pns[] = `file -q -pns $refFiles[$i]`;
				if (size($pns) > 0)
					$parentNamespace[$i] = $pns[0];
				else
					$parentNamespace[$i] = "";
				$origNamespace[$i] = `file -q -namespace $refFiles[$i]`;
			}

			for ($i=0;$i<size($refFiles);$i++){
				// if parent namespace is clash
				if ($parentNamespace[$i] == "CLASH"){					
					string $validNamespace = $origNamespace[$i];
					print ("testing CLASH namespace:"+$origNamespace[$i]+"\n");
					// get the ref namespace
					if (`namespace -ex (":"+$origNamespace[$i])`){
						print ("found clashing CLASH namespace:"+$origNamespace[$i]+"\n");
						$clashNamespace[size($clashNamespace)] = $origNamespace[$i];
						string $namespace = $origNamespace[$i];
						string $numIfAny =  `match "[0-9]+$" $namespace`;
						int $numSize = size($numIfAny);
						int $endPosition = size($namespace) - $numSize;
						string $baseNamespace = `substring $namespace 1 $endPosition`;
						int $number = 1;
						$validNamespace = ($baseNamespace+$number);
						// while the ref namespace exists on the root namespace
						while (`namespace -ex (":"+$validNamespace)`){
							$number++;
							$validNamespace = ($baseNamespace+$number);
						}
					}
					// set ref namespace to new namespace
					$newNamespace[$i] = $validNamespace;
					//file -e -namespace $validNamespace $each;
				}
				else {
					$newNamespace[$i] = $origNamespace[$i];
				}
			}		

			// rename root namespaces that clash
			for ($i=0;$i<size($refFiles);$i++){
				// if its not 
				print ("parentNamespace=\""+$parentNamespace[$i]+"\"\n");
				if ($parentNamespace[$i] == ""){
					print ("root namespace found\n");
					if (stringArrayContains($newNamespace[$i],$clashNamespace)){
						print ("clashing root namespace found\n");
						$newNamespace[$i] = ($newNamespace[$i]+"CLASHTEMP");
					}
				}
			}


			// temporarily rename the root level namespaces to allow us to remove the CLASH namespace cleanly;
			for ($i=0;$i<size($refFiles);$i++){
				if (`gmatch $newNamespace[$i] "*CLASHTEMP"`){
					// move the clashing namespace
					file -e -namespace $newNamespace[$i] $refFiles[$i];
					// if the namespace persists after renaming the reference namespace 
					if (`namespace -ex $origNamespace[$i]`){
						// move the remaining namespace contents to the root
						namespace -f -mv $origNamespace[$i] ":";
						// remove the namespace
						namespace -rm $origNamespace[$i];
					}
				}
			}			
				
			// remove the TEMP namespace by moving its contents to the root. let maya handle non-reference clashes on its own.
			namespace -f -mv "CLASH" ":";
			namespace -set ":";
			namespace -rm "CLASH";


			// rename the reference node namespaces to their new names
			for ($i=0;$i<size($refFiles);$i++){
				if ($parentNamespace[$i] == "CLASH"){
					if ($newNamespace[$i] != $origNamespace[$i])
						file -e -namespace $newNamespace[$i] $refFiles[$i];
				}
			}

			// restore the clash namespaces to their old names
			for ($i=0;$i<size($refFiles);$i++){
				if (`gmatch $newNamespace[$i] "*CLASHTEMP"`){
					file -e -namespace $origNamespace[$i] $refFiles[$i];
				}

			}		


			//$fileCmd += (" -ra false -options \"v=0\" \""+$impFile+"\"");
			//evalEcho ( -options \"v=0\" \""+$impFile+"\"");
		}
		else {
			//$fileCmd += (" -ra false -options \"v=0\" \""+$impFile+"\"");
			evalEcho ("file -import -ra true -loadReferenceDepth \"all\" -pr -mnc false -rpr \""+$prefix+"\" -options \"v=0\" \""+$impFile+"\"");
		}
		//evalEcho ($fileCmd);
	}
	else if ($type == "namespace"){
		namespace -set ":";
		evalEcho ("file -import -loadReferenceDepth \"all\" -namespace \""+$prefix+"\" -pr -options \"v=0\" \""+$impFile+"\"");
	}
	namespace -set ":";
}

global proc abxShotsDeleteAllRefNodes (){
	select -clear;
	string $refNodes[] = `ls -type reference`;
	for ($each in $refNodes){
		lockNode -lock 0 $each;
		delete $each;
	}
	

}

global proc abxShotsDeleteAllRenderLayers (){
	select -clear;
	string $renderLayers[] = `ls -type renderLayer`;

	for ($each in $renderLayers){
		if (!`gmatch $each "*defaultRenderLayer*"`){
			if (!`about -batch`){
				renderLayerEditorDeleteLayer RenderLayerTab $each;
				//delete $each;
				updateEditorRenderLayer RenderLayerTab;
				print ("Deleting Render Layer "+$each+"\n");
			}
			else {
				delete $each;
			}
		}
	}


	$renderLayers = `ls -type renderLayer`;
	
	for ($each in $renderLayers){
		if (!`gmatch $each "defaultRenderLayer"`)
			delete $each;
	}

}

global proc abxShotsDeleteAllDisplayLayers (){

	// BUG: need to have it remove 'lookAt' and 'camera' objects as members before deleteing otherwise it actually deletes the cam
	select -clear;
	string $renderLayers[] = `ls -type displayLayer`;
	for ($each in $renderLayers){
		if (!`gmatch $each "defaultLayer"`)
			delete $each;
	}

}

global proc string[] abxShotsSort (string $listArray[]){
	// do a sort that is based on underscore seperations

	string $result[];

	for ($i=0;$i<size($listArray);$i++){
		string $tokenBuffer[];
		tokenize $listArray[$i] "_" $tokenBuffer;
		

	}
	return $result;
}

global proc abxDeleteAllRN() {
	// clear out old reference nodes
	$oldRN = `ls -type reference`;
	for ($each in $oldRN){
		lockNode -l 0 $each;
		delete $each;
	}

}

global proc abxDeleteUnknownRefNodes (){
	select `ls -r 1 -type reference "*UNKNOWN*"`;
	if (size(`ls -sl`) > 0)
		lockNode -l 0;
	delete `ls -r 1 -type reference "*UNKNOWN*"`;
}

global proc abxDeleteSharedRefNodes (){
	select `ls -r 1 -type reference "*shared*"`;
	if (size(`ls -sl`) > 0)
		lockNode -l 0;
	delete `ls -r 1 -type reference "*shared*"`;
}

global proc abxShotsGatherAudio () {

	string $currentScene = `file -q -sn`;

	string $shotNameGuess = "";
	string $shotTakeGuess = "";
	string $shotDeptGuess = "";
	string $shotSubDeptGuess = "";
	string $shotSequenceGuess = "";
	string $shotFolderGuess = "";
	string $extension = `fileExtension $currentScene`;
	string $currentSceneName = `basenameEx $currentScene`;
	
	string $tokenBuffer[];
	tokenize $currentScene "/" $tokenBuffer;
	if (size($tokenBuffer) > 1){
		$subDeptGuess = $tokenBuffer[size($tokenBuffer)-2];
		if (size($tokenBuffer) > 2 ) {
			$shotDeptGuess = tolower($tokenBuffer[size($tokenBuffer)-3]);
			if (size($tokenBuffer) > 3 ) {
				$shotNameGuess = $tokenBuffer[size($tokenBuffer)-4];
				if (size($tokenBuffer) > 4){
					if ($tokenBuffer[size($tokenBuffer)-5] != "_ALL_SHOTS" && $tokenBuffer[size($tokenBuffer)-5] != "_PREVIS"){
						$shotSequenceGuess = $tokenBuffer[size($tokenBuffer)-5];
						if ($tokenBuffer[size($tokenBuffer)-6] == "_ALL_SHOTS" || $tokenBuffer[size($tokenBuffer)-6] == "_PREVIS" ){
							$shotFolderGuess = $tokenBuffer[size($tokenBuffer)-6];
						}	
					}
					else{
						$shotFolderGuess = $tokenBuffer[size($tokenBuffer)-5];
					}
				}
			}
		}
	}
	if ($shotFolderGuess == "_PREVIS" || $shotFolderGuess == "_ALL_SHOTS"){	
	string $audioNodes[] = `ls -type audio`;
	for ($each in $audioNodes){
		string $path = `getAttr ($each+".filename")`;
		string $fullPath = `workspace -en $path`;
		print ("filetest -r "+$fullPath+"\n");
		if (`filetest -r $fullPath`){
			string $filename = `basename $path ""`;
			// if it appears to be outside the project structure
			if ($path == `workspace -pp $path`){
				string $soundFolder = "";
				if ($shotSequenceGuess != ""){
					$soundFolder = (`workspace -q -rd`+"sound/"+$shotFolderGuess+"/"+$shotSequenceGuess+"/"+$shotNameGuess+"/");
					sysFile -md $soundFolder;
					sysFile -cp ($soundFolder+$filename) ($path);
					print ("path="+$path+" filename = "+$filename+" soundFolder="+$soundFolder+"\n");
					setAttr -type "string" ($each+".filename") ($soundFolder+$filename) ;
				}

			}
	}
	}
	}
}

global proc abxShotsUseAudioMaster (){
	// find the master audio file for the given scene
	// e.g. M:\Skylanders2013_PP10102\RENDER\FROM_EDIT\_MASTER_AUDIO\FMV1\FMV1_485.aif
	$filePath = `file -q -sn`;
	// 0:Server 1:Job 2:ShotFolder 3:Seq 4:Shot 5:dept 6:subDept 7:take 8:version 9:ext
	string $shotInfo[] = abxShotsGetFromPath($filePath);
	string $mAudioPath = ($shotInfo[0]+"/"+$shotInfo[1]+"/RENDER/FROM_EDIT/_MASTER_AUDIO/"+$shotInfo[3]+"/"+$shotInfo[3]+"_"+$shotInfo[4]+".aif");
	$properName = ($shotInfo[3]+"_"+$shotInfo[4]);
	if (`filetest -r $mAudioPath`){
		print ("FOUND MASTER AUDIO FILE: "+$mAudioPath+"\n");
		string $foundMAudioNode = "";
		string $audioNodes[] = `ls -type audio`;
		for ($each in $audioNodes){
			string $path = `getAttr ($each+".filename")`;	
			//print ("COMPARING:"+$path+" to "+$mAudioPath+"\n");
			if ($path == $mAudioPath || $path == toNativePath($mAudioPath)){
				$foundMAudioNode = $each;
			}
		}
		if ($foundMAudioNode != ""){
			if ($foundMAudioNode != $properName){
				if (`objExists $properName`){
					rename $properName ("NOTVALID_"+$properName);
				}
				rename $foundMAudioNode $properName;
			}
			else {
				print ("MASTER AUDIO ALREADY EXISTS IN SCENE\n");
			}
		}
		else {
			string $newAudio = $properName;
			if (!`objExists $properName`){
				print ("MASTER AUDIO NODE NOT FOUND IN SCENE. CREATING... PLEASE SET THE PROPER AUDIO OFFSET ON NEW AUDIO NODE\n");
				$newAudio = `createNode -ss audio -n $properName`;
			}
			else{
				print ("MASTER AUDIO NODE FOUND BUT NOT SET CORRECTLY. SETTING TO CORRECT PATH\n");
			}

			setAttr -type "string" ($newAudio+".filename") $mAudioPath;
		}

	// search through in scene audio files

	// if an audio node to the master file does not exist. create one
	}


}


global proc abxShotsUpdateDetailsFromScene (string $shotName, string $shotFolder, string $updateWhat, string $updateValue) {

	string $shotDetails[];
	string $shotFileName = `abxShotsGetShortName $shotName`;

	string $oldDetails[] = abxShotsGetShotDetails($shotName, $shotFolder);

	// res
	$shotDetails[0]=$oldDetails[0];
	//framerate
	$shotDetails[1]=$oldDetails[1];
	//anim start frame
	$shotDetails[2]=$oldDetails[2];
	//anim end frame
	$shotDetails[3]=$oldDetails[3];
	// cam version
	$shotDetails[4]=$oldDetails[4];
	// camDate
	$shotDetails[5]=$oldDetails[5];
	// anmStatus
	$shotDetails[6]=$oldDetails[6];
	// fxStatus
	$shotDetails[7]=$oldDetails[7];
	// lgtStatus
	$shotDetails[8]=$oldDetails[8];
	// cmpStatus
	$shotDetails[9]=$oldDetails[9];	
	// shot notes
	$shotDetails[10]=$oldDetails[10];
	// lens info
	$shotDetails[11]=$oldDetails[11];
	// thumb frame
	$shotDetails[12]=$oldDetails[12];
	// assets in use
	$shotDetails[13]=$oldDetails[13];
	// flags 
	$shotDetails[14]=$oldDetails[14];


	if ($updateWhat == "shotDetails" || $updateWhat == "all"){
		// resolution
		getAttr "defaultResolution.width";

		$shotDetails[0] = (`getAttr "defaultResolution.width"`+" X "+`getAttr "defaultResolution.height"`);

		// frame rate
		$shotDetails[1]= `currentUnit -q -time`;

		if ( $updateWhat != "all"){
			$shotDetails[2] = `playbackOptions -q -min`;
			$shotDetails[3] = `playbackOptions -q -max`;
		}
	}

	if ($updateWhat == "camDetails"){
		// cam version
		$shotDetails[4]=$oldDetails[4];
		//camDate
		$shotDetails[5]=`date`;
	}


	//if ($updateWhat == "pre status");
		//$shotDetails[10]=`intSlider -q -value abxAssetsStatusWindowSlider`;	
	if ($updateWhat == "anm status")
		$shotDetails[6]=$updateValue;
	if ($updateWhat == "fx status")
		$shotDetails[7]=$updateValue;
	if ($updateWhat == "lgt status")
		$shotDetails[8]=$updateValue;	
	if ($updateWhat == "cmp status")
		$shotDetails[9]=$updateValue;

	if ($updateWhat == "notes"){
		$shotDetails[10]=$updateValue;
	}

	if ($updateWhat == "lens" || $updateWhat == "all"){
		string $camLensInfo = "";
		string $foundCam = "";
		if (`objExists master:renderCam`)
			$foundCam = "master:renderCam";
		else if (`objExists renderCam`)
			$foundCam = "renderCam";
		if ($foundCam != "")
			$camLensInfo = (`getAttr ($foundCam+".focalLength")`+","+`getAttr ($foundCam+".horizontalFilmAperture")`+","+`getAttr ($foundCam+".verticalFilmAperture")`);
		$shotDetails[11] = $camLensInfo;
	}
	if ($updateWhat == "thumbframe"){
		$shotDetails[12] = `currentTime -q`;
	}
	if ($updateWhat == "assets" || $updateWhat == "all"){
		string $assetsInScene[] = abxAssetsGetAssetsInScene();
		string $assetsAsStr = stringArrayToString($assetsInScene,",");
		$shotDetails[13] = $assetsAsStr;
	}
	if ($updateWhat == "flags"){
		$shotDetails[14] = $updateValue;
	}
	abxShotsWriteShotDetails ($shotName, $shotFolder, $shotDetails);

}

global proc abxShotsUpdateDetail (string $shotName, string $shotFolder, string $whichOne, string $value){

	string $shotDetails[];
	string $oldDetails[] = abxShotsGetShotDetails($shotName, $shotFolder);

	// res
	$shotDetails[0]=$oldDetails[0];
	//framerate
	$shotDetails[1]=$oldDetails[1];
	//anim start frame
	$shotDetails[2]=$oldDetails[2];
	//anim end frame
	$shotDetails[3]=$oldDetails[3];
	// cam version
	$shotDetails[4]=$oldDetails[4];
	//camDate
	$shotDetails[5]=$oldDetails[5];
	//anmStatus
	$shotDetails[6]=$oldDetails[6];
	//fxStatus
	$shotDetails[7]=$oldDetails[7];
	//lgtStatus
	$shotDetails[8]=$oldDetails[8];
	// cmpStatus
	$shotDetails[9]=$oldDetails[9];
	//notes
	$shotDetails[10]=$oldDetails[10];
	// lens info
	$shotDetails[11]=$oldDetails[11];
	// thumb frame
	$shotDetails[12]=$oldDetails[12];
	// assets in use
	$shotDetails[13]=$oldDetails[13];
	// shot flags
	$shotDetails[14]=$oldDetails[14];

	if ($whichOne == "frameRange"){
		string $tokenBuffer[];
		tokenize $value "-" $tokenBuffer;
		if (size($tokenBuffer) == 2){
			$shotDetails[2] = $tokenBuffer[0];
			$shotDetails[3] = $tokenBuffer[1];
		}
	}

	abxShotsWriteShotDetails ($shotName, $shotFolder, $shotDetails);
}

global proc string[] abxShotsGetSequences (string $shotFolder) {

	string $results[];
	string $projectPath = `workspace -q -rd`;
	string $shotsFolder[] = `getFileList -folder ($projectPath+"/scenes/"+$shotFolder+"/")`;

	string $sorted[] = sort($shotsFolder);

	for ($each in $sorted){
		if (`filetest -d ($projectPath+"/scenes/"+$shotFolder+"/"+$each+"/")`){
			if ($each != ".DS_Store"){

				// determine if it is a scene subfolder
				string $subFolders[] = `getFileList -folder ($projectPath+"/scenes/"+$shotFolder+"/"+$each+"/")`;

				int $isShotFolder = 0;
				for ($every in $subFolders){
					if ($isShotFolder == 0){
						if  ($every == "ANM" || $every == "LGT" || $every == "FX" || $every == "PRE"){
							$isShotFolder = 1;
						}
					}
					else {
						break;
					}
				}

				if ($isShotFolder == 0){
					$results[(size($results))] = $each;
				}
			}
		}
	}
	return $results;
}

global proc abxShotsWriteShotLog (string $shotFolder, string $shotName, string $updateWhat, string $takeName, string $version, string $note){

	// shot base name
	string $shotFileName = `abxShotsGetShortName $shotName`;

	string $logFile = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName+"/"+$shotFileName+"_log.txt");
	print ($logFile+"\n");

	string $tokenBuffer[];
	tokenize $updateWhat " " $tokenBuffer;
	string $process = toupper($tokenBuffer[1]);
	string $dept;
	while (size($process)<10){
		$process+=" ";
	}
	string $dept = toupper($tokenBuffer[0]);
	while (size($dept)<10){
		$dept+=" ";
	}
	string $date = `date`;
	
	string $user = `getenv USER`;
	while (size($user)<10){
		$user+=" ";
	}	
	while (size($version)<10){
		$version+=" ";
	}

	if ($takeName == "")
		$takeName = "---";

	while (size($takeName)<10){
		$takeName +=" ";
	}

	$fileId=`fopen $logFile "a"`;
		
		fprint $fileId ($date+"\t"+$dept+"\t"+$process+"\t"+$takeName+"\t"+$version+"\t"+$user+"\t"+encodeString($note)+"\n");

	fclose $fileId;



}

global proc string abxShotsGetFriendlyDate(string $file){

	if (`filetest -r $file`){
		string $pyCmd = ("import os; import time; os.path.getmtime('"+$file+"');");

		string $modDate = python($pyCmd);
		string $curDate = python("time.time()");
		//print ("ModDate = "+$modDate+" curDate="+$curDate+"\n");
		int $mDate = int($modDate);
		int $cDate = int($curDate);
		int $day_diff = (($cDate - $mDate)/86400);
		int $second_diff = (($cDate - $mDate)%86400);

	    if ($day_diff < 1){
	        if ($second_diff < 10)
	            return "just now";
	        if ($second_diff < 60)
	            return ($second_diff+" seconds ago");
	        if ($second_diff < 120)
	            return  "a minute ago";
	        if ($second_diff < 3600)
	            return (( $second_diff / 60 )+" minutes ago");
	        if ($second_diff < 7200)
	            return ("an hour ago");
	        if ($second_diff < 86400)
	            return (($second_diff / 3600 )+" hours ago");
	    }
	    else if ($day_diff == 1)
	        return "Yesterday";
	    else if ($day_diff < 7)
	        return (($day_diff) + " days ago");
	    else if ($day_diff < 31)
	        return (($day_diff/7) + " weeks ago");
	    else if ($day_diff < 365)
	        return (($day_diff/30) + " months ago");
	    else 
	    	return (($day_diff/365) + " years ago");
	}
	else {
		return "Never";
	}
}

global proc string abxShotsGetFriendlyLogDate(string $strTime){
	if (size($strTime)> 4){
	//string $modDate = 0;//python("import time;time.strptime('"+$strTime+"', '%Y/%m/%d %H:%M:%S')");
	//print ("\""+$strTime+"\"\n");
	string $modDate = python("import time;from datetime import datetime;do = datetime.strptime('"+$strTime+"', '%Y/%m/%d %H:%M:%S');time.mktime(do.timetuple());");
	string $curDate = python("time.time()");
	int $mDate = int($modDate);
	int $cDate = int($curDate);
	int $day_diff = (($cDate - $mDate)/86400);
	int $second_diff = (($cDate - $mDate)%86400);

    if ($day_diff < 1){
        if ($second_diff < 10)
            return "just now";
        if ($second_diff < 60)
            return ($second_diff+" seconds ago");
        if ($second_diff < 120)
            return  "a minute ago";
        if ($second_diff < 3600)
            return (( $second_diff / 60 )+" minutes ago");
        if ($second_diff < 7200)
            return ("an hour ago");
        if ($second_diff < 86400)
            return (($second_diff / 3600 )+" hours ago");
    }
    else if ($day_diff == 1)
        return "Yesterday";
    else if ($day_diff < 365)
        return (($day_diff) + " days ago");
    //else if ($day_diff < 31)
    //    return (($day_diff/7) + " weeks ago");
    //else if ($day_diff < 365)
    //    return (($day_diff/30) + " months ago");
    else 
    	return (($day_diff/365) + " year ago");
	}
	else {
		return "never";
	}
}

global proc string abxShotsGetMDate(string $file){

	if (`filetest -r $file`){
		string $pyCmd = ("import os; import time; time.ctime(os.path.getmtime('"+$file+"'));");
		string $result = python($pyCmd);
		string $timeago = abxShotsGetFriendlyDate($file);
		return ($result +"    ( "+$timeago+" )");
	}
	else {
		return "Never";
	}
}

global proc string abxShotsGetMDateS(string $file){

	if (`filetest -r $file`){
		string $pyCmd = ("import os; import time;os.path.getmtime('"+$file+"');");
		string $result = python($pyCmd);
		return $result;
	}
	else {
		return "0";
	}
}

global proc statusPrompt(string $shotName, string $shotFolder, string $deptName,int $mode){


	string $cmd = ("layoutDialog -dismiss (`intSlider -q -v abxShotsStatusWindowSlider`+\"|\"+`intSlider -q -v abxShotsStatusWindowStageSlider`+\"|\"+`scrollField -q -text abxShotsStatusNotesField`);");

    // Get the dialog's formLayout.
    string $form = `setParent -q`;
		frameLayout -lv 1 -label ($deptName+" Status") -borderStyle "out" abxShotsStatusFrmeLyt;
			columnLayout;
				separator -vis 1 -h 20;
				rowLayout -cw 1 20 -cw 2 200 -cw 2 200 -cw 3 200 -cw 4 20 -numberOfColumns 4;
					separator -vis 1;
					rowLayout -cw 1 20 -cw 2 205 -numberOfColumns 2 abxShotsStatWinStageLyt;
						columnLayout;
							separator -vis 0 -h 5;
							intSlider -h 100 -horizontal false -min 0 -max 2 -value 0 -step 1 abxShotsStatusWindowStageSlider;
						setParent ..;
						columnLayout -rs 5;
							button -w 120 -h 40 -label "Polishing" -ann "Polish: Smoothing has been approved, adding finishing touches" -c ("intSlider -e -value 2 abxShotsStatusWindowStageSlider;");	
							button -w 120 -h 40 -label "Splining" -ann "Splining: Block has been approved. Animation is now being Smoothed out" -c ("intSlider -e -value 1 abxShotsStatusWindowStageSlider;");
							button -w 120 -h 40 -label "Blocking" -ann "Blocking: Rough Timing of Animation. " -c ("intSlider -e -value 0 abxShotsStatusWindowStageSlider;");
						setParent ..;
					setParent ..;
					rowLayout -cw 1 20 -cw 2 350 -numberOfColumns 2;
						columnLayout;
							//separator -vis 1 -h 3;
							intSlider -h 196 -horizontal false -min -3 -max 5 -value 0 -step 1 abxShotsStatusWindowSlider;
						setParent ..;
						columnLayout -rs 1;
						//rowLayout -cw 1 95 -cw 2 95 -cw 3 95 -cw 4 95 -cw 5 95 -cw 6 95 -cw 7 95 -numberOfColumns 8;
							button -w 120 -label `abxShotsStatAsLabel(5)` -ann "Client Approved: Item has been approvd by the client" -bgc .15 .83 .77 -ebg 0 -c ("intSlider -e -value 5 abxShotsStatusWindowSlider;");
							button -w 120 -label `abxShotsStatAsLabel(4)` -ann "Internal Approved:  Item has been approved by in-house directors and is awaiting final client approval" -bgc .3 .7 .4 -ebg 0 -c ("intSlider -e -value 4 abxShotsStatusWindowSlider;");
							button -w 120 -label `abxShotsStatAsLabel(3)` -ann "Review Needed: Item has had all notes and comments addressed and it is awaiting review for approval" -bgc .9 .85 .34 -ebg 0 -c ("intSlider -e -value 3 abxShotsStatusWindowSlider;");
							button -w 120 -label `abxShotsStatAsLabel(2)` -ann "Work In Progress: Item is actively being worked on" -bgc .7 .5 .3 -ebg 0 -c ("intSlider -e -value 2 abxShotsStatusWindowSlider;");
							button -w 120 -label `abxShotsStatAsLabel(1)` -ann "Revision Needed: Item requires changes to be addressed" -bgc .7 .3 .3 -ebg 0 -c ("intSlider -e -value 1 abxShotsStatusWindowSlider;");
							button -w 120 -label `abxShotsStatAsLabel(0)` -ann "Not Started: Item has not been worked yet." -bgc .2 .2 .2 -ebg 0 -c ("intSlider -e -value 0 abxShotsStatusWindowSlider;");
							button -w 120 -label `abxShotsStatAsLabel(-1)` -ann "Ready To Start: Item is prepped and Ready to start working on" -bgc .7 .4 .7 -ebg 0 -c ("intSlider -e -value -1 abxShotsStatusWindowSlider;");
							button -w 120 -label `abxShotsStatAsLabel(-3)` -ann "On Hold: Work on the item is temporarily suspended." -bgc .2 .4 .7 -ebg 0 -c ("intSlider -e -value -3 abxShotsStatusWindowSlider;");
							button -w 120 -label `abxShotsStatAsLabel(-2)` -ann "Dead: Items set to this means Do Not Use them." -bgc .15 .15 .15 -ebg 0 -c ("intSlider -e -value -2 abxShotsStatusWindowSlider;");
						setParent ..;
					setParent ..;
				separator -vis 1;
				setParent ..;
				separator -vis 1 -h 20;
			setParent ..;
		setParent ..;
		frameLayout -lv 1 -label "Revision Notes" -borderStyle "out" abxShotsStatusNoteFrmeLyt;
			columnLayout -h 60 -adj 1 -cal "left" -cat "both" 3 -rs 3;
				text -label "Describe what you changed:";
				scrollField -h 80 -wordWrap true -text "" -editable true -ec $cmd abxShotsStatusNotesField;
			setParent..;
		setParent $form;
		button -h 40 -label ("Update Status and Notes") -c $cmd abxShotsStatWinOKBtn;
		button -h 40 -label "Cancel" -c "layoutDialog -dismiss \"Cancel\"" abxShotsStatWinCBtn;

		formLayout -e 

			-af abxShotsStatusFrmeLyt "left" 3
			-af abxShotsStatusFrmeLyt "top" 3 
			-an abxShotsStatusFrmeLyt "bottom"
			-af abxShotsStatusFrmeLyt "right" 3

			-af abxShotsStatusNoteFrmeLyt "left" 3
			-ac abxShotsStatusNoteFrmeLyt "top" 3 abxShotsStatusFrmeLyt
			-af abxShotsStatusNoteFrmeLyt "bottom" 55
			-af abxShotsStatusNoteFrmeLyt "right" 3

			-af abxShotsStatWinOKBtn "left" 0
			-an abxShotsStatWinOKBtn  "top" 
			-af abxShotsStatWinOKBtn "bottom" 3
			-ap abxShotsStatWinOKBtn "right" 3 50

			-ap abxShotsStatWinCBtn "left" 0 50
			-an abxShotsStatWinCBtn  "top" 
			-af abxShotsStatWinCBtn "bottom" 3
			-af abxShotsStatWinCBtn "right"  3

			$form;

	if ($deptName != "anm")
		rowLayout -e -enable 0 abxShotsStatWinStageLyt;

	if ($mode == 1 || $mode == 2){
		button -e -vis 0 abxShotsStatWinCBtn;
		formLayout -e -ap abxShotsStatWinOKBtn "right" 3 100 $form;
	}

	if ($mode == 2){
		scrollField -e -text (`getenv USERNAME`+" is too lazy to leave a useful note.") abxShotsStatusNotesField;
		button -e -label ("Last Chance To Leave a Note") abxShotsStatWinOKBtn;
	}
	// set the slider to the current status
	
	string $shotDetails[] = `abxShotsGetShotDetails $shotName $shotFolder`;
	if (size($shotDetails) > 4){
		//print $shotDetails;
		if ($deptName == "pre"){
			if ($shotDetails[5] != "") {
				int $val = int($shotDetails[5]);
				intSlider -e -v $val abxShotsStatusWindowSlider;
			}
		}
		else if ($deptName == "anm"){
			if ($shotDetails[6] != "") {
				string $anmStatBuff[];
				tokenize $shotDetails[6] "," $anmStatBuff;
				int $val = int($anmStatBuff[0]);
				intSlider -e -v $val abxShotsStatusWindowSlider;
				$val = int($anmStatBuff[1]);
				intSlider -e -v $val abxShotsStatusWindowStageSlider;
			}
		}
		else if ($deptName == "fx"){
			if ($shotDetails[7] != "") {
				int $val = int($shotDetails[7]);
				intSlider -e -v $val abxShotsStatusWindowSlider;
			}
		}
		else if ($deptName == "lgt"){
			if ($shotDetails[8] != "") {
				int $val = int($shotDetails[8]);
				intSlider -e -v $val abxShotsStatusWindowSlider;
			}
		}
		else if ($deptName == "cmp"){
			if ($shotDetails[9] != "") {
				int $val = int($shotDetails[9]);
				intSlider -e -v $val abxShotsStatusWindowSlider;
			}
		}
	}
}

global proc string abxShotsStatusWindowShowUI (string $shotName, string $shotFolder, string $deptName, int $mode){

	string $result = "";
	$result = `layoutDialog -title ($shotName+" Status Update and Notes") -ui ("statusPrompt(\""+$shotName+"\",\""+$shotFolder+"\",\""+$deptName+"\","+$mode+")")`;
	
	if ($result != "Cancel" && $result != "dismiss") {
		string $tokenBuffer[];
		tokenize $result "|" $tokenBuffer;
		int $status =  $tokenBuffer[0];
		int $stage = $tokenBuffer[1];
		$note = $tokenBuffer[2];
		abxShotsStatusWindowSetStatus $shotName $shotFolder $deptName $mode $status $stage $note;
		print ("///\n/// LOADING STATUS UPDATE\n\n\n\n");
		evalDeferred -lp ("abxShotsLoadHUDStatus \"\";");
		return $note;
	}
	else {
		return "";
	}
}

// mode=0: ignore the status
global proc abxShotsStatusWindowSetStatus (string $shotName, string $shotFolder, string $deptName, int $mode, int $status, int $stage, string $note){

	string $updateWhat;

	string $listControl;
	if ($shotFolder == "_ALL_SHOTS")
		$listControl = "abxShotsList";
	else if ($shotFolder == "_PREVIS")
		$listControl = "abxPrevisList";

	//int $status = `intSlider -q -value abxShotsStatusWindowSlider`;
	//int $stage = `intSlider -q -value abxShotsStatusWindowStageSlider`;
	string $color = `abxShotsStatAsColor $status`;
	string $label = `abxShotsStageAsLabel $stage`;
	string $setColorCmd = ("treeView -e ");
	$setColorCmd += ("-btc \""+$shotName+"\" ");

	switch ($deptName){
		case "pre":
			$updateWhat = "pre status";
			$setColorCmd += "1";
			break;
		case "anm":
			$updateWhat = "anm status";
			$setColorCmd += "1";

			break;
		case "fx":
			$updateWhat = "fx status";
			$setColorCmd += "2";
			break;
		case "lgt":
			$updateWhat = "lgt status";
			$setColorCmd += "3";
			break;
		case "cmp":
			$updateWhat = "cmp status";
			$setColorCmd += "4";
			break;
	}
	$setColorCmd += (" "+$color+" ");

	// if its anm status update then apply the stage label as well
	if ($deptName == "anm")
		$setColorCmd += ("-i \""+$shotName+"\" 1 \""+$label+"\" ");
	
	$setColorCmd += $listControl;
	if (`treeView -exists $listControl`)
		evalEcho $setColorCmd;	


	string $updateValue = $status;
	if ($deptName == "anm")
		$updateValue = ($status+","+$stage);

	// get the UI value and set the details
	evalEcho ("abxShotsUpdateDetailsFromScene \""+$shotName+"\" \""+$shotFolder+"\" \""+$updateWhat+"\" \""+$updateValue+"\" ");

	// log the status change
	if ($mode == 0){
		$note = (abxShotsStatAsLabel($status)+": "+$note);
		evalEcho("abxShotsWriteShotLog \""+$shotFolder+"\" \""+$shotName+"\" \""+$updateWhat+"\" \"---\" \"---\" \""+$note+"\"");
	}

	string $filePath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName);
	print ("FilePath="+$filePath+"   shotName="+$shotName+"\n");
	// edit the shot details on the server database
	//pprainbow();
	//int $dbExists = python("import rainbow.utils as U; U.checkDB();");

	global int $dbExists;
	print ($filePath+"\n");
	string $cmd = "";
	//// set the shot to inactive if anm is dead
	//if ($deptName == "anm" && $status == -2){
	//	print ("MARKING SHOT AS INACTIV\n\n");
	//	$cmd += ("R.Shot.getFromPath('"+$filePath+"').is_active = False;");
	//}
	$cmd += ("R.Shot.getFromPath('"+$filePath+"').save();");
	print ($cmd+"\n");

	if ($dbExists == true && $shotFolder != "_PREVIS"){
		$fail = catch(python($cmd));
	}
}

global proc string abxShotsStatAsColor (int $status){
	string $strStatus = $status;
	string $result = "";
	
	switch ($strStatus){
		case "-3":
			$result = ".4 .5 .7";
			break;
		case "-2":
			$result = ".10 .10 .10";
			break;
		case "-1":
			$result = ".2 .4 .7";
			break;
		case "0":
			$result = ".4 .4 .4";
			break;
		case "1":
			$result = ".7 .3 .3"; //179 77 77
			break;
		case "2":
			$result = ".7 .5 .3";
			break;
		case "3":
			$result = ".9 .85 .34"; // 230 217 87
			break;
		case "4":
			$result = ".3 .7 .4";
			break;
		case "5":
			$result = ".15 .83 .77"; //38 212 197
			break;
		}
	return $result;
}

global proc string abxShotsStageAsLabel(int $stage){
	string $strStage = $stage;
	string $result = "";
	string $ppTools = `getenv MAYA_PPTOOLS`;
	
	switch ($strStage){
		case "0":
			$result = ($ppTools+"/icons/stat1.png"); // Blocking
			break;
		case "1":
			$result = ($ppTools+"/icons/stat2.png"); // Splining
			break;
		case "2":
			$result = ($ppTools+"/icons/stat3.png"); // Polish
			break;
	}
	return $result;
}

global proc string abxShotsStatAsLabel(int $status){
	string $strStatus = $status;
	string $result = "";
	
	switch ($strStatus){
		case "-3":
			$result = "On Hold";
			break;
		case "-2":
			$result = "Dead";
			break;
		case "-1":
			$result = "Ready To Start";
			break;
		case "0":
			$result = "Wait"; //".27 .27 .27";
			break;
		case "1":
			$result = "Changes Needed";
			break;
		case "2":
			$result = "Work In Progress";
			break;
		case "3":
			$result = "Work Completed";
			break;
		case "4":
			$result = "Internal Approved";
			break;
		case "5":
			$result = "Client Approved";
			break;
		}
	return $result;
}

global proc int abxShotsTreeViewButtonA (string $shotName, int $state){
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	abxShotsStatusWindowShowUI $shotName $shotFolder "anm" 0;

	return 1;
}
global proc int abxShotsTreeViewButtonF (string $shotName, int $state){
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	abxShotsStatusWindowShowUI $shotName $shotFolder "fx" 0;
	return 1;
}
global proc int abxShotsTreeViewButtonL (string $shotName, int $state){
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	abxShotsStatusWindowShowUI $shotName $shotFolder "lgt" 0;
	return 1;
}
global proc int abxShotsTreeViewButtonC (string $shotName, int $state){
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	abxShotsStatusWindowShowUI $shotName $shotFolder "cmp" 0;

	return 1;
}

global proc abxShotsSetShotFrameRange (string $shotName){

	string $shotFolder = `abxShotsGetActiveShotFolder`;
	// prompt the user
	string $result = `layoutDialog -title ("Shot Manager: "+$shotName+" Frame Range") -ui "frangePrompt"`;
	if ($result != "Cancel"){
		string $tokenBuffer[];
		tokenize $result "-" $tokenBuffer;
		if (size ($tokenBuffer) == 2){
			abxShotsSetFrameRange($shotFolder,$shotName,$tokenBuffer[0],$tokenBuffer[1]);
		}
	}
}

global proc abxShotsSetFrameRange(string $shotFolder, string $shotName, int $start, int $end){

	string $filePath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName);
	// edit the shot details on the server database
	//pprainbow();
	// ignore saving previs shots to database frame ranges
	if ($shotFolder != "_PREVIS"){
		global int $dbExists;
		print ($filePath+"\n");
		string $cmd = ("R.Shot.getFromPath('"+$filePath+"').set({'startframe':"+""+$start+",'endframe':"+$end+"})");
		print ($cmd+"\n");
		if ($dbExists == true){
			$fail = catch(python($cmd));
		}
	}
	
	// edit the local shot details text file as well
	abxShotsUpdateDetail ($shotName, $shotFolder, "frameRange", ($start+"-"+$end));

	// add to the log file
	abxShotsWriteShotLog ($shotFolder, $shotName, "---", "---", "---", ("Frame range set to "+$start+"-"+$end));

	evalDeferred("abxShotsRefreshDetailsUI \""+$shotName+"\"");
}

global proc frangePrompt()
{
    // Get the dialog's formLayout.
    string $form = `setParent -q`;

    int $start = `textField -q -text abxShotsDtlRangeS`;
    int $end = `textField -q -text abxShotsDtlRangeE`;

    formLayout -e -width 300 $form;

    string $t = `floatFieldGrp -en1 1 -en2 1 -cw 1 80 -cw 2 100 -cw 3 100 -nf 2 -label "Start/End:" -v1 $start -v2 $end frangeEditFFG`;

    string $b1 = `button -l "OK"    -c "string $frResult =(`floatFieldGrp -q -v1 frangeEditFFG`+\"-\"+`floatFieldGrp -q -v2 frangeEditFFG`);layoutDialog -dismiss $frResult;"`;
    string $b2 = `button -l "Cancel"     -c "layoutDialog -dismiss \"Cancel\""`;


    int $spacer = 5;
    int $top = 5;
    int $edge = 5;

    formLayout -edit
        -attachForm            $t   "top"    ($top+10)
        -attachForm            $t   "left"   $edge
        -attachNone            $t   "bottom"
        -attachForm            $t   "right"  $edge

        -attachOppositeForm    $b1  "top" (-25-$spacer)
        -attachForm            $b1  "left"   $edge
        -attachNone            $b1  "bottom"
        -attachPosition        $b1  "right"  $spacer 50

        -attachOppositeForm    $b2  "top"    (-25-$spacer)
        -attachPosition        $b2  "left"   $spacer 50
        -attachNone            $b2  "bottom"
        -attachForm            $b2  "right" $edge

    $form;
}

global proc string[] abxShotsGetShotLog(string $shotName, string $shotsFolder){

	string $shotFileName = `abxShotsGetShortName $shotName`;
	string $result[];
	string $logFile = (`workspace -q -rd`+"scenes/"+$shotsFolder+"/"+$shotName+"/"+$shotFileName+"_log.txt");
	
	if (`filetest -f ($logFile)`){
		 $fileId=`fopen $logFile "r"`;
			string $nextLine = `fgetline $fileId`;
			$result[size($result)] = $nextLine;
			while ( size( $nextLine ) > 0 ) {
				//print ( $nextLine );
				$nextLine = `fgetline $fileId`;
				$result[size($result)] = $nextLine;
			}
 		fclose $fileId;
		return $result;
	}
	else{
		//print ($logFile+" File not Found. Ignoring.\n");
		return {""};
	}
}

// checks for vray attributes for subdivision settings
global proc abxShotsVraySubDCheck (){
	string $meshes[] = `ls -type mesh`;

	for ($each in $meshes){
		if (!`attributeExists "vraySubdivEnable" $each`){
			addAttr -longName "vraySubdivEnable" -at "long" $each;
			setAttr ($each+".vraySubdivEnable") 1;
		}
		if (!`attributeExists "vraySubdivUVsAtBorders" $each`){
			addAttr -longName "vraySubdivUVsAtBorders" -at "long" $each;
			setAttr ($each+".vraySubdivUVsAtBorders") 1;
		}
		if (!`attributeExists "vraySubdivUVs" $each`){
			addAttr -longName "vraySubdivUVs" -at "long" $each;
			setAttr ($each+".vraySubdivUVs") 1;
		}
		if (!`attributeExists "vrayStaticSubdiv" $each`){
			addAttr -longName "vrayStaticSubdiv" -at "long" $each;
			setAttr ($each+".vrayStaticSubdiv") 0-9;
		}
		if (!`attributeExists "vrayOverrideGlobalSubQual" $each`){
			addAttr -longName "vrayOverrideGlobalSubQual" -at "long" $each;
			setAttr ($each+".vrayOverrideGlobalSubQual") 1;
		}
		if (!`attributeExists "vrayViewDep" $each`){
			addAttr -longName "vrayViewDep" -at "long" $each;
			setAttr ($each+".vrayViewDep") 1;
		}
		if (!`attributeExists "vrayEdgeLength" $each`){
			addAttr -longName "vrayEdgeLength" -at "float" $each;
			setAttr ($each+".vrayEdgeLength") 4.0;
		}
		if (!`attributeExists "vrayMaxSubdivs" $each`){
			addAttr -longName "vrayMaxSubdivs" -at "long" $each;
			setAttr ($each+".vrayMaxSubdivs") 3;
		}
	}
}
global proc abxShotsRestoreDeformedShader (string $refNodes[], int $force){

	// set to the default render layer before processing
	editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;

	string $foundDeformed[];

	if (size($refNodes) == 0)
		$refNodes = `file -q -r`;

	for ($each in $refNodes){
		string $refNodeName = `referenceQuery -rfn $each`;
		string $namespace = `file -q -namespace $each`;
		string $editCommands[] = `referenceQuery -failedEdits false -successfulEdits true -editStrings $each`;
		for ($every in $editCommands){
			print ("// Checking Edit Command "+$every+"\n");
			// if its a geo and a parent command then its probably a deformed shape
			if (`gmatch $every "*geo_*"` && `gmatch $every "parent -s -r*"`){
				// if its an instance ignore it as a potential suspect
				if (!`gmatch $every "parent -s -r -add *"`){
				print ("GeoEdit:"+$every+"\n");
					string $tokenBuffer[];
					tokenize $every " " $tokenBuffer;
					string $editCmd = $tokenBuffer[0];
					string $editTarget = "";
					string $editSource = "";
					if ($editCmd == "parent"){
						print ($every+"\n");
						// shading engine (sg) name

						$editTarget = $tokenBuffer[4];
						$editSource = $tokenBuffer[3];

						if ($editTarget != ""){
							
							print ("editTarget="+$editTarget+"\n");
							// if the target is not referenced object but a deformed shape add it to the list of found deformed
							if (size(`ls -rn $editSource`) == 0)
								print ("// adding Edit String To Array\n");
								$foundDeformed[size($foundDeformed)] = $editTarget;
								//print ("// done Edit String To Array\n");
						}
					}
				}

				//if (`gmatch $every "*instObjGroup*"`){
				//	$rnToClean[size($rnToClean)] = $refNodeName;
				//
				//	break;
				//}
			}
		}
	}

	if (size($foundDeformed)>0){
		print ("Found Deformed\n");
		print $foundDeformed;
	}

	// parse through the found deformed and make it assign the intermediate
	for ($each in $foundDeformed){
		if (`objExists $each`){
			string $cmd = ("listRelatives -shapes -fullPath "+$each);
			$childrenShapes = eval($cmd);
			if (size($childrenShapes) > 1){
				// find the shape that has a reference edit that turns it into an intermediate object and use this as the source of the shader assignment
				string $shapeTurnedIntermediate = "";
				for ($every in $childrenShapes){
					if (`referenceQuery -inr $every`){
						string $editStrings[] = `referenceQuery -editStrings $every`;
						string $es;
						for ($es in $editStrings){
							if (`gmatch $es "*intermediate*"`){
								$shapeTurnedIntermediate  = $every;
							}
						}
					}
				}
				// if there was an instanced geo turned intermediate get its shader and assign it to the other shape nodes
				if ($shapeTurnedIntermediate != ""){
					string $shadingGroups[] = `listConnections -s 1 ($shapeTurnedIntermediate+".instObjGroups[0]")`;
					if (size($shadingGroups) > 0){
						for ($i=1;$i<size($childrenShapes);$i++){
							if (!`referenceQuery -inr $childrenShapes[$i]`){
								evalEcho("sets -e -forceElement "+$shadingGroups[0]+" "+$childrenShapes[$i]);
							}
						}
					}
				}
			}
		}
	}
}

/*
global proc abxShotsRestoreDeformedShader (){

	$selectedGeo = `ls -rn -r 1 -long "geo_*"`;

	for ($each in $selectedGeo){
		$childrenShapes = `listRelatives -shapes -fullPath $each`;
		if (size($childrenShapes) > 1){
			// find the shape that has a reference edit that turns it into an intermediate object and use this as the source of the shader assignment
			string $shapeTurnedIntermediate = "";
			for ($every in $childrenShapes){
				string $editStrings[] = `referenceQuery -editStrings $every`;
				string $es;
				for ($es in $editStrings){
					if (`gmatch $es "*intermediate*"`){
						$shapeTurnedIntermediate  = $every;
					}
				}
			}
			// if there was an instanced geo turned intermediate get its shader and assign it to the other shape nodes
			if ($shapeTurnedIntermediate != ""){
				string $shadingGroups[] = `listConnections -s 1 ($shapeTurnedIntermediate+".instObjGroups[0]")`;
				if (size($shadingGroups) > 0){
					for ($i=1;$i<size($childrenShapes);$i++){
						evalEcho("sets -e -forceElement "+$shadingGroups[0]+" "+$childrenShapes[$i]);
					}
				}
			}
		}
	}
}
*/

global proc abxShotsRemoveGeoEdits (int $force){

	// set to the default render layer before processing
	editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;

	string $rnToClean[];
	string $editStringsRefNode[];
	string $editStrings[];


	//string $restoreInitialSG[];

	string $refNodes[] = `file -q -r`;
	for ($each in $refNodes){
		//print ("Testing RefNode:"+$each+"\n");
		string $refNodeName = `referenceQuery -rfn $each`;
		string $namespace = `file -q -namespace $each`;
		//string $editCommands[] = evalEcho("referenceQuery -editStrings \""+$each+"\"");
		string $editCommands[] = `referenceQuery -editStrings $refNodeName`;
		for ($every in $editCommands){
			if (`gmatch $every "*geo_*"` && `gmatch $every "*instObjGroups*"`){
				print ("GeoEdit:"+$every+"\n");
				string $tokenBuffer[];
				tokenize $every " " $tokenBuffer;
				string $editCmd = $tokenBuffer[0];
				string $editTarget = "";
				string $editSource = "";
				if ($editCmd == "connectAttr"){
					// shading engine (sg) name
					$editTarget = $tokenBuffer[2];
					$editSource = $tokenBuffer[1];
				}
				else if ($editCmd == "disconnectAttr"){
					// shading engine (sg) name
					$editTarget = $tokenBuffer[3];
					$editSource = $tokenBuffer[2];
				}

				if ($editTarget != ""){
					//print ("editTarget:"+$editTarget+"\n");
					// the connection is to a shader and it is a reference node
					string $tokenBuffer2[];
					tokenize $editTarget "." $tokenBuffer2;
					string $targetNodeOnly = ($tokenBuffer2[0]+"\"");
					string $testCmd = ("size(`ls -type shadingEngine "+$targetNodeOnly+"`)");
					//print ("testCmd:"+$testCmd+"\n");
					string $testReadOnly = ("size(`ls -rn "+$editSource+"`)");
					//print ("testReadOnly:"+$testReadOnly+"\n");
					if (eval($testCmd) > 0 && eval($testReadOnly) > 0){
						print ("Shader Override:"+$every+"\n");
						$editStringsRefNode[size($editStringsRefNode)] = $refNodeName;
						$editStrings[size($editStrings)] = $every;
						$rnToClean[size($rnToClean)] = $refNodeName;
					}
				}
				//if (`gmatch $every "*instObjGroup*"`){
				//	$rnToClean[size($rnToClean)] = $refNodeName;
				//
				//	break;
				//}
			}
		}
	}
	//print ("// Found Override Edit Strings // \n");
	//print $editStrings;
	//print ("// End Found Override Edit Strings // \n");

	if (size($editStringsRefNode)>0){
		string $result = "Remove Shading Overrides";
		if (!$force){
			$result = `confirmDialog -title "Shot Manager: Master" -message ("There appears to be shader overrides on the reference "+$editStringsRefNode[0]) -button "Remove Shading Overrides" -button "Ignore" -button "Cancel" -defaultButton "Remove Shading Overrides" -cancelButton "Cancel" -dismissString "Cancel"`;
		}
		if ($result == "Remove Shading Overrides"){

			// unload all the references that need editng
			for ($i=0;$i<size($editStringsRefNode);$i++){	
				string $each = $editStringsRefNode[$i];
				
				print ($each+"\n");
				int $initialRefLoadState = `file -rfn $each -q -deferReference`;

				if ($initialRefLoadState == 0){
					file -unloadReference $each;
				}
			}

				//string $editCommands[] = `referenceQuery -editStrings $each`;		

			for ($every in $editStrings){
				//`gmatch $each "*ShadingGroup*"` `gmatch $each "*SG*"`
				// if it is a SG edit then...
				if (`gmatch $every "*geo_*"`){
					// parse out strings to get edit destination
					string $tokenBuffer[];
					tokenize $every "\"" $tokenBuffer;
					if (size($tokenBuffer) > 1){
						string $editCmdTokenBuffer[];
						tokenize $tokenBuffer[0] " " $editCmdTokenBuffer;
						string $editCommand = $editCmdTokenBuffer[0];
						string $destination = $tokenBuffer[1];
						if ($destination !="" && `gmatch $every "*visibility*"` == 0 && `gmatch $every "*instObjGroup*"` == 1){
							print ("referenceEdit -failedEdits true -successfulEdits true -editCommand "+$editCommand+" -removeEdits "+$destination+"\n");
							referenceEdit -failedEdits true -successfulEdits true -editCommand $editCommand -removeEdits $destination;
						}
					}
				}
			}

			for ($i=0;$i<size($editStringsRefNode);$i++){	
				string $each = $editStringsRefNode[$i];
				int $initialRefLoadState = `file -rfn $each -q -deferReference`;
				if ($initialRefLoadState == 1){	
					
					file -loadReference $each;
				}
			}

			// if initial shading group assignments were overridden we must manually restore the connections
			//for ($every in $restoreInitialSG){
			//	print ("sets -forceElement \"initialShadingGroup\" "+$every+";\n");
			//	if (`objExists $every`)
			//		sets -forceElement "initialShadingGroup" $every;
			//}
			
		}
		else if ($result == "Ignore"){

		}
		else {

			error ("User Aborted Master due to Shader Overrides.");
		}
	}
}



// opens a standard maya file open browser at the shot work path
global proc abxShotsOpenOtherFile(string $shotName){

	string $shotFolder = `abxShotsGetActiveShotFolder`;
	if ($shotName == ""){
		string $selItems[];
		if ($shotFolder == "_ALL_SHOTS")
			$selItems = `treeView -q -si abxShotsList`;
		else if ($shotFolder == "_PREVIS")
			$selItems = `treeView -q -si abxPrevisList`;
		$shotName = $selItems[0];
	}

	string $dept = `abxShotsGetActiveDeptTab`;
	$dept = toupper($dept);
	string $browserPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName+"/"+$dept+"/work/");
	print ("browserPath ="+$browserPath+"\n");
	string $file[] = `fileDialog2 -fileFilter "Maya Files (*.ma *.mb);;Maya ASCII (*.ma);;Maya Binary (*.mb);;All Files (*.*)" -caption "Open" -fileMode 1 -dir $browserPath`;
	//$file[0] = `workspace -en $file[0]`;
	if (`filetest -r $file[0]`){
		print ($file[0]+"\n");
		saveChanges("abxLockFileCheckOut(\"\");file -f -o \""+$file[0]+"\";abxLockFileCheckIn(\""+$file[0]+"\");");
	}
		
}

global proc abxShotsImportOtherFile(string $shotName){
	string $shotFolder;
	string $browserPath = `workspace -q -rd`;
	if (`window -exists abxShotsWindow`){
		$shotFolder = `abxShotsGetActiveShotFolder`;
		if ($shotName == ""){
			string $selItems[];
			if ($shotFolder == "_ALL_SHOTS")
				$selItems = `treeView -q -si abxShotsList`;
			else if ($shotFolder == "_PREVIS")
				$selItems = `treeView -q -si abxPrevisList`;
			$shotName = $selItems[0];
		}
		string $dept = `abxShotsGetActiveDeptTab`;
		$dept = toupper($dept);
		$browserPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName+"/"+$dept+"/work/");

	}

	print ("browserPath ="+$browserPath+"\n");
	string $file[] = `fileDialog2 -fileFilter "Maya Files (*.ma *.mb);;Maya ASCII (*.ma);;Maya Binary (*.mb);;All Files (*.*)" -caption "Open" -fileMode 1 -dir $browserPath`;
	//$file[0] = `workspace -en $file[0]`;
	if (`filetest -r $file[0]`){
		print ($file[0]+"\n");
		abxShotsImportScene($file[0],"CLASH","rename");
	}
		
}

// checks reference paths to make sure they point to _publish file
// also check the proxy rigs are swapped to regular rigs
global proc abxShotsCheckRefPaths (){
	string $refFiles[] = `file -q -r`;
	string $each;
	for ($each in $refFiles){
		string $refNode = `referenceQuery -rfn $each`;
		
		if (`referenceQuery -isLoaded $each`){
			$filepath = `referenceQuery -f -wcn $refNode`;
			$ext = `fileExtension $filepath`;
			$basename = `basenameEx $filepath`;
			$dirname = `dirname $filepath`;		
			
			
			// correct any proxies to be the full res asset
			if (`gmatch $basename "*_proxy.mb"`){
			    print ("Proxy found, switching to non proxy\n");
			    int $strSize = size($basename) - 9;
			    string $nonProxyBasename = `substring $basename 1 $strSize`;
			    file -e -loadReference ($dirname+"/"+$nonProxyBasename) $refNode;
			}

			string $tokenBuffer[];
			tokenize $dirname "/" $tokenBuffer;
			if ($tokenBuffer[size($tokenBuffer)-1] != "_publish"){
			    string $assetLib = (`workspace -q -rd`+"assets");
			    string $tokenBuffer2[];
			    tokenize $assetLib "/" $tokenBuffer2;
            
                print ("dirname="+$dirname+" assetLib="+$assetLib+"\n");
				if (`gmatch $dirname ($assetLib+"*")`){
					$assetTypeGuess = $tokenBuffer[size($tokenBuffer2)];
					$assetNameGuess = $tokenBuffer[size($tokenBuffer2)+1];
					string $correctPath = ($assetLib+"/"+$assetTypeGuess+"/"+$assetNameGuess+"/_publish/"+$assetNameGuess+".mb");
					print ("Found Non-standard Reference="+$each+"\n");
					print ("correctPath="+$correctPath+"\n");
				}
			}
		}
	}
	


}

global proc abxShotsProxyToFull (){
	string $refFiles[] = `file -q -r`;
	string $each;
	for ($each in $refFiles){
		string $refNode = `referenceQuery -rfn $each`;
		print ($refNode+"\n");
		
		if (`referenceQuery -isLoaded $each`){
			string $filepath = `referenceQuery -f -wcn $refNode`;
			string $ext = `fileExtension $filepath`;
			string $basename = `basenameEx $filepath`;
			string $dirname = `dirname $filepath`;		
			
			//print ("basename="+$basename+" dirname="+$dirname+"\n");
			// correct any proxies to be the full res asset
			if (`gmatch $basename "*_proxy"`){
			    print ("Proxy found, switching to non proxy\n");
			    int $strSize = size($basename) - 6;
			    string $nonProxyBasename = `substring $basename 1 $strSize`;
			    if (`filetest -r ($dirname+"/"+$nonProxyBasename+"."+$ext)`)
			        file -loadReference $refNode ($dirname+"/"+$nonProxyBasename+"."+$ext) ;
			    else
			        warning ("Could not load non-proxy ref:"+$dirname+"/"+$nonProxyBasename+"."+$ext+" on ref node:"+$refNode);
			}
		}
	}
}

global proc abxShotsClearFailedEdits (){
		string $refNodes[] = `file -q -r`;
		for ($each in $refNodes){
			string $refNodeName = `referenceQuery -rfn $each`;
			referenceEdit -failedEdits true -successfulEdits false -removeEdits $refNodeName;
		}
}

// parses through a scene and removes nested namespaces
// renames reference namespaces if necessary
global proc abxShotsRemoveNestedNamespaces (){

	string $assets[] = abxAssetsGetAssetsInScene();
	string $allnamespaces[] = `namespaceInfo -lon -r`; 
	
		string $refNodes[] = `ls -sl`;
		int $number = 1;
		for ($each in $refNodes){
			string $refNodeName = `referenceQuery -rfn $each`;
			string $refFile = `referenceQuery -filename $refNodeName`;
			string $namespace = `file -q -namespace $refNodeName`;
			//stringArrayContains ($allnamespaces "")
			file -e -namespace ("WarMachineRobot"+$number) $refFile ;
			$number++;
			//referenceEdit -failedEdits true -successfulEdits false -removeEdits $refNodeName;
		}
}




// searches the open scene for splitToTake_<takeName> sets and it export to those take names
global proc abxShotsSplitToTake (string $shotFolder, string $shotName){

	$shotFolder = `abxShotsGetActiveShotFolder`;

	string $shotSequence = "";
	string $sceneFileName = "";
	string $shotNameGuess = "";
	string $shotTakeGuess = "";
	string $subDeptGuess = "";
	string $deptGuess = "";
	string $shotFolderGuess = "";
	string $shotsFolder = "";//"scenes/"+$shotFolder+"/";

	$shotFileName = `abxShotsGetShortName $shotName`;

	// get the scene name
	string $currentScene = `file -q -sn`;
	string $extension = `fileExtension $currentScene`;
	string $currentSceneName = `basenameEx $currentScene`;

	// tokenize the scene name for automatic incremental save
	string $tokenBuffer[];
	tokenize $currentScene "/" $tokenBuffer;

	$sceneFileName = $tokenBuffer[size($tokenBuffer)-1];

	int $latestFoundVersion = -1;

	// collects audio files that are not in the local server
	

	// assume this path <workspace>/scenes/<shotFolder>/<shotName>/<dept>/<take><version>
	// tokenize backwards through the current scene path to guess details about the file

	if (size($tokenBuffer) > 1){
		$subDeptGuess = $tokenBuffer[size($tokenBuffer)-2];
		if (size($tokenBuffer) > 2 ) {
			$deptGuess = tolower($tokenBuffer[size($tokenBuffer)-3]);
			if (size($tokenBuffer) > 3 ) {
				$shotNameGuess = $tokenBuffer[size($tokenBuffer)-4];
				if (size($tokenBuffer) > 4){
					if ($tokenBuffer[size($tokenBuffer)-5] != "_ALL_SHOTS" && $tokenBuffer[size($tokenBuffer)-5] != "_PREVIS"){
						$shotSequence = $tokenBuffer[size($tokenBuffer)-5];
						if (size($tokenBuffer) > 5){
							if ($tokenBuffer[size($tokenBuffer)-6] == "_ALL_SHOTS" || $tokenBuffer[size($tokenBuffer)-6] == "_PREVIS"){
								$shotFolderGuess = $tokenBuffer[size($tokenBuffer)-6];
								$shotsFolder = ("scenes/"+$tokenBuffer[size($tokenBuffer)-6]+"/");
							}
						}
					}
					else {
						$shotFolderGuess = $tokenBuffer[size($tokenBuffer)-5];
						$shotsFolder = ("scenes/"+$tokenBuffer[size($tokenBuffer)-5]+"/");
					}
				}
			}
		}
	}
	if ($shotsFolder == ""){
		//if (!$force)
			//$result = `confirmDialog -title "Shot Manager: Split To Take" -message "Could Not Guess what shot this file belongs to from the file path" -button "Ok" -defaultButton "Ok" -dismissString "Ok"`;
		//return;
	}

	if ($shotName == "auto"){
		//ls -type objectSet

	}


}

global proc abxShotsSetFrameRate (float $targetFPS){
	float $startFrame = `playbackOptions -q -min`;
	int $moveKeys = false;
	int $moveRange = false;
	int $snapKeys = false;
	int $snapRange = false;
	string $ppTools = `getenv MAYA_PPTOOLS`;

	eval("source \""+$ppTools+"/scripts/Toolbox/Animation/abxFPS.mel\"");
	frameRateChangeProc ($targetFPS,$startFrame,$moveKeys,$moveRange,$snapKeys,$snapRange);

}

// these are autodesk predifined procedures that help maya know what to lock when referencing.
// these should be department specific 
// lighters:exclude lock on edit shadingNodes, transform visibility, shapeNodes, instObjGroup attributes
// animators: exclude lock on transforms

// if a reference is locked, we should prevent any shape nodes from being parented as well
global proc string[] getLockReferenceExcludedAttributes(){
	// Return a string array containing a list of attributes
	// to be skipped during locking of a referenced file. The
	// listed attributes locked state will remain the same as
	// in the referenced file.

	$lockReferenceExcludedAttributes = {
		"visibility",
		"renderLayerInfo",
		"clothes_switch",
		"animation_display",
		"locatorScale",
		"anim_display",
		"animation_display",
		"farClipPlane",
		"nearClipPlane",
		"renderable"};

	//$lockReferenceExcludedAttributes[2] = "instObjGroups";
	//$lockReferenceExcludedAttributes[3] = "objGroups";
	//$lockReferenceExcludedAttributes[4] = "dagSetMembers";

	return $lockReferenceExcludedAttributes;
}


global proc string[] getLockReferenceExcludedNodeTypes()
{
	global string $deptOpen;
	string $lockReferenceExcludedNodeTypes[];
	string $deptGuess = "";
	string $recentFileList[] = `optionVar -q "RecentFilesList"`;

	// tokenize the scene name for automatic incremental save
	// sometimes this isn't set when the load is called so we need another way to ID the file
	string $currentScene = `file -q -sn -shn`;
	if ($currentScene == "")
		$deptGuess = $deptOpen;
		//$currentScene = basenameEx($recentFileList[size($recentFileList)-1]);
	print ("currentScene="+$currentScene+"\n");
	print ("deptOpen="+$deptOpen+"\n");
	string $tokenBuffer[];
	tokenize $currentScene "_" $tokenBuffer;


	// assume file name convention "seq_shot_dept_version.ma" or "seq_shot_dept_take_version.ma"
	if (size($tokenBuffer) == 4){
		$deptGuess = tolower($tokenBuffer[size($tokenBuffer)-2]);
	}
	else if (size($tokenBuffer) == 5){
		$deptGuess = tolower($tokenBuffer[size($tokenBuffer)-3]);
	}
	print ("deptGuess="+$deptGuess+"\n");

	if ($deptGuess == "lgt" || $deptGuess == ""){
		// Return a string array containing a list of node types 
		// whose attributes should be skipped during locking of a 
		// referenced file.
		print ("Locking Lighting Specific Nodes/Attributes\n");		
		$explicits = {
			"lightLinker",
			"displayLayerManager",
			"displayLayer",
			"renderLayerManager",
			"renderLayer",
			"set",
			"shadingEngine",
			"mesh",	
			"nurbsSurface",	
			"shaveHair",
			"shaveGlobals",
			"imagePlane",
			"joint",
			"nucleus",
			"nCloth",
			"aiAOV",
			"aiAOVDriver",
			"aiAOVFilter"
		};
		//$explicits[4] = "transform";
		$plusShaders = stringArrayCatenate($explicits, `listNodeTypes "shader"`);
		$plusTextures = stringArrayCatenate($plusShaders, `listNodeTypes "texture"`);
		$plusUtilities = stringArrayCatenate($plusTextures, `listNodeTypes "utility"`);
		$lockReferenceExcludedNodeTypes = $plusUtilities;
	}
	else if ($deptGuess == "anm" || $deptGuess == "pre"){
		print ("Locking Animation Specific Nodes/Attributes\n");
		string $explicits[] = {
			"displayLayerManager",
			"displayLayer",
			"renderLayerManager",
			"renderLayer",
			"set",
			"mesh",
			"nurbsSurface",
			"transform",
			"joint",
			"nucleus",
			"nCloth",
			"deformSine",
			"deformFlare",
			"deformBend",
			"deformTwist",
			"deformWave",
			"deformSquash",
			"cluster",
			"motionPath"
		};
		$plusTextures = stringArrayCatenate($explicits, `listNodeTypes "texture"`);
		$lockReferenceExcludedNodeTypes = $plusTextures;
		//$explicits[4] = "transform";		
	}
	return $lockReferenceExcludedNodeTypes;
}

/*
global proc int isShadingNode (string $node)  {
	string $nodeType = `nodeType $node`;
	if ($nodeType == "shadingEngine" || $nodeType == "container") return true;
	return (`getClassification -satisfies "shader" $nodeType` ||
			`getClassification -satisfies "texture" $nodeType` ||
			`getClassification -satisfies "utility" $nodeType` ||
			`getClassification -satisfies "light" $nodeType` ||
			`getClassification -satisfies "postprocess" $nodeType`);
}

// filter string array
global proc string[] onlyShadingNodes (string $list[])  {
	string $new[] = {};
	for ($l in $list)
		if (isShadingNode($l)) $new[size($new)] = $l;
	return $new;
}
*/

// removes any edits that have been made to a reference that isn't allowed via locked references
// this restores refs that were unlocked
global proc clearLockedRefEdits (){
    // remove any edits to objects with "Shape" in their name (horrible i know. needs to test object for type)
    editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;
    string $excludeEditRemoveAttributes[] = {"uvSet","instObjGroups","objectGroups","uvSetName","objectGroupId","scale", "rootThickness","rootSplay", "disableDynamics","enableCollision","stiffness","rootStiffness","dampening","blindShaveData"};

    $allowableMultiAttrTypes = { "double2", "double3", "double4", "float2", "float3", "float4", "short2", "short3", "long2", "long3", "stringArray", "doubleArray", "floatArray" };
    $allowableAttrTypes = {"float","long","double","short","int","bool","enum"};

    string $excludeNodes[] = getLockReferenceExcludedNodeTypes();
    string $excludeAttrs[] = getLockReferenceExcludedAttributes();


    // removes setAttr edits on any node found to be an intermediate object thats a shape node
    string $refNodes[] = `file -q -r`;
    for ($each in $refNodes){
    	print ("// Checking Ref "+$each+"\n");
        string $rmvEditCmds[];
        $isUnloaded = false;
        string $refNodeName = `referenceQuery -rfn $each`;
        string $namespace = `file -q -namespace $each`;
        string $editCommands[] = evalEcho("referenceQuery -failedEdits false -successfulEdits true -editNodes -editAttrs \""+$each+"\"");
        print ("// Ref Edit Query Successful "+$each+"\n");
        for ($every in $editCommands){

            string $tokenBuffer[];
            tokenize $every "." $tokenBuffer;

            print ("// "+$every+"\n");
        	string $nodeType = catch(eval("nodeType \""+$tokenBuffer[0]+"\""));
        	string $attrName = $tokenBuffer[1];
            
            if (!stringArrayContains($nodeType,$excludeNodes)){
            	if (size($tokenBuffer)>1){
		            if (!stringArrayContains($attrName,$excludeAttrs)){
	                    $rmvEditCmds[size($rmvEditCmds)] = ("referenceEdit -failedEdits false -successfulEdits true -removeEdits  \""+$every+"\"");
	                    print ("// Removing Edit on "+$every+"\n");
	                    //evalEcho("referenceEdit -failedEdits false -successfulEdits true -removeEdits  \""+$every+"\"");
	            	}
	        	}
        	}
        }
            
    
        
        // unload then remove the edits that have been marked for removal then reload the reference
        if ($isUnloaded == false){
            evalEcho("file -unloadReference \""+$refNodeName+"\"");
            $isUnloaded = true;
        }
        
        for ($every in $rmvEditCmds){
            evalEcho($every);
            //print ($every+"\n");
        }
        
        if ($isUnloaded == true){
            evalEcho("file -loadReference \""+$refNodeName+"\"");
        }
        
    }
}

global proc abxShotsSendNotification(string $target,string $targetPath,string $event,string $message, int $propagate) {
	global int $dbExists;

	// if db doesnt exist try one more time
	if ($dbExists == false){
		global int $dbExists = 0;
		$dbExists = pprainbow();
		global int $jobLoaded = 0;
		$jobLoaded = rain_loadJob("");
	}
	string $user = `getenv USERNAME`;
	string $cmd = "";
	if ($target == "Shot")
		$cmd = ("R.Shot.getFromPath('"+$targetPath+"').set({'message_text':'"+$message+"','message_event':'"+$event+"','message_sender':'"+$user+"','message_propagation':"+$propagate+"})");
	if ($target == "Sequence")
		$cmd = ("R.Sequence.getFromPath('"+$targetPath+"').set({'message_text':'"+$message+"','message_event':'"+$event+"','message_sender':'"+$user+"','message_propagation':"+$propagate+"})");
	if ($target == "Job")
		$cmd = ("R.Job.getFromPath('"+$targetPath+"').set({'message_text':'"+$message+"','message_event':'"+$event+"','message_sender':'"+$user+"','message_propagation':"+$propagate+"})");
	//if ($target == "User")
		//string $cmd = ("R.Shot.getFromPath('"+$targetPath+"').set({'message_text':'"+$message+"','message_event':'"+$event+"','message_sender':'"+$user+"'})");

	int $fail = 0;
	
	if ($dbExists == true){
		print ($cmd+"\n");
		if ($cmd != ""){
			print ("python(\""+$cmd+"\")\n");
			$fail = catch(python($cmd));
		}
	}

	if ($fail)
		confirmDialog -m "Notification Message Failed. Please contact your nearest TD" -button "OK";
	else
		confirmDialog -m "Notification Message Sent." -button "OK";

}

global proc abxShotsFixStoryNeonRefs(){
	string $refNodes[] = `file -q -r`;
	for ($each in $refNodes){
		$isUnloaded = false;
		string $refNodeName = `referenceQuery -rfn $each`;
		string $filePathWCN = `referenceQuery -filename -wcn $each`;
		string $namespace = `file -q -namespace $each`;
		if (`gmatch $each "N:*"`){
			string $regularExpr = "N:/STORY2012_PP10088/3D/story2012_maya";
			string $fixedPath = `substitute $regularExpr $filePathWCN "M:/STORY2012_PP10088/3D/STORY2012_maya"`;

			evalEcho("file -loadReference "+$refNodeName+" \""+$fixedPath+"\"") ;
		}
	}
}

// determines the time stamp on the default anm master and compares it to timestamp on the latest lighting scene
global proc int abxShotsFreshMaster (string $shotName){
	string $shotFolder = `abxShotsGetActiveShotFolder`;
	string $seqChildren[];
	string $dept = "";
	if ($shotFolder == "_PREVIS"){
		$dept = "pre";
	}
	else {
		$dept = "anm";
	}

	string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");

	string $shotFileName = `abxShotsGetShortName $shotName`;
	// get the latest anm master scene
	string $latestWorkVersion = abxShotsGetLatestWorkVersion($shotFolder, $shotName, "anm", "", "master",0);
	string $takeSceneName = ($shotFileName+"_anm_master_"+$latestWorkVersion+".mb");
	string $takeFullPath = ($shotsPath+$shotName+"/"+toupper($dept)+"/master/"+$takeSceneName);
	//string $masterCamFullPath = ($shotsPath+$shotName+"/CAM/master/"+$shotFileName+"_cam_master.ma");
	//print ($takeFullPath+"\n");

	// get the modified date of the file
	float $anmMasterStamp = 0;
	if ($takeFullPath != "") $anmMasterStamp = abxShotsGetMDateS($takeFullPath);

	// get the latest anm master scene
	string $latestWorkVersion = abxShotsGetLatestWorkVersion($shotFolder, $shotName, "lgt", "", "work",0);
	string $takeSceneName = ($shotFileName+"_lgt_"+$latestWorkVersion+".ma");
	string $takeFullPath = ($shotsPath+$shotName+"/"+toupper("lgt")+"/work/"+$takeSceneName);
	//string $masterCamFullPath = ($shotsPath+$shotName+"/CAM/master/"+$shotFileName+"_cam_master.ma");
	//print ($takeFullPath+"\n");

	// get the modified date
	float $lgtWorkStamp = -1;
	if ($takeFullPath != "")  $lgtWorkStamp = abxShotsGetMDateS($takeFullPath);
	if ($anmMasterStamp > $lgtWorkStamp)
		return 1;
	else
		return 0;
}


global proc abxShotsAddUserCheck (string $shotFolder, string $shotName, string $deptName){

	//// check for the database
	//global int $dbExists;
	//if ($dbExists){
	//	string $filePath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName);
	//	$fail = catch(python("activeShot = R.Shot.getFromPath('"+$filePath+"')"));
	//	if (!$fail){
	//		string $peopleList[] = python("activeShot.people");
	//		print ($peopleList);
	//	}
	//}
}

// retuns a path to the folder containing the latest cache
global proc string abxShotsGetLatestCache(string $filePath, string $simMode){

	string $sceneName = $filePath;
	string $sceneNameNoExt = `basenameEx $sceneName`;
	string $fileNameParts[] = stringToStringArray($sceneNameNoExt,"_");
	string $seqName = $fileNameParts[0];
	string $shotName = $fileNameParts[1];
	string $deptName = $fileNameParts[2];


	// if its a cloth cache mode
	if ($simMode == "clothSim"){

		// find the cache //////////////////////////

		$cacheRoot = (`workspace -q -rd`+"data/nClothSims/");
		$cachePrefix = ($seqName+"_"+$shotName+"_fx_"+$simMode);

		print ("Cache Filter: \""+$cacheRoot+$cachePrefix+"*\"\n");
		string $cacheFolders[] = `getFileList -fs ($cachePrefix+"*") -folder $cacheRoot`;
		//string $sorted[] = sort($cacheFolders);
		print ("// Possible Caches: \n");
		print $cacheFolders;
		print ("// END Possible Caches\n");

		// find which file has latest (must end with _v### )
		int $ver = 0;
		string $latestCacheFolder = "";
		string $every = "";
		for ($every in $cacheFolders){
		    int $len = size($every);
		    int $start = $len - 5;
		    string $verSuffix = `substring $every $start $len`;
		    int $foundVer = `match "[0-9]+" $verSuffix`;
		    if ($foundVer > $ver){
		        $ver = $foundVer;
		        $latestCacheFolder = $every;
		    }
		}
		// latest cache folder found, now check for xml files

		if ($latestCacheFolder != ""){
			return ($cacheRoot+$latestCacheFolder);
		}
		else {
			print ("// autoCacheGetLatestCache: No Cloth Cache Found\n");
			return "";
		}
	}
	else if ($simMode == "hairSim"){
		// find the cache //////////////////////////

		$cacheRoot = (`workspace -q -rd`+"data/haircutCache/");
		$cachePrefix = ($seqName+"_"+$shotName+"_fx_"+$simMode);

		print ("Cache Filter: \""+$cacheRoot+$cachePrefix+"*\"\n");
		string $cacheFolders[] = `getFileList -fs ($cachePrefix+"*") -folder $cacheRoot`;
		//string $sorted[] = sort($cacheFolders);
		print ("// Possible Caches: \n");
		print $cacheFolders;
		print ("// END Possible Caches\n");

		// find which file has latest (must end with _v### )
		int $ver = 0;
		string $latestCacheFolder = "";
		string $every = "";
		for ($every in $cacheFolders){
		    int $len = size($every);
		    int $start = $len - 5;
		    string $verSuffix = `substring $every $start $len`;
		    int $foundVer = `match "[0-9]+" $verSuffix`;
		    if ($foundVer > $ver){
		        $ver = $foundVer;
		        $latestCacheFolder = $every;
		    }
		}

		if ($latestCacheFolder != ""){

			print ("Checking SubFolders of: \""+$cacheRoot+$latestCacheFolder+"/"+"\"\n");

			string $cacheSubFolders[] = `getFileList -fs "*.*" -folder ($cacheRoot+$latestCacheFolder+"/")`;
			//string $sorted[] = sort($cacheFolders);
			print ("// Possible Cache Versions: \n");
			print $cacheSubFolders;
			print ("// END Possible Cache Versions\n");

			// assuming latest cache versoin subfolder is latest returned from getFilelist (its sorted by creation date reverse order)
			string $latestCacheVersion = "";
			$ver = 0;
			for ($every in $cacheSubFolders){
				int $foundVer = `match "[0-9]+" $every`;
				if ($foundVer > $ver){
					$ver = $foundVer;
					$latestCacheVersion = $every;
				}
			}

			print ("Checking SubFolders of: \""+$cacheRoot+$latestCacheFolder+"/"+$latestCacheVersion+"/"+"\"\n");
			return ($cacheRoot+$latestCacheFolder+"/"+$latestCacheVersion);;
		}
		else {
			print ("// autoCacheGetLatestCache: No Hair Cache Found\n");
			return "";
		}
	}
	else{
		print ("// autoCacheGetLatestCache: No Cache Found\n");
		return  "";
	}
}

// checks for corrupt arnold globals and deletes them. this requires reopening scene after removing.
global proc corruptArnoldGlobalCheck (){

	//

}

// clears the hud status when scene files changes
global proc abxShotsClearHUDStatus (){
	global string $hudStatus;
	$hudStatus = "";
}

global proc abxShotsLoadHUDStatus (string $filePath){
	print ("\n\nabxShotsLoadStatus Called\n\n");
	if ($filePath == "")
		$filePath = `file -q -sn`;

	// 0:Server 1:Job 2:ShotFolder 3:Seq 4:Shot 5:dept 6:subDept 7:take 8:version 9:ext
	string $shotInfo[] = abxShotsGetFromPath($filePath);
	global string $hudStatus;
	// anm = 7, fx = 8, lgt = 9
	string $shotDetails[] = abxShotsGetShotDetails(($shotInfo[3]+"/"+$shotInfo[3]+"_"+$shotInfo[4]), $shotInfo[2]);
	string $dept = $shotInfo[5];
	int $index = 6;
	if ($dept == "fx") $index = 7;
	else if ($dept == "lgt") $index = 8;
	string $outputStr = "";
	string $tokenBuffer[];
	tokenize $shotDetails[$index] "," $tokenBuffer;
	string $status = $tokenBuffer[0];
	string $stage = "0";
	if (size($tokenBuffer)>1) $stage = $tokenBuffer[1];

	if (size($shotDetails)>$index){
		if ($shotInfo[2] == "_PREVIS"){
			$outputStr += "PREVIS";
		}
		else{
			switch ($stage){		
				case "0":
					if ($status == "0")
						$outputStr += " PREVIS";
					else
						$outputStr += " BLOCKING";
					break;
				case "1":
					$outputStr += " SPLINING";
					break;
				case "2":
					$outputStr += " POLISHING";
					break;
				default:
					$outputStr += " ???";
			}
		}
		switch ($status){
			case "-2": 
				$outputStr += " DEAD";
				break;	
			case "-1": 
				$outputStr += " HOLD";
				break;	
			case "0":	
			case "1":
			case "2":
				$outputStr += " WIP";
				break;
			case "3":
				$outputStr += " REVIEW";
				break;
			case "4":
				$outputStr += " BLESSED";
				break;
			case "5":
				$outputStr += " APPROVED";
				break;
			default:
				$outputStr += " ???";
		}
		$hudStatus = $outputStr;
	}
	else {
		$hudStatus = "";
	}
	print ("UPDATING SHOT STATUS HUD INFO: "+$shotInfo[3]+"/"+$shotInfo[3]+"_"+$shotInfo[4]+" "+$shotInfo[2]+" "+$dept+" to "+$outputStr+"\n");
	if (`exists getShotStatus`) getShotStatus();
}


// 0:Server 1:Job 2:ShotFolder 3:Seq 4:Shot 5:dept 6:subDept 7:take 8:version 9:ext
global proc string[] abxShotsGetFromPath (string $filePath){

	if ($filePath == "")
		$filePath = `file -q -sn`;

	if ($filePath != ""){
		string $basename = `basenameEx $filePath`;
		string $pathParts[] = stringToStringArray($filePath, "/");
		string $fileParts[] = stringToStringArray($basename, "_");
		string $server = $pathParts[0];
		string $job = $pathParts[1];
		string $folder = $pathParts[5];
		string $sequence = $fileParts[0];
		string $name = $fileParts[1];
		string $dept = $fileParts[2];
		string $subDept = $pathParts[size($pathParts)-2];
		string $version = `match "v[0-9]+" $basename`;
		string $take = "";
		if (!`gmatch $fileParts[3] ($version+"*")`)
			 $take = $fileParts[3];

		string $extension = `fileExtension $filePath`;
		return {$server,$job,$folder,$sequence,$name,$dept,$subDept,$take,$version,$extension};
	}
	else{
		return {};
	}
}

global proc deleteAllInNamespace (string $namespace){
    
    if ($namespace == ""){
        string $sel[] = `ls -sl`;
        string $tokenBuffer[];
        tokenize $sel[0] ":" $tokenBuffer;
        if (size($tokenBuffer)>1)
            $namespace = $tokenBuffer[0];
    }
       print $namespace;
    if ($namespace != ""){
        select -ne -r ($namespace+":*");
        $sel = `ls -sl`;
        for ($each in $sel){
            catch(`lockNode -l 0 $each`);
            catch(`delete $each`);
        }
    }
}


global proc string[] ppNukeCamExport (string $filePath){

	$oldExports = `ls -r 1 "exportCam*"`;
	string $renderCamNames[] = {"renderCam"};
	string $results[];

	if (`objExists "l"` && `objExists "r"`){
		$renderCamNames = {"l","r"};
	}

	if (size($oldExports)){
		for($each in $oldExports)
			catch (`delete $each`);
	}

	if ($filePath == ""){
		$filePath = `file -q -sn`;
	}

	// 0:Server 1:Job 2:ShotFolder 3:Seq 4:Shot 5:dept 6:subDept 7:take 8:version 9:ext
	string $shotInfo[] = abxShotsGetFromPath($filePath);
    string $shotDetails[] = abxShotsGetShotDetails(($shotInfo[3]+"/"+$shotInfo[3]+"_"+$shotInfo[4]), $shotInfo[2]);

    //string $exportPath = ("M:/"+$shotInfo[1]+"/COMP/"+$shotInfo[2]+"/"+$shotInfo[3]+"/"+$shotInfo[3]+"_"+$shotInfo[4]+"/CAM/"+$shotInfo[3]+"_"+$shotInfo[4]+"_"+$shotInfo[5]);



    for ($each in $renderCamNames){

    	// disable fluids to prevent slow exporting
    	setState fluid 0;

    	string $exportPath = ("M:/"+$shotInfo[1]+"/RENDER/"+$shotInfo[2]+"/"+$shotInfo[3]+"/"+$shotInfo[3]+"_"+$shotInfo[4]+"/DATA/CAM/"+$shotInfo[3]+"_"+$shotInfo[4]+"_"+$shotInfo[5]);

	    // if there is more than one camera being exported (stereo pairs) then export with camName
	    string $exportfilename = $shotInfo[8];
	    if (size($renderCamNames)>1)
	    	$exportfilename = ($shotInfo[8]+"_"+$each);


	    if ($shotInfo[7] == "")
			$exportPath += ("_"+$exportfilename+".fbx");
		else 
			$exportPath += ("_"+$shotInfo[7]+"_"+$exportfilename+".fbx");

	    string $exportDir = `dirname $exportPath`;    	
    
	    string $rCam[] = `ls -r 1 $each`;
	    if (size($rCam)==0)
	        error ("NukeCamExport: No Object called 'renderCam' found. Please make sure your renderable camera is named 'renderCam' and try again.");
	    if (size($rCam)>1)
	        error ("NukeCamExport: More than one object called 'renderCam' found. Please remove or rename duplicate renderCam cameras. The scene may only contain one.");
	    
	    string $rCamShapes[] = `listRelatives -s $rCam[0]`;
	    string $exportCam[] = `duplicate -n "exportCam" $rCam[0]`;
	    string $exportCamShapes[] = `listRelatives -s $exportCam[0]`;

	    // remove other children;
	    for ($each in `listRelatives -pa -children $exportCam[0]`){
	        if (`objectType $each` != "camera")
	            catchQuiet(`delete $each`);
	    }
	    
	    $bakeCmd = ("bakeResults -simulation false -t \""+$shotDetails[2]+":"+$shotDetails[3]+"\" -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys true -sparseAnimCurveBake false -removeBakedAttributeFromLayer false -bakeOnOverrideLayer false ");

	    // connect camera shape attributes
	    $attrsToConnect = {"focalLength","lensSqueezeRatio","cameraScale","horizontalFilmAperture","verticalFilmAperture","verticalFilmOffset","horizontalFilmOffset"};
	    for ($each in $attrsToConnect){
	    	setAttr -l 0 ($exportCam[0]+"."+$each);
	        connectAttr ($rCamShapes[0]+"."+$each) ($exportCamShapes[0]+"."+$each);
	        $bakeCmd += ("-at \""+$each+"\" ");
	    }
	    $bakeCmd += $exportCamShapes[0];

	    $unlockAttrs = {"tx","ty","tz","rx","ry","rz"};
	    for ($each in $unlockAttrs){
	        setAttr -l 0 ($exportCam[0]+"."+$each);
	    }    
	    // unparent camera to world
	    if (size(`listRelatives -parent $exportCam[0]`))
	    	evalEcho("parent -w "+$exportCam[0]);


	    // parent constrain
	    parentConstraint -weight 1 $rCam[0] $exportCam[0];

	    evalEcho ($bakeCmd);

	    // convert the horizontalFilmOffset (in inches of filmback) to nuke's window U/V values  ((2/apertureX)*((mayaFilmBackOffsetX) 
	    float $hfa = `getAttr ($exportCam[0]+".horizontalFilmAperture")`;
	    $hfoToNukeWindowU = 2/$hfa;
	    scaleKey -valuePivot 0 -valueScale $hfoToNukeWindowU ($exportCam[0]+".horizontalFilmOffset");

	   	select $exportCam[0];

	   	if (!`filetest -r $exportDir`)
	   	    sysFile -makeDir $exportDir;

	   	// set fbx options
	   	evalEcho("FBXExportFileVersion -v \"FBX200900\"");
	   	evalEcho("FBXExportReferencedContainersContent -v false");
		evalEcho("FBXExportCameras -v true");
		evalEcho("FBXExportBakeComplexStart -v "+$shotDetails[2]);
		evalEcho("FBXExportBakeComplexEnd -v "+$shotDetails[3]);
		evalEcho("FBXExportBakeComplexStep -v 1");
		evalEcho("FBXExportBakeComplexAnimation -v true");

		$oldMin = `playbackOptions -q -min`;
		$oldMax = `playbackOptions -q -max`;

		playbackOptions -e -min $shotDetails[2];
		playbackOptions -e -max $shotDetails[3];



	    // export selected
	    evalEcho("file -force -options \"v=0\" -typ \"FBX export\" -pr -es \""+$exportPath+"\"");

	    delete $exportCam[0];

	    playbackOptions -e -min $oldMin;
		playbackOptions -e -max $oldMax;

		setState fluid 1;

		// prevents file from appearing modified after export
		//file -mf false;
		$results[size($results)] = $exportPath;


	}
	print ($results);
    return $results;
}

global proc string[] ppNukeNullsExport (string $filePath){

	string $results[];

	// disable fluids to prevent slow exporting
	setState fluid 0;

	if ($filePath == ""){
		$filePath = `file -q -sn`;
	}

	// 0:Server 1:Job 2:ShotFolder 3:Seq 4:Shot 5:dept 6:subDept 7:take 8:version 9:ext
	string $shotInfo[] = abxShotsGetFromPath($filePath);
    string $shotDetails[] = abxShotsGetShotDetails(($shotInfo[3]+"/"+$shotInfo[3]+"_"+$shotInfo[4]), $shotInfo[2]);



	string $exportPath = ("M:/"+$shotInfo[1]+"/RENDER/"+$shotInfo[2]+"/"+$shotInfo[3]+"/"+$shotInfo[3]+"_"+$shotInfo[4]+"/DATA/NULLS/"+$shotInfo[3]+"_"+$shotInfo[4]+"_"+$shotInfo[5]);

    // if there is more than one camera being exported (stereo pairs) then export with camName
    string $exportfilename = $shotInfo[8];


    if ($shotInfo[7] == "")
		$exportPath += ("_"+$exportfilename+".fbx");
	else 
		$exportPath += ("_"+$shotInfo[7]+"_"+$exportfilename+".fbx");

    string $exportDir = `dirname $exportPath`;    

	$oldMin = `playbackOptions -q -min`;
	$oldMax = `playbackOptions -q -max`;
	playbackOptions -e -min $shotDetails[2];
	playbackOptions -e -max $shotDetails[3];


	string $newNulls[] = abxShotsStickNulls(`ls -sl`);

   	select $newNulls;

   	if (!`filetest -r $exportDir`)
   	    sysFile -makeDir $exportDir;

   	// set fbx options
   	FBXExportFileVersion -v "FBX200900";
   	FBXExportReferencedContainersContent -v false;
	FBXExportCameras -v true;
	FBXExportBakeComplexStart -v $shotDetails[2];
	FBXExportBakeComplexEnd -v $shotDetails[3];
	FBXExportBakeComplexStep -v 1;
	FBXExportBakeComplexAnimation -v true;

    // export selected
    file -force -options "v=0" -typ "FBX export" -pr -es $exportPath;

    playbackOptions -e -min $oldMin;
	playbackOptions -e -max $oldMax;

	$results[size($results)] = $exportPath;

	catchQuiet(`delete $newNulls`);

	setState fluid 1;

	print $results;
    return $results;
}

global proc string[] abxShotsStickNulls(string $Selection[]){

	// disable fluids to prevent slow exporting
	setState fluid 0;

	string $Locs[];

	int $start = `playbackOptions -q -min`;
	int $end = `playbackOptions -q -max`;

	int $j = 0;
	for ($objects in $Selection){

		$subName = substituteAllString($objects, ":", "_");

		string $loc[] = `spaceLocator -name ("null_"+$subName)`;
		$Locs[$j] = $loc[0];

		// add a pointpoly constraint if its a vertex locator, otherwise do an orient constraint
		if (`gmatch $objects "*.vtx*"`){
			select -clear;
			select $objects;
			select -add $Locs[$j];
			doCreatePointOnPolyConstraintArgList 1 { "0","0","0","1","","1" };
			//string $constraint[]=`pointOnPolyConstraint -weight 1 $objects $Locs[$j]`;
			//setAttr ($constraint[0]+".geo_bodyU0") 0.790328; 
			//setAttr ($constraint[0]+".geo_bodyV0") 0.630023;
			//normalConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $objects $Locs[$j];
			select -clear;
		}
		else {
			orientConstraint -offset 0 0 0 -weight 1 $objects $Locs[$j];
		}
		$j++;
		
	}

	for ($i = $start; $i<=$end; $i++){
		currentTime $i;
		$k = 0;
		for ($objects in $Selection){

			if (`gmatch $objects "*.vtx*"`){

			}
			else{
				float $CVPos[] = `xform -q -t -ws $objects`;
				move -a $CVPos[0] $CVPos[1] $CVPos[2] $Locs[$k];

				setKeyframe ($Locs[$k]+".translateX");
				setKeyframe ($Locs[$k]+".translateY");
				setKeyframe ($Locs[$k]+".translateZ");
			}

			$k++;
		}

	}
	$k = 0;
	for ($objects in $Selection){
		$bakeCmd = "";
		if (`gmatch $objects "*.vtx*"`){
			$bakeCmd = ("bakeResults -simulation false -t \""+$start+":"+$end+"\" -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys true -sparseAnimCurveBake false -removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at tx -at ty -at tz -at rx -at ry -at rz "+$Locs[$k]);
		}
		else{
			$bakeCmd = ("bakeResults -simulation false -t \""+$start+":"+$end+"\" -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys true -sparseAnimCurveBake false -removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at rx -at ry -at rz "+$Locs[$k]);
		}
		evalEcho($bakeCmd);
		$k++;
	}

	setState fluid 1;
	//select -r $Selection;
	return $Locs;
}