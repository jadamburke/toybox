// abxAssets

//
// global component manager for managing the creation and management of assets in maya
//


// make sure this is loaded and up-to-date
//source "//monkey/resources/maya/2012-x64/scripts/Toolbox/Lighting/abxExportShaderMel";
eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Lighting/abxExportShaderMel.mel\"");


global proc abxAssets () {

	global int $dbExists = 0;
	$dbExists = pprainbow();

	string $abxAssetsVersionString = "1.18b";

	if (!`window -exists abxAssetsWindow`)  {
		window -t ("Asset Manager v" + $abxAssetsVersionString + " - PandaPanther") -width 616 -height 650 -menuBar true abxAssetsWindow;

		menu -label "Create";
			menuItem -label "New Character" -c "abxAssetsShowCreateUI \"assets\" \"characters\" \"\" \"model\"";
			menuItem -label "New Prop"  -c "abxAssetsShowCreateUI \"assets\" \"props\" \"\" \"model\"";
			menuItem -label "New Vehicle"  -c "abxAssetsShowCreateUI \"assets\" \"vehicle\" \"\" \"model\"";
			menuItem -label "New Decor"  -c "abxAssetsShowCreateUI \"assets\" \"decor\" \"\" \"model\"";
			menuItem -label "New Set"  -c "abxAssetsShowCreateUI \"assets\" \"sets\" \"\" \"model\"";
			menuItem -label "New Shader" -c "abxAssetsShowCreateUI \"assets\" \"shaders\" \"\" \"model\"";
			menuItem -label "New Light Rig" -c "abxAssetsShowCreateUI \"assets\" \"lightRigs\" \"\" \"model\"";

		formLayout abxAssetsWindowMainForm;

		paneLayout -configuration "vertical2" abxAssetMainPane;
		
		tabLayout -imw 0 -imh 0 -cc "abxAssetsDeptTabChange;" abxAssetsListTabLyt;
		setParent ..;
		tabLayout -imw 0 -imh 0 -cc "abxAssetsDeptTabChange;" abxAssetsUITabLyt;
			formLayout -p abxAssetsUITabLyt abxAssetsDetailsForm;
			formLayout -p abxAssetsUITabLyt abxAssetsUIForm;
				//if (!`exists abxAssetUILoadForm`)
					eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/production/abxAssetUI.mel\"");
				// parent the UI form
				abxAssetUILoadForm("abxAssetsUIForm");
		
		formLayout -p abxAssetsListTabLyt abxAssetsLibForm;
		formLayout -p abxAssetsListTabLyt abxAssetsLibListForm;
		formLayout -p abxAssetsListTabLyt -en 1 abxAssetsSrcFrmLyt;
			button -l "Refresh" -c "abxAssetsReloadInScene;" abxAssetsAnmScnListRefreshBtn;
			treeView -elc abxAssetsEditShotLabelCB -idc "abxAssetsAnmScnListDblClk" -numberOfButtons 3 -abr true -enk true -sc "abxAssetsSetActiveSceneAsset" -cmc "abxAssetsUpdateSceneAssetsMenu" abxAssetsAnmScnList;

			popupMenu abxAssetsAnmPUMenu;
			menuItem -label ("Dept:"+"TakeName") abxAssetsAnmMenuItemTitle;
			menuItem -divider 1;
			menuItem -en 1 -label "Select ROOT" -c "abxAssetsScnRefCtxMCmd \"select ROOT\"";
			menuItem -divider 1;
			menuItem -en 1 -label "Reload Asset" -c "abxAssetsScnRefCtxMCmd \"reload\"";
			menuItem -en 1 -label "Load / Unload Asset" -c "abxAssetsScnRefCtxMCmd \"toggleLoad\"";
			menuItem -en 1 -label "Lock / Unlock Asset" -c "abxAssetsScnRefCtxMCmd \"toggleLock\"";
			menuItem -divider 1;
			//menuItem -en 0 -label "Export Animation";
			//menuItem -en 0 -label "Import Animation";
			//menuItem -divider 1;
			
			menuItem -divider 1;
			menuItem -en 1 -label "Remove Asset" -c "abxAssetsScnRefCtxMCmd \"remove\"";

			formLayout -e 
			-af abxAssetsAnmScnListRefreshBtn "left" 3
			-af abxAssetsAnmScnListRefreshBtn "top" 3
			-an abxAssetsAnmScnListRefreshBtn "bottom"
			-af abxAssetsAnmScnListRefreshBtn "right" 3

			-af abxAssetsAnmScnList "left" 3
			-af abxAssetsAnmScnList "top" 30
			-af abxAssetsAnmScnList "bottom" 3
			-af abxAssetsAnmScnList "right" 3
 
			abxAssetsSrcFrmLyt;

		setParent abxAssetsLibForm;

		string $assetLister = `treeLister -w 250 abxAssetsTreeLister`;
		setParent abxAssetsLibListForm;
		string $assetTreeView = `treeView -elc abxAssetsEditShotLabelCB -numberOfButtons 3 -abr true -enk true  -sc "abxAssetsSetActiveListAsset" -cmc "" -ecc "abxAssetsExpandListAsset" -pc 1 "abxAssetsTVBtnG" -pc 2 "abxAssetsTVBtnS" -pc 3 "abxAssetsTVBtnR" -idc "abxAssetsTreeViewDblClk" abxAssetsTreeView`;
		abxAssetsBuildContextMenu $assetLister;

		setParent abxAssetsDetailsForm;

		print ("treeLister="+$assetLister+"\n");
		menu -label "View";
			menuItem -label "Refresh" -c ("treeLister -e -clearContents "+$assetLister+"; abxAssetsPopulateUIList "+$assetLister);
		menu -label "Tools";
			menuItem -en 1 -sm 1 -label "Assembly";
				menuItem -en 1 -label "Update All Prop/Decor Assets" -c "abxAssetsUpdateWorkRefs \"all\" 1";
				menuItem -en 1 -label "Duplicate Instance of Prop/Decor Asset" -c "abxAssetsInstanceWorkRef";
				setParent -menu ..;
			menuItem -en 1 -sm 1 -label "Modeling";
				menuItem -en 1 -label "Convert namespace to underscores" -c "abxAssetsNamespaceToRnp";
				menuItem -en 1 -label "Remove all namespaces" -c "abxAssetsRemoveAllNamespaces";
				menuItem -en 1 -label "Turn off all Smooth Mesh Previews" -c "abxAssetsNoPolySmooth";
				menuItem -en 1 -label "Delete All Render Layers" -c "abxAssetsDeleteAllRenderLayers";
				menuItem -en 1 -label "Delete All Display Layers" -c "abxAssetsDeleteAllDisplayLayers";
				menuItem -divider 1;
				menuItem -en 1 -label "Check For Face Assignments" -c "abxAssetsFaceAssignmentCheck 0";
				menuItem -en 1 -label "Check For Lambert1 Assignments" -c "initialShadingGroupCheck 0";
				menuItem -en 1 -label "Remove Orphan Isolate Selected Sets" -c "abxAssetsRemoveIsolateSelected";
			setParent -menu ..;
			menuItem -en 1 -sm 1 -label "Rigging";
				menuItem -en 1 -label "Swap Refs to Moon" -c "abxAssetsFixStoryNeonRefs";
				menuItem -en 1 -label "Check for Name Clashes" -c ("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Misc/checkNameClash.mel\";checkNameClash;");
				menuItem -en 1 -label "Clear Failed Edits on Refs" -c "abxAssetsClearFailedEdits";
			    menuItem -en 1 -label "Restore Deformed Geo Shader Assignments" -c "abxAssetsRestoreDeformedShader 0;";
			    menuItem -en 1 -label "Restore Deformed Geo Render Attrs" -c "abxAssetsRestoreShapeRenderProperties 1";
			setParent -menu ..;

		//menuItem abxAssetsMakeTexturesLocal ("auto");
		menu -label "Help";
			menuItem -label "Castle Wiki" -c"system \"start \\\"C:/Program Files (x86)/Mozilla Firefox/firefox.exe\\\" \\\"http://purple/castle/pipeline/assetManager/index.php\\\"\"";;
			menuItem -label "About Asset Manager" ;

		$pMenu = `popupMenu -parent $assetLister -pmc ("abxAssetsUpdateContextMenu \""+$assetLister+"\"") abxAssetsPopupMenu`;
		abxAssetsBuildContextMenu $assetLister;
    			
		formLayout -e
        		-af abxAssetMainPane top 0
        		-af abxAssetMainPane left 0
        		-af abxAssetMainPane bottom 0
        		-af abxAssetMainPane right 0
        		abxAssetsWindowMainForm;

		formLayout -e 
			-af $assetLister left 0
			-af $assetLister top 0
			-af $assetLister right 0
			-af $assetLister bottom 0
			abxAssetsLibForm;

		formLayout -e 
			-af $assetTreeView left 0
			-af $assetTreeView top 0
			-af $assetTreeView right 0
			-af $assetTreeView bottom 0
			abxAssetsLibListForm;

		tabLayout -e -tl abxAssetsLibForm "Library"  abxAssetsListTabLyt;
		tabLayout -e -tl abxAssetsLibListForm "List"  abxAssetsListTabLyt;
		tabLayout -e -tl abxAssetsSrcFrmLyt "In Scene"  abxAssetsListTabLyt;

		tabLayout -e -tl abxAssetsDetailsForm "Details"  abxAssetsUITabLyt;
		tabLayout -e -tl abxAssetsUIForm "Asset UI"  abxAssetsUITabLyt;

		paneLayout -e -paneSize 1 30 100 abxAssetMainPane;

		abxAssetsPopulateUIList($assetLister);
		abxAssetsCreateDetailUI();
		abxAssetsPopulateTreeView();
		abxAssetsReloadInScene();
		//showWindow abxAssetsWindow;
	}

	window -e -width 616 -height 650 abxAssetsWindow;
	showWindow abxAssetsWindow;
}

global proc int abxAssetsSetActiveSceneAsset (string $itemName, int $state) {
	if ($state == 1){
		menuItem -e -label $itemName abxAssetsAnmMenuItemTitle;
		//abxShotsRefreshDetailsUI $shotName;
		string $tokenBuffer[];
		tokenize $itemName "|" $tokenBuffer;
		abxAssetsSetActiveAsset($tokenBuffer[0]);
		//print ("set current Item to "+$tokenBuffer[0]+"\n");
	}
	return 1;
}

global proc abxAssetsClearUIList (string $treeLister) {

	treeLister e -clearContents $treeLister;

}

global proc string abxAssetsEditShotLabelCB (string $oldName, string $newName){
	return "";
}

global proc abxAssetsReloadInScene(){

	string $foundAssets[] = sort(abxAssetsGetAssetsInScene());
	treeView -e -removeAll abxAssetsAnmScnList;
	string $each;
	treeView -e -pc 1 "abxAssetsBtnPressCmd \"toggleLoad\"" -pc 2 "abxAssetsBtnPressCmd \"reload\"" -pc 3 "abxAssetsBtnPressCmd \"toggleLock\"" abxAssetsAnmScnList;
	for ($each in $foundAssets){
		string $tokenBuffer[];
		tokenize $each "|" $tokenBuffer;
		string $refNode = `referenceQuery -rfn $tokenBuffer[1]`;
		string $namespace = `file -q -namespace $tokenBuffer[1]`;
		int $isLoaded = `referenceQuery -isLoaded $refNode`;
		int $isLocked = `getAttr ($refNode+".locked")`;
		treeView -e  -addItem $each "" abxAssetsAnmScnList;
		treeView -e -bto $each 1 true -bs $each 1 "2StateButton" -bs $each 3 "2StateButton" -bto $each 2 true -bto $each 3 true abxAssetsAnmScnList;
		if ($isLoaded){
			treeView -e -bst $each 1 buttonDown -i $each 1 (`getenv MAYA_PPTOOLS`+"/icons/glyph_check.png") abxAssetsAnmScnList;
			treeView -e -lbc $each .27 .27 .27 abxAssetsAnmScnList;
		}
		else{
			treeView -e -bst $each 1 buttonUp -i $each 1 "" abxAssetsAnmScnList;
			treeView -e -lbc $each .2 .2 .2 abxAssetsAnmScnList;
			treeView -e -tc $each .3 .3 .3 abxAssetsAnmScnList;
		}
		if ($isLocked){
			treeView -e -bst $each 3 buttonDown -i $each 3 (`getenv MAYA_PPTOOLS`+"/icons/glyph_lock.png") abxAssetsAnmScnList;
		}
		else{	
			treeView -e -bst $each 3 buttonUp -i $each 3 "" abxAssetsAnmScnList;
		}
		treeView -e -dl $each $namespace abxAssetsAnmScnList;
		treeView -e -i $each 2 (`getenv MAYA_PPTOOLS`+"/icons/glyph_reload.png") abxAssetsAnmScnList;
		//treeView -e -bs $each 1 "3StateButton" -bs $each 2 "3StateButton" abxAssetsAnmScnList;
		treeView -e -hl $each 1 abxAssetsAnmScnList;
		treeView -e -hc $each .2 .2 .2 abxAssetsAnmScnList;
	//	textScrollList -e -append $each abxAssetsAnmScnList;
	}
}

global proc abxAssetsBtnPressCmd (string $cmd, string $item, int $state){
	menuItem -e -label $item abxAssetsAnmMenuItemTitle;
	abxAssetsScnRefCtxMCmd $cmd;

}

// prevents tree list view items from being double clicked
global proc int abxAssetsAnmScnListDblClk (string $itemName){
	//print ("$itemName = "+$itemName+"\n");
	//menuItem -e -label $itemName abxAssetsAnmMenuItemTitle;
	abxAssetsScnRefCtxMCmd "select ROOT";
	return true;
}

// prevents tree list view items from being double clicked
global proc int abxAssetsAnmScnListDblClk (string $itemName){
	//print ("$itemName = "+$itemName+"\n");
	//menuItem -e -label $itemName abxAssetsAnmMenuItemTitle;
	abxAssetsScnRefCtxMCmd "select ROOT";
	return true;
}

global proc abxAssetsScnRefCtxMCmd (string $command){
	string $assetPath = `menuItem -q -label abxAssetsAnmMenuItemTitle`;

	string $tokenBuffer[];
	tokenize $assetPath "|" $tokenBuffer;
	string $tokenBuffer2[];
	tokenize $tokenBuffer[0] "/" $tokenBuffer2;
	string $filename = $tokenBuffer[1];
	string $assetName = $tokenBuffer2[2];
	string $assetType = $tokenBuffer2[1];
	string $assetLib = $tokenBuffer2[0];

	string $namespace = evalEcho("file -q -namespace \""+$filename+"\"");
	string $refNode = `referenceQuery -rfn $filename`;
	switch ($command){
	case "select ROOT":
		select ($namespace+":ROOT");
		break;
	case "reload":
		file -loadReference $refNode;
		break;
	case "toggleLock":
		if (`getAttr ($refNode+".locked")`){
			$result = `confirmDialog -title "Unlock Asset Confirm:" -message ("It is highly recommended to keep your asset locked. If you are having trouble working with locked assets contact a TD (adam). Are you sure you want to unlock "+$namespace+"?") -button "Unlock" -button "Cancel"  -defaultButton "Unlock" -cancelButton "Cancel" -dismissString "Cancel"`;
				if ($result == "Unlock"){
				file -unloadReference $refNode;
				setAttr ($refNode+".locked") 0;
				file -loadReference $refNode;
			}
		}
		else {
			file -unloadReference $refNode;
			setAttr ($refNode+".locked") 1;
			file -loadReference $refNode;
		}
		break;
	case "toggleLoad":
		if (`referenceQuery -isLoaded $refNode`){
			file -unloadReference $refNode;
		}
		else{
			file -loadReference $refNode;
		}
		break;
	case "remove":
		$result = `confirmDialog -title "Remove Asset Confirm:" -message ("Are you sure you want to remove the reference "+$namespace+"? This cannot be undone.") -button "Remove" -button "Cancel"  -defaultButton "Remove" -cancelButton "Cancel" -dismissString "Cancel"`;
		if ($result == "Remove"){
			file -removeReference $filename;
		}
		break;
	}
	abxAssetsReloadInScene();
}

// loads the cache file to save file query times
global proc string[] abxAssetsGetAllAssets (int $useAssetCache, int $useStatusCache, int $rebuildCache){
	string $projectPath = `workspace -q -rd`;
	string $assetFolders[] = `getFileList -folder ($projectPath+"/assets/")`;

	string $assetList[];
	string $assetLib[];
	string $assetType[];
	string $assetPath[];
	string $index = 0;

	string $result[];

	for ($each in $assetFolders){

		if (`filetest -d ($projectPath+"/assets/"+$each)`){

			string $subFolders[] = `getFileList -folder ($projectPath+"/assets/"+$each+"/")`;
			string $sorted[] = sort($subFolders);
			
			for ($every in $sorted){
				if (`filetest -d ($projectPath+"/assets/"+$each+"/"+$every)`){
					if ($every != "old" && $every != "_OLD" && $every != "archive"){
						$assetPath[size($assetList)] = ($projectPath+"/assets/"+$each+"/"+$every);
						$assetLib[size($assetList)] = "assets";
						$assetType[size($assetList)] = $each;
						$assetList[size($assetList)] = $every;
					}
				}
			}
		}
	}
return $result;
}

global proc abxAssetsPopulateUIList (string $treeLister) {

	// get a list of the directories inside assets folder for project
	string $projectPath = `workspace -q -rd`;
	//string $backlotPath = "//MONKEY/resources/backlot";

	string $assetFolders[] = `getFileList -folder ($projectPath+"/assets/")`;
	//string $backlotFolders[] = `getFileList -folder ($backlotPath+ "/assets/")`;

	string $assetList[];
	string $assetLib[];
	string $assetType[];
	string $assetPath[];
	string $index = 0;

	for ($each in $assetFolders){

		if (`filetest -d ($projectPath+"/assets/"+$each)`){

			string $subFolders[] = `getFileList -folder ($projectPath+"/assets/"+$each+"/")`;
			string $sorted[] = sort($subFolders);
			
			for ($every in $sorted){
				if (`filetest -d ($projectPath+"/assets/"+$each+"/"+$every)`){
					if ($every != "old" && $every != "_OLD" && $every != "archive"){
						$assetPath[size($assetList)] = ($projectPath+"/assets/"+$each+"/"+$every);
						$assetLib[size($assetList)] = "assets";
						$assetType[size($assetList)] = $each;
						$assetList[size($assetList)] = $every;
					}
				}
			}
		}
	}

	for ($i=0;$i<size($assetList);$i++){
		string $thumbIcon = "";
		//string $thumbPath = ($projectPath+"assets/"+$assetType[$i]+"/"+$assetList[$i]+"/"+$assetList[$i]+".png");
		//string $thumbPath = ($assetPath[$i]+"/"+$assetList[$i]+".png");
		//if (`filetest -r $thumbPath`){
		//	$thumbIcon = $thumbPath;
		//}
		treeLister -e -add ($assetLib[$i]+"/"+$assetType[$i]+"/"+$assetList[$i]) $thumbIcon ("abxAssetsSetActiveAsset(\"assets/"+$assetType[$i]+"/"+$assetList[$i]+"\");") $treeLister;
	}
	
	if (`filetest -d ($projectPath+"/assets/characters/")` && size ($assetList) != 0){
		treeLister -e -selectPath "assets" $treeLister;
		treeLister -e -expandPath "assets" $treeLister;
	}
}

global proc abxAssetsPopulateTreeView (){
	string $projectPath = `workspace -q -rd`;
	string $backlotPath = "//MONKEY/resources/backlot";
	string $listControl = "abxAssetsTreeView";

	string $assetFolders[] = `getFileList -folder ($projectPath+"/assets/")`;

	string $assetList[];
	string $assetLib[];
	string $assetType[];
	string $assetPath[];
	string $index = 0;

	for ($each in $assetFolders){

		if (`filetest -d ($projectPath+"/assets/"+$each)`){
		
			string $subFolders[] = `getFileList -folder ($projectPath+"/assets/"+$each+"/")`;

			string $sorted[] = sort($subFolders);

			
			for ($j=0;$j<1;$j++){
				string $every = $sorted[$j];
				if (`filetest -d ($projectPath+"/assets/"+$each+"/"+$every)`){
					if ($every != "old" && $every != "_OLD" && $every != "" && $every != "archive"){
						$assetPath[size($assetList)] = ($projectPath+"/assets/"+$each+"/"+$every);
						$assetLib[size($assetList)] = "assets";
						$assetType[size($assetList)] = $each;
						$assetList[size($assetList)] = $every;
					}
				}
			}
		}
	}
	// only do the first item in the list to save load time
	for ($i=0;$i<size($assetType);$i++){
	//for ($i=0;$i<1;$i++){
		string $thumbIcon = "";
		//string $thumbPath = ($projectPath+"assets/"+$assetType[$i]+"/"+$assetList[$i]+"/"+$assetList[$i]+".png");
		string $thumbPath = ($assetPath[$i]+"/"+$assetList[$i]+".png");
		string $fullname = ($assetLib[$i]+"/"+$assetType[$i]+"/"+$assetList[$i]);
		if (`filetest -r $thumbPath`){
			$thumbIcon = $thumbPath;
		}
		if (!`treeView -q -itemExists ($assetLib[$i]+"/"+$assetType[$i]) $listControl`){
			treeView -e -addItem ($assetLib[$i]+"/"+$assetType[$i]) "" $listControl;
			treeView -e -selectionColor ($assetLib[$i]+"/"+$assetType[$i]) .8 .8 .8 $listControl;

			treeView -e -displayLabel ($assetLib[$i]+"/"+$assetType[$i]) $assetType[$i] $listControl;
			treeView -e -bti ($assetLib[$i]+"/"+$assetType[$i]) 1 "G" -bti ($assetLib[$i]+"/"+$assetType[$i]) 2 "S" -bti ($assetLib[$i]+"/"+$assetType[$i]) 3 "R" $listControl;
			treeView -e -btc ($assetLib[$i]+"/"+$assetType[$i]) 1 .2 .2 .2 -btc ($assetLib[$i]+"/"+$assetType[$i]) 2 .2 .2 .2 -btc ($assetLib[$i]+"/"+$assetType[$i]) 3 .2 .2 .2 $listControl;
			treeView -e -ei ($assetLib[$i]+"/"+$assetType[$i]) 0 $listControl;
		}
		treeView -e -addItem $fullname ($assetLib[$i]+"/"+$assetType[$i]) $listControl;
		treeView -e -selectionColor $fullname .8 .8 .8 -lbc $fullname .2 .2 .2 $listControl;

		treeView -e -displayLabel $fullname $assetList[$i] $listControl;
		treeView -e -bti $fullname 1 "" -bti $fullname 2 "" -bti $fullname 3 "" $listControl;
		treeView -e -lbc $fullname .2 .2 .2 $listControl;
	}


}

global proc int abxAssetsExpandListAsset (string $itemName, int $state) {
	if ($state == 1){
		string $projectPath = `workspace -q -rd`;
		string $listControl = "abxAssetsTreeView";

		string $assetFolders[] = `getFileList -folder ($projectPath+"/"+$itemName)`;

		string $assetList[];
		string $assetLib[];
		//string $assetType[];
		string $assetPath[];
		string $index = 0;

			
		string $subFolders[] = `getFileList -folder ($projectPath+"/"+$itemName+"/")`;

		string $sorted[] = sort($subFolders);

				
		for ($every in $sorted){
			if (`filetest -d ($projectPath+"/"+$itemName+"/"+$every)`){
				if ($every != "old" && $every != "_OLD" && $every != "archive"){
					$assetPath[size($assetList)] = ($projectPath+"/"+$itemName+"/"+$every);
					$assetLib[size($assetList)] = "assets";
					//$assetType[size($assetList)] = $each;
					$assetList[size($assetList)] = $every;
				}
			}
		}

		// only do the first item in the list to save load time
		//for ($i=0;$i<size($assetList);$i++){
		for ($i=1;$i<size($assetList);$i++){
			string $thumbIcon = "";
			//string $thumbPath = ($projectPath+"assets/"+$assetType[$i]+"/"+$assetList[$i]+"/"+$assetList[$i]+".png");
			string $thumbPath = ($assetPath[$i]+"/"+$assetList[$i]+".png");
			string $fullname = ($itemName+"/"+$assetList[$i]);
			if (`filetest -r $thumbPath`){
				$thumbIcon = $thumbPath;
			}
			if (!`treeView -q -itemExists $fullname $listControl`){
				treeView -e -addItem $fullname ($itemName) $listControl;
				treeView -e -selectionColor $fullname .8 .8 .8 -lbc $fullname .2 .2 .2 $listControl;
				treeView -e -displayLabel $fullname $assetList[$i] $listControl;
				treeView -e -bti $fullname 1 "" -bti $fullname 2 "" -bti $fullname 3 "" $listControl;
			}
			if ($i%2)
				treeView -e -lbc $fullname .24 .24 .24 $listControl;
				
			else 
				treeView -e -lbc $fullname .2 .2 .2 $listControl;
		}

		abxAssetsUpdateTreeViewStatus($itemName);
		//print ("set asset to "+$assetName+"\n");
	}
	return 1;

}

// prevents tree list view items from being double clicked
global proc int abxAssetsTreeViewDblClk (string $itemName){
	return true;
}

// updates the tree control popup menu
global proc int abxAssetsUpdateMenu (string $itemName) {
	//treeView -e -cs abxAssetsTreeViewList;
	//treeView -e -si $itemName 1 abxAssetsTreeViewList;
	//menuItem -e -label $itemName abxAssetsListPMItemTitle;

	return true;

}

global proc abxAssetsUpdateTreeViewStatus (string $assetType){
	string $listControl = "abxAssetsTreeView";
	if (`treeView -q -itemExists $assetType $listControl`){
		string $typeChildren[] = `treeView -q -ch $assetType $listControl`;
		for ($i=1;$i<size($typeChildren);$i++){
			string $each = $typeChildren[$i];
			// open the details file for the asset
			string $assetDetails[] = abxAssetsGetAssetDetails($each);
			// rig status
			if ($assetDetails[1] != ""){
				int $status = $assetDetails[1];
				eval("treeView -e -btc \""+$each+"\" 3 "+`abxAssetsStatAsColor $status`+" "+$listControl);
			}
			else {
				//eval("button -e -bgc .4 .4 .4 abxAssetsRStatBtn");
				//eval("button -e -ebg 0 abxAssetsRStatBtn");
			}
			// geo status
			if ($assetDetails[2] != ""){
				int $status = $assetDetails[2];
				eval("treeView -e -btc \""+$each+"\" 1 "+`abxAssetsStatAsColor $status`+" "+$listControl);
			}
			else {
				//eval("button -e -bgc .4 .4 .4 abxAssetsGStatBtn");
				//eval("button -e -ebg 0 abxAssetsGStatBtn");
			}
			// shader status
			if ($assetDetails[3] != ""){
				int $status = $assetDetails[3];
				eval("treeView -e -btc \""+$each+"\" 2 "+`abxAssetsStatAsColor $status`+" "+$listControl);
			}
			else {
				//eval("button -e -bgc .4 .4 .4 abxAssetsSStatBtn");
				//eval("button -e -ebg 0 abxAssetsSStatBtn");
			}
		}

	}

}

global proc abxAssetsSetActiveAsset (string $assetPath) {
	print ("set asset to "+$assetPath+"\n");
	abxAssetsRefreshDetailsUI $assetPath;

}


global proc int abxAssetsSetActiveListAsset (string $assetName, int $state) {
	$treeView = "abxAssetsTreeView";
	if ($state == 1){
		string $tokenBuffer[];
		tokenize $assetName "/" $tokenBuffer;
		if (size($tokenBuffer) == 3){
			abxAssetsSetActiveAsset($assetName);
			//print ("set asset to "+$assetName+"\n");
		}
		treeView -e -textColor $assetName .2 .2 .2 $treeView;
	}
	else{
		treeView -e -textColor $assetName .8 .8 .8 $treeView;
	}
	return 1;

}

// rebuild the context menu to reflect the active asset
global proc abxAssetsBuildContextMenu (string $treeLister){

	// delete the current popup menu items
	string $popupMenus[] = `treeLister -q -pma $treeLister`;

	for ($each in $popupMenus){
		menuItem -parent $each -label "Asset Label" -ann "Open the scene folder in Windows" -c "abxAssetsCtxMCmd(\"browse\")" abxAssetsPopupMenuItemTitle ;
		menuItem -parent $each -divider true;
		//menuItem -parent $each -divider 1;
		//menuItem -parent $each -divider 1;
		menuItem -parent $each -label "Reference Published Rig" -ann "Reference in the Published Rig scene" -c "abxAssetsCtxMCmd(\"ref asset\")";
		menuItem -sm 1 -parent $each -label "More Options";
			menuItem -label "Reference Geo Master" -c "abxAssetsCtxMCmd(\"refgeo asset\")";
			menuItem -divider true;
			menuItem -label "Reference As Prop" -c "abxAssetsCtxMCmd(\"refgeoworkprop asset\")";
			menuItem -label "Reference As Decor" -c "abxAssetsCtxMCmd(\"refgeoworkdecor asset\")";
			menuItem -divider true;
			menuItem -label "Import Published Rig" -c "abxAssetsCtxMCmd(\"import asset\")";
			menuItem -en false -label "Import Geo Only";
			menuItem -divider true;
			menuItem -label "Reference As Temporary" -ann "Creates a reference that is automatically removed during mastering." -c "abxAssetsCtxMCmd(\"ref temp\")";
			setParent..;
		menuItem -parent $each -divider true;
		
		menuItem -parent $each -en false -label "======= Geo =======";
		//menuItem -parent $each -divider 1;
		menuItem -parent $each -label "Open Latest Geo Work Scene" -ann "Open the latest version of the Geo work scene" -c "abxAssetsCtxMCmd(\"open geo work\");";
		menuItem -parent $each -label "Open Latest Geo Work Scene in Separate Maya" -ann "Open the latest version of the Geo work scene in a separate maya" -c "abxAssetsCtxMCmd(\"open geo work bg\");";

		//menuItem -parent $each -label "  Open Geo Master" -c "abxAssetsCtxMCmd(\"open geo master\");";
		menuItem -parent $each -label "Save Geo Work Scene New Version" -ann "Save the current scene as a new version of the Geo work scene" -c "abxAssetsCtxMCmd(\"save geo work\")";
		menuItem -parent $each -label "Update Geo Master With This Scene" -ann "Save this scene as the new Geo Master.  Must have the latest Geo work scene open." -c "abxAssetsCtxMCmd(\"save geo master\")";
		menuItem -parent $each -divider true;
		menuItem -parent $each -en false -label "======= Rig =======";
		//menuItem -parent $each -divider 1;
		menuItem -parent $each -label "Create Rig Work Scene From Geo" -ann "Create a Rig work scene from this scene.  Must have latest Geo work scene open.  Rig scene can't already exist." -c "abxAssetsCtxMCmd(\"start rig work\");";
		//menuItem -parent $each -en 0 -label "  Ref Geo" -c "abxAssetsCtxMCmd(\"refgeo asset\")";
		menuItem -parent $each -label "Open Latest Rig Work Scene" -ann "Open the latest version of the Rig work scene" -c "abxAssetsCtxMCmd(\"open rig work\");";
		menuItem -parent $each -label "Open Latest Rig Work Scene in Separate Maya" -ann "Open the latest version of the Geo work scene in a separate maya" -c "abxAssetsCtxMCmd(\"open rig work bg\");";

		//menuItem -parent $each -label "  Open Rig Master Scene" -c "abxAssetsCtxMCmd(\"open rig master\");";;
		menuItem -parent $each -label "Save Rig Work Scene New Version" -ann "Save the current scene as a new version of the Rig work scene" -c "abxAssetsCtxMCmd(\"save rig work\")";
		menuItem -parent $each -label "Update Rig Master With This Scene" -ann "Save this scene as the new Rig Master.  Must have the latest Rig work scene open." -c "abxAssetsCtxMCmd(\"save rig master\")";
		menuItem -parent $each -divider true;
		menuItem -parent $each -label "Publish This Rig Master" -ann "Publish this scene.  Must have the Rig Master scene open." -c "abxAssetsCtxMCmd(\"publish\")";
		menuItem -parent $each -divider true;
		
		menuItem -sm 1 -parent $each -label "Open Master";
			menuItem -label "Open Geo Master Scene" -c "abxAssetsCtxMCmd(\"open geo master\");";
			menuItem -label "Open Rig Master Scene" -c "abxAssetsCtxMCmd(\"open rig master\");";;
			setParent ..;
		menuItem -parent $each -divider true;
		
		menuItem -parent $each -divider true;
		menuItem -parent $each -label "Open Other Scene..." -c "abxAssetsCtxMCmd(\"open other\")";
		menuItem -parent $each -label "Capture Thumbnail" -c"abxAssetsCtxMCmd(\"thumb\")";
		menuItem -parent $each -label "Pack Asset" -c"abxAssetsCtxMCmd(\"pack publish\")";
	}
}

global proc abxAssetsUpdateContextMenu (string $treeLister){
	string $selAsset = "";
	if (`treeLister -q -exists $treeLister`){
		$selAsset = `treeLister -q -ruc $treeLister`;
		evalDeferred("treeLister -e -ei \""+$selAsset+"\" "+$treeLister);
	}
	else if (`treeView -q -exists $treeLister`){
		$selAsset = `treeView -q -si $treeLister`;
	}
	menuItem -e -label $selAsset abxAssetsPopupMenuItemTitle;
	
}

// executes commands from the popup menu while making sure they are applied to the correct asset
global proc abxAssetsCtxMCmd(string $command){
	
	string $assetPath = `menuItem -q -label abxAssetsPopupMenuItemTitle`;

	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetName = $tokenBuffer[2];
	string $assetType = $tokenBuffer[1];
	string $assetLib = $tokenBuffer[0];

	switch ($command){
	case "open geo work":
		abxAssetsOpenWorkScene(($assetPath+"/geo"), "latest", false);
		break;
	case "open geo work bg":
		string $eCmd = encodeString("abxAssetsOpenWorkScene((\""+$assetPath+"/geo\"), \"latest\", false)");
		callMayaBG (0, 1, "", `workspace -q -rd`, "", $eCmd);
		break;
	case "open geo master":
		abxAssetsOpenMasterScene($assetPath+"/geo", false);
		headsUpMessage -time 3600  "THIS IS THE GEO MASTER SCENE. DO NOT MODIFY!";
		break;
	case "start rig work":
		abxAssetsStartRigScene($assetPath, false);
		break;
	case "open rig work":
		abxAssetsOpenWorkScene(($assetPath+"/rig"), "latest", false);
		break;
	case "open rig work bg":
		string $eCmd = encodeString("abxAssetsOpenWorkScene((\""+$assetPath+"/rig\"), \"latest\", false)");
		callMayaBG (0, 1, "", `workspace -q -rd`, "", $eCmd);
		break;
	case "open rig master":
		abxAssetsOpenMasterScene($assetPath+"/rig", false);
		headsUpMessage -time 3600  "THIS IS THE RIG MASTER SCENE. DO NOT MODIFY!";
		break;
	case "save rig work":
		abxAssetsIncrementalSave(($assetPath+"/rig"), false, "");
		break;
	case "save rig master":
		abxAssetsMaster(($assetPath+"/rig"), false, "");
		break;
	case "save geo work":
		abxAssetsIncrementalSave(($assetPath+"/geo"), false, "");
		break;
	case "save geo master":
		abxAssetsMaster(($assetPath+"/geo"), false, "");
		break;
	case "publish":
		abxAssetsPublish($assetPath, false, "");
		break;
	case "ref asset":
		abxAssetsRefAsset($assetPath,"",1);
		break;
	case "ref asset rproxy":
		abxAssetsRefAsset($assetPath,"renderproxy",1);
		break;
	case "ref asset previs":
		abxAssetsRefAsset($assetPath,"previs",1);
		break;
	case "ref asset proxy":
		abxAssetsRefAsset($assetPath,"proxy",1);
		break;
	case "ref temp":
		abxAssetsRefTemp($assetPath);
		break;
	case "refgeo asset":
		abxAssetsRefGeo($assetPath);
		break;
	case "refgeoworkprop asset":
		abxAssetsRefGeoWork($assetPath,"prop");
		break;
	case "refgeoworkdecor asset":
		abxAssetsRefGeoWork($assetPath,"decor");
		break;
	case "import asset":
		abxAssetsImpAsset($assetPath);
		break;
	case "thumb":
		abxAssetsCaptureThumbnail($assetPath);
		break;
	case "browse":
		abxAssetsBrowseShot($assetPath);
		break;
	case "open other":
		abxAssetsFileOpenHere($assetPath);
		break;
	case "pack publish":
		string $packScriptSource = (`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Misc/ppPackScene.mel");
		if (`filetest -r $packScriptSource`){
			eval("source \""+$packScriptSource+"\"");
			if (!`window -ex ppPackSceneWindow`)
				ppPackScene;
			string $scenePath = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+".mb");
			textScrollList -e -append $scenePath ppPackSceneFLScrlLst;
		}
		else {
			error ("Could Not Find Pack Script:"+$packScriptSource);
		}

		break;
	case "pack editable":
		// NOT DONE YET
		break;
	}
	
}



global proc abxAssetsCreateDetailUI (){
	
	setParent abxAssetsDetailsForm;

	paneLayout -bgc .4 .4 .4 -configuration "horizontal2" abxAssetsDetailsPane;

	scrollLayout -p abxAssetsDetailsPane -bgc .2 .2 .2 -cr true abxAssetsDetailsScrlLyt;

	formLayout abxAssetSpecLyt;
		columnLayout -cat "both" 4 -rs 6 -adj 1 abxAssetsDtlColLyt;
			separator -h 2 -style "none";
			frameLayout -cll 1 -bv 0 -li 0 -lv false -bgc .2 .2 .2 -l "Asset Details";
				columnLayout -bgc .4 .4 .4 -rs 5 -adj true;
					separator -h 4 -style "none";
					rowLayout -numberOfColumns 3 -rat 2 "top" 0 -adj 3;
						separator -w 4 -vis 0;
						frameLayout -lv 0 -bgc .4 .4 .4 abxAssetsDetailImgFrmLyt;
							iconTextStaticLabel -style "iconOnly" -h 128 -w 128 -i (`getenv MAYA_PPTOOLS`+"/icons/assetThumb.png") abxAssetUIDetailImg;
							//image -h 128 -w 128 -i (`getenv MAYA_PPTOOLS`+"/icons/assetThumb.png") abxAssetsDetailImg;
							popupMenu;
								menuItem -label "Capture Thumbnail" -c "abxAssetsCaptureThumbnail \"\"" abxAssetsDetailCaptureMI;
							setParent..;
						columnLayout -cat "both" 0 -adj true -rs 2;
							textFieldGrp -cw 1 40 -cw 2 100 -adj 2 -label "Name:" -text  "" -editable false abxAssetsDtlAssetName;
							textFieldGrp -cw 1 40 -cw 2 100 -adj 2 -label "Type:" -text  "" -editable false abxAssetsDtlType;
							rowLayout -numberOfColumns 3 -adj 1 ;
								separator -w 50 -vis 0;
								// reference type: previs, proxy, full, render proxy
								//radioButtonGrp -numberOfRadioButtons 4 -cw5 1 40 40 40 40 -label "" -labelArray4 "previs" "proxy" "full" "render proxy";

								columnLayout -rs 3;
									button -vis 1 -bgc .2 .2 .2 -ebg 0 -h 60 -w 80 -l "reference rig>" -ann "Reference Published Rig" -c "" abxAssetsDetailsRefBtn;
									button -vis 1 -bgc .2 .2 .2 -ebg 0 -h 20 -w 80 -l "import rig>" -ann "Import Published Rig" -c "" abxAssetsDetailsImpBtn;
								setParent..;
								separator -w 3 -vis 0;
							//textFieldGrp -cw 1 80 -cw 2 122 -adj 2 -label "Publish Date:" -text  "" -editable false abxAssetsDtlFPS;
							//floatFieldGrp -en1 0 -en2 0 -cw 1 80 -cw 2 50 -cw 3 50 -nf 2 -label "Start/End:" -v1 0 -v2 0 abxAssetsDtlRange;
							setParent..;
						setParent..;
					setParent..;
				setParent..;
			setParent..;
		//separator -h 5 -style "none";
		/*
		frameLayout -en 1 -cll 1 -bs "etchedIn" -l "Status";
		
		columnLayout -cat "both" 0 -adj true -rs 2;
			
			rowLayout -numberOfColumns 4 ;
				button -vis 1 -h 30 -w 50 -l "GEO" -c "abxAssetsStatusWindowShowUI \"\" \"GEO\" 0" abxAssetsGStatBtn;
				button -vis 1 -h 30 -w 50 -l "SHD" -c "abxAssetsStatusWindowShowUI \"\" \"SHD\" 0" abxAssetsSStatBtn;
				button -vis 1 -h 30 -w 50 -l "RIG"  -c "abxAssetsStatusWindowShowUI \"\" \"RIG\" 0" abxAssetsRStatBtn;
				button -vis 1 -h 30 -w 50 -l "PUB" -c "abxAssetsStatusWindowShowUI  \"\" \"PUB\" 0" abxAssetsPStatBtn;
		*/
		frameLayout -p "abxAssetsDtlColLyt" -cl 0 -cll 1 -bv 0 -li 0 -bgc .27 .27 .27 -l "Status";
			columnLayout -bgc .4 .4 .4 -cat "both" 2 -adj true;
				columnLayout -cat "both" 2 -adj true -rs 2;
					rowLayout -numberOfColumns 3 ;
						text -vis 1 -h 10 -w 95 -l "GEO";
						text -vis 1 -h 10 -w 95 -l "SHD";
						text -vis 1 -h 10 -w 95 -l "RIG";
						//button -vis 1 -h 30 -w 50 -l "PUB" -c "abxAssetsStatusWindowShowUI  \"\" \"PUB\" 0" abxAssetsPStatBtn;
					setParent..;
					rowLayout -numberOfColumns 3 ;
						button -vis 1 -h 25 -w 95 -l "" -c "abxAssetsStatusWindowShowUI \"\" \"GEO\" 0" abxAssetsGStatBtn;
						button -vis 1 -h 25 -w 95 -l "" -c "abxAssetsStatusWindowShowUI \"\" \"SHD\" 0" abxAssetsSStatBtn;
						button -vis 1 -h 25 -w 95 -l ""  -c "abxAssetsStatusWindowShowUI \"\" \"RIG\" 0" abxAssetsRStatBtn;
					setParent..;
				setParent..;
				separator -style "none" -h 2;
			setParent..;		
		setParent..;
		frameLayout -p "abxAssetsDtlColLyt" -cll 1 -li 0 -bv 0 -bgc .27 .27 .27 -l "Latest Modified";
			columnLayout -bgc .4 .4 .4 -cat "both" 2 -adj true;
				columnLayout  -cat "both" 0 -adj true -rs 2;
					separator -style "none" -h 5;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 80 -nc 2 -adj 2;
						text -l "Geo Master:";
						textField -text  "" -editable false abxAssetsDtlGMDate;
					setParent..;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 80 -nc 2 -adj 2;
						text -l "Rig Master:";
						textField -text  "" -editable false abxAssetsDtlRMDate;
					setParent..;
					rowLayout -cal 1 "right" -cat 1 "both" 0 -cw 1 80 -nc 2 -adj 2;
						text -l "Publish:";
						textField -text  "" -editable false abxAssetsDtlPubDate;
					setParent..;
					//separator -style "none" -h 5;
					//textFieldGrp -cw 1 80 -cw 2 100 -adj 2 -label "Geo Master:" -text  "" -editable false abxAssetsDtlGMDate;
					////textFieldGrp -cw 1 80 -cw 2 100 -adj 2 -label "Shd Master:" -text  "" -editable false abxAssetsDtlSMDate;
					//textFieldGrp -cw 1 80 -cw 2 100 -adj 2 -label "Rig Master:" -text  "" -editable false abxAssetsDtlRMDate;
					//textFieldGrp -cw 1 80 -cw 2 100 -adj 2 -label "Publish:" -text  "" -editable false abxAssetsDtlPubDate;
					//separator -style "none" -h 5;
				setParent..;
				separator -style "none" -h 2;
			setParent..;
		setParent..;

		frameLayout -p "abxAssetsDtlColLyt" -cl 1 -cll 1 -bv 0 -li 0 -bgc .27 .27 .27 -l "ActivityLog";
			columnLayout -bgc .4 .4 .4 -cat "both" 2 -adj true;
				columnLayout -cat "both" 2 -adj true -rs 2;
					separator -style "none" -h 5;
					formLayout abxAssetsLogFrmLyt;
						scrollField -bgc .2 .2 .2 -wordWrap false -text "" -editable false abxAssetsLgtScnList;
					setParent..;
					separator -style "none" -h 5;


	setParent abxAssetsDetailsPane;;

	tabLayout -imw 0 -imh 0 -cc "abxAssetsDeptTabChange;" abxAssetsDeptTabLyt;
	/*
	formLayout -e 
		-af abxAssetSpecLyt "left" 0
		-af abxAssetSpecLyt "top" 0
		-af abxAssetSpecLyt "right" 0
		-ac abxAssetSpecLyt "bottom" 0 abxAssetsDeptTabLyt 
		-af abxAssetsDeptTabLyt "left" 0 
		-ap abxAssetsDeptTabLyt "top" 0 50 
		-af abxAssetsDeptTabLyt "right" 0 
		-af abxAssetsDeptTabLyt "bottom" 0 
		abxAssetsDetailsForm;
	*/
	formLayout -e
		-af abxAssetsDtlColLyt "left" 2
		-af abxAssetsDtlColLyt "top" 2
		-af abxAssetsDtlColLyt "right" 2
		-af abxAssetsDtlColLyt "bottom" 2
		abxAssetSpecLyt;

		
		setParent abxAssetsDeptTabLyt;

		// Geo
		formLayout -en 1 -bgc .2 .5 .3 abxAssetsGeoFrmLyt;
			//rowLayout -numberOfColumns 2 -adj 2 -ct2 "both" "both" -rat 2 "both" 0;
				rowLayout -nc 5 -adj 4 abxAssetsGeoListBtnCol;
					button -label "Add" -w 60 -h 20 -bgc .2 .2 .2 -ebg 0 -ann "Adds a Scene File to Rig Dept" -c abxAssetsCreateTakeProc;
					button -label "Open" -w 60 -h 20 -bgc .2 .2 .2 -ebg 0 -c "abxAssetsOpenTake abxAssetsGeoScnList";
					button -label "Save" -w 60 -h 20 -bgc .2 .2 .2 -ebg 0 -c "abxAssetsIncrementalSave \"auto\" 0 \"\";abxAssetsDeptTabChange;";
					separator -w 20 -h 20 -style "none";
					button -en 1 -ann "Master latest work scene" -label "Master" -w 60 -h 20 -bgc .7 .2 .2 -ebg 0 -c "abxAssetsMasterTake abxAssetsGeoScnList";

				setParent ..;	
				frameLayout -bgc .2 .5 .3 -bs "in" -cll 0 -label "TAKE                                    WORK         MASTER" abxAssetsGeoScnListFrme;
					treeView -numberOfButtons 1 -abr true -enableKeys true -idc "abxAssetsTakeListDblClk" -sc "abxAssetsSetActiveTake " -cmc "abxAssetsUpdateTakeMenu" abxAssetsGeoScnList;
					popupMenu abxAssetsGeoPUMenu;
					abxAssetsBuildTakeMenu ("abxAssetsGeoScnList");

					setParent ..;
				setParent ..;


		formLayout -e 
			-af abxAssetsGeoScnListFrme "left" 2
			-af abxAssetsGeoScnListFrme "top" 2
			-ac abxAssetsGeoScnListFrme "bottom" 2 abxAssetsGeoListBtnCol
			-af abxAssetsGeoScnListFrme "right" 2

			-af abxAssetsGeoListBtnCol "left" 2
			-an abxAssetsGeoListBtnCol "top"
			-af abxAssetsGeoListBtnCol "bottom" 2
			-af abxAssetsGeoListBtnCol "right" 2
 
			abxAssetsGeoFrmLyt;
		setParent abxAssetsDeptTabLyt;


		// Rig
		formLayout -en 1 -bgc .3 .5 .6 abxAssetsRigFrmLyt;
			//rowLayout -numberOfColumns 2 -adj 2 -ct2 "both" "both" -rat 2 "both" 0;
				rowLayout -nc 5 -adj 4 abxAssetsRigListBtnCol ;
					button -label "Add" -h 20 -w 60 -bgc .2 .2 .2 -ebg 0 -ann "Adds a Scene File to Rig Dept" -c abxAssetsCreateTakeProc;
					button -label "Open" -h 20 -w 60 -bgc .2 .2 .2 -ebg 0 -c "abxAssetsOpenTake abxAssetsRigScnList";
					button -label "Save" -h 20 -w 60 -bgc .2 .2 .2 -ebg 0 -c "abxAssetsIncrementalSave \"auto\" 0 \"\";abxAssetsDeptTabChange;";
					separator -h 20 -w 20 -style "none";
					button -en 1 -ann "Master latest work scene" -label "Master" -w 60 -h 20 -bgc .7 .2 .2 -ebg 0 -c "abxAssetsMasterTake abxAssetsRigScnList";

				setParent ..;	
				frameLayout -bgc .3 .5 .6 -bs "in" -cll 0 -label "TAKE                                    WORK         MASTER" abxAssetsRigScnListFrme;
					treeView -numberOfButtons 1 -abr true -enableKeys true -idc "abxAssetsTakeListDblClk" -sc "abxAssetsSetActiveTake " -cmc "abxAssetsUpdateTakeMenu" abxAssetsRigScnList;
					popupMenu abxAssetsRigPUMenu;
					abxAssetsBuildTakeMenu ("abxAssetsRigScnList");
					setParent ..;
				setParent ..;					


		formLayout -e 
			-af abxAssetsRigScnListFrme "left" 2
			-af abxAssetsRigScnListFrme "top" 2
			-ac abxAssetsRigScnListFrme "bottom" 2 abxAssetsRigListBtnCol
			-af abxAssetsRigScnListFrme "right" 2

			-af abxAssetsRigListBtnCol "left" 2
			-an abxAssetsRigListBtnCol "top"
 			-af abxAssetsRigListBtnCol "bottom" 2
			-af abxAssetsRigListBtnCol "right" 2

			abxAssetsRigFrmLyt;
		setParent abxAssetsDeptTabLyt;



		formLayout -e 
			-af abxAssetsLgtScnList "left" 3
			-af abxAssetsLgtScnList "top" 3
			-af abxAssetsLgtScnList "bottom" 3
			-af abxAssetsLgtScnList "right" 3
 
			abxAssetsLogFrmLyt;
		setParent abxAssetsDeptTabLyt;
	
		tabLayout -e 
			-tabLabel abxAssetsGeoFrmLyt "GEO Scenes"
			-tabLabel abxAssetsRigFrmLyt "RIG Scenes"
			 abxAssetsDeptTabLyt;

		formLayout -e 
        		-af abxAssetsDetailsPane top 0
        		-af abxAssetsDetailsPane left 0
        		-af abxAssetsDetailsPane bottom 0
        		-af abxAssetsDetailsPane right 0
		abxAssetsDetailsForm;
		paneLayout -e -paneSize 2 100 30 abxAssetsDetailsPane;

}

global proc abxAssetsBuildTakeMenu (string $assetLister) {


	// delete the current popup menu items
	string $popupMenus[] = `treeView -q -pma $assetLister`;
	string $labelMenuItem = ($assetLister+"MenuLabel");
	for ($each in $popupMenus){
		menuItem -parent $each -label ("Dept:"+"TakeName") $labelMenuItem;
		menuItem -parent $each -divider 1;
		menuItem -parent $each -en 1 -label "Open Latest Work Scene" -c ("abxAssetsOpenTake  "+$assetLister);
		menuItem -parent $each -en 1 -label "Incremental Save Work Scene" -c "abxAssetsIncrementalSave 0 \"\" \"auto\" \"\" \"\" \"\" \"\";abxAssetsDeptTabChange;";
		menuItem -parent $each -divider 1;

		menuItem -parent $each -en 0 -label "Master Latest Work Scene" -c ("abxAssetsMasterTake 0 0 "+$assetLister+" \"latest\" \"\"");
		menuItem -parent $each -en 1 -label "Master Latest Work Scene in Background" -c ("abxAssetsMasterTake 1 1 "+$assetLister+" \"latest\" \"Background Mastering Latest Work Version\"");

		menuItem -parent $each -en 0 -label "Open Master File" -c "";
		menuItem -parent $each -divider 1;
		menuItem -parent $each -en 0 -label "Archive and Remove" -c "";
		menuItem -parent $each -label "Pack Scene File" -c ("abxAssetsPackTake "+$assetLister);

	}
}

global proc abxAssetsDeptTabChange () {
	string $assetTab = `tabLayout -q -st abxAssetsListTabLyt`;
	// get the selected shot
	if ($assetTab == "abxAssetsSrcFrmLyt"){
		abxAssetsReloadInScene();
	}
	else{
		if (`treeView -exists abxAssetsTreeView`){
			string $assetHighlighted[];
			if ($assetTab == "abxAssetsLibListForm")
				$assetHighlighted = `treeView -q -si abxAssetsTreeView`;
			else if ($assetTab == "abxAssetsLibForm"){
				$assetHighlighted[0] = ("assets/"+`textFieldGrp -q -text abxAssetsDtlType`+"/"+`textFieldGrp -q -text abxAssetsDtlAssetName`);
			}
			string $tokenBuffer[];
			string $assetPath = $assetHighlighted[0];
			//tokenize $assetPath ":" $tokenBuffer;
			//string $assetName = $tokenBuffer[size($tokenBuffer)-1];

			// refresh the details UI
			//if (size($tokenBuffer)>=3){
				abxAssetsRefreshDetailsUI $assetPath;
				//print ("Setting "+$assetPath+"\n");
			//}
		}
	}
	// if the user selects the "In Scene" tab

}

global proc string abxAssetssGetActiveAssetTab (){
	return `tabLayout -q -st abxAssetsListTabLyt`;
}

global proc string abxAssetsGetActiveDeptTab (){
	string $dept = `tabLayout -q -st abxAssetsDeptTabLyt`;
	if ($dept == "abxAssetsGeoFrmLyt" )
		$dept = "geo";
	else if ($dept == "abxAssetsRigFrmLyt")
		$dept = "rig";
	else if ($dept == "abxAssetsSrcFrmLyt")
		$dept = "";

	return $dept;
}

global proc int abxAssetsTreeViewDblClk (string $itemName){
	return true;
}




global proc int abxAssetsUpdateSceneAssetsMenu (string $itemName) {
	treeView -e -cs abxAssetsAnmScnList;
	treeView -e -si $itemName 1 abxAssetsAnmScnList;
	menuItem -e -label $itemName abxAssetsAnmMenuItemTitle;

	return true;
}

global proc abxAssetsRefreshDetailsUI (string $assetPath){

	string $ppResource = `getenv PP_RESOURCE`;
	
	string $tokenBuffer[];
	string $assetLib = "";
	string $assetType = "";
	string $assetName = "";
	string $assetDept = "";

	tokenize $assetPath "/" $tokenBuffer;
	if (size($tokenBuffer)>=3){
		$assetLib = $tokenBuffer[0];
		$assetType = $tokenBuffer[1];
		$assetName = $tokenBuffer[2];
	}
	else if ($assetPath == ""){
		// check for selected item in tree or list view and set asset path to that.
		//if (`tabLayout -q -st abxAssetsListTabLyt` == "abxAssetsTreeLister"){
			string $selItem = ("assets/"+`textFieldGrp -q -text abxAssetsDtlType`+"/"+`textFieldGrp -q -text abxAssetsDtlAssetName`);
			$assetPath = $selItem;
		//}
		//else if (`tabLayout -q -st abxAssetsListTabLyt` == "abxAssetsTreeView"){
		//	string $selItems[] = `treeView -q -si abxAssetsTreeView`;
		//	$assetPath = $selItems[0];
		//}
	}
	else{
		warning ("Unknown assetPath:"+$assetPath+"\n");
		return;
	}
	
	
	string $assetDetails[] = abxAssetsGetAssetDetails($assetPath);

	string $shotImg = (`workspace -q -rd`+$assetPath+"/"+$assetName+".png");
	if (`filetest -r $shotImg`)
		iconTextStaticLabel -e -image $shotImg -di $shotImg abxAssetUIDetailImg;
		//image -e -image $shotImg abxAssetsDetailImg;
	else 
		iconTextStaticLabel -e -i (`getenv MAYA_PPTOOLS`+"/icons/assetThumb.png") -di (`getenv MAYA_PPTOOLS`+"/icons/assetThumb.png") abxAssetUIDetailImg;
		//image -e -i (`getenv MAYA_PPTOOLS`+"/icons/assetThumb.png") abxAssetsDetailImg;
	
	// get master file details
	menuItem -e -c ("abxAssetsCaptureThumbnail \""+$assetPath+"\"") abxAssetsDetailCaptureMI;
	
	textFieldGrp -e -text $assetName abxAssetsDtlAssetName;
	textFieldGrp -e -text $assetType abxAssetsDtlType;

	button -e -c ("abxAssetsRefAsset(\""+$assetPath+"\",\"\",1)") abxAssetsDetailsRefBtn;
	button -e -c ("abxAssetsImpAsset(\""+$assetPath+"\")") abxAssetsDetailsImpBtn;
	
	string $pubDate = abxAssetsGetMDate((`workspace -q -rd`+$assetPath+"/_publish/"+$assetName+".mb"));
	string $rmDate = abxAssetsGetMDate((`workspace -q -rd`+$assetPath+"/rig/"+$assetName+"_rig.mb"));
	string $gmDate = abxAssetsGetMDate((`workspace -q -rd`+$assetPath+"/geo/"+$assetName+"_geo.mb"));
	// have to get the latest shader version
	//string $latestShader[] = cbxAssetsGetLatestAssetShaderInfo ($assetPath);
	//string $smDate = abxAssetsGetMDate((`workspace -q -rd`+$assetPath+"/shaders/master/"+$latestShader[1]+"/"));
	
	textField -e -text $rmDate abxAssetsDtlRMDate;
	textField -e -text $gmDate abxAssetsDtlGMDate;
	//textFieldGrp -e -text $smDate abxAssetsDtlSMDate;
	textField -e -text $pubDate abxAssetsDtlPubDate;
	
	
	int $pubDateS = abxAssetsGetMDateS((`workspace -q -rd`+$assetPath+"/_publish/"+$assetName+".mb"));
	int $rmDateS = abxAssetsGetMDateS((`workspace -q -rd`+$assetPath+"/rig/"+$assetName+"_rig.mb"));
	int $gmDateS = abxAssetsGetMDateS((`workspace -q -rd`+$assetPath+"/geo/"+$assetName+"_geo.mb"));
	//int $smDateS = abxAssetsGetMDateS((`workspace -q -rd`+$assetPath+"/geo/"+$latestShader[1]+"/"));
	
	if ($pubDateS<$rmDateS || $pubDateS < $gmDateS)
		textField -e -bgc .7 .3 .3 abxAssetsDtlPubDate;
	else 
		textField -e -bgc .27 .27 .27 -ebg 0 abxAssetsDtlPubDate;
	if ($rmDateS<$gmDateS && $gmDate != "Never")
		textField -e -bgc .7 .3 .3 abxAssetsDtlRMDate;
	else 
		textField -e -bgc .27 .27 .27 -ebg 0 abxAssetsDtlRMDate;
		
	
	// show activity log
	string $logData[] = abxAssetsGetAssetLog($assetPath);
	scrollField -e -cl  abxAssetsLgtScnList;
	for ($each in $logData){
		//textScrollList -e -a $each abxAssetsLgtScnList;
		scrollField -e -it $each -ip 0  abxAssetsLgtScnList;
	}
	//button -e -c ("abxAssetsStatusWindowShowUI \""+$assetPath+"\" \"pub\" 0") abxAssetsPStatBtn; 
	//button -e -c ("abxAssetsStatusWindowShowUI \""+$assetPath+"\" \"rig\" 0") abxAssetsRStatBtn; 
	//button -e -c ("abxAssetsStatusWindowShowUI \""+$assetPath+"\" \"geo\" 0") abxAssetsGStatBtn;
	//button -e -c ("abxAssetsStatusWindowShowUI \""+$assetPath+"\" \"shd\" 0") abxAssetsSStatBtn;


	
	//string $assetDetails = `abxAssetsGetAssetDetails $assetPath`;
	if ($assetDetails[1] != ""){
		int $status = $assetDetails[1];
		eval("button -e -label \""+`abxAssetsStatAsLabel $status`+"\" -ebg 0 -bgc "+`abxAssetsStatAsColor $status`+" abxAssetsRStatBtn");
		//eval("button -e  abxAssetsRStatBtn");
	}
	else {
		eval("button -e -label \"\" -bgc .4 .4 .4 abxAssetsRStatBtn");
		//eval("button -e -ebg 0 abxAssetsRStatBtn");
	}
	if ($assetDetails[2] != ""){
		int $status = $assetDetails[2];
		eval("button -e -label \""+`abxAssetsStatAsLabel $status`+"\" -ebg 0 -bgc "+`abxAssetsStatAsColor $status`+" abxAssetsGStatBtn");
		//eval("button -e -ebg 0 abxAssetsGStatBtn");
	}
	else {
		eval("button -e -label \"\" -bgc .4 .4 .4 abxAssetsGStatBtn");
		//eval("button -e -ebg 0 abxAssetsGStatBtn");
	}
	if ($assetDetails[3] != ""){
		int $status = $assetDetails[3];
		eval("button -e -label \""+`abxAssetsStatAsLabel $status`+"\" -ebg 0 -bgc "+`abxAssetsStatAsColor $status`+" abxAssetsSStatBtn");
		//eval("button -e -ebg 0 abxAssetsSStatBtn");
	}
	else {
		eval("button -e -label \"\" -bgc .4 .4 .4 abxAssetsSStatBtn");
		//eval("button -e -ebg 0 abxAssetsSStatBtn");
	}
	

	//textFieldGrp -e -text  $assetDetails[1] -editable false abxAssetsDtlFPS;
	//textFieldGrp -e -text  $assetDetails[0] abxAssetsDtlRes;
	//int $start;
	//int $end;
	//if ($assetDetails[2] != "")
	//	$start = $assetDetails[2];
	//if ($assetDetails[3] != "")
	//	$end = $assetDetails[3];

	//floatFieldGrp -e -v1 $start -v2 $end abxAssetsDtlRange;

	//textFieldGrp -e -text $assetDetails[4] abxAssetsDtlCamScene;
	//textFieldGrp -e -text $assetDetails[5] abxAssetsDtlCamDate;

	treeView -e -ra abxAssetsGeoScnList;
	//treeView -e -ra abxAssetsShdScnList;
	treeView -e -ra abxAssetsRigScnList;

	// get active tab to determine which dept to show
	string $dept = `abxAssetsGetActiveDeptTab`;
	if ($dept == "Log"){
		$dept = "";
	}

	string $filePath = (`workspace -q -rd`+"/"+$assetPath);

	//print ("Refreshing "+$dept+" tab\n");
	string $sorted[] = `abxAssetsGetScenes $assetPath $dept`;
	//print $sorted;
	string $each = "";
	for ($i=0;$i<size($sorted);$i++){

		$each = $sorted[$i];
		if($each != ""){
			if ($dept != ""){
				$dept = capitalizeString($dept);
				//textScrollList -e -append $each abxAssetsAnmScnList;
				treeView -e -addItem $each "" ("abxAssets"+$dept+"ScnList");
				//if ($i%2)
					//treeView -e -lbc $each .15 .15 .15 abxAssetsAnmScnList;
				//else
					//treeView -e -lbc $each .18 .18 .18 abxAssetsAnmScnList;
				treeView -e -selectionColor $each .8 .8 .8 -lbc $each .2 .2 .2 ("abxAssets"+$dept+"ScnList");
				string $takeFilePath = ($filePath+"/"+toupper($dept)+"/work/"+$each);
				string $labelName = abxAssetsGetTakeLabel($each,$takeFilePath);
				treeView -e -font $each "fixedWidthFont" -dl $each $labelName ("abxAssets"+$dept+"ScnList");
				
				
				if (abxLockFileGetStatus($takeFilePath,0)){
					print ("Lock File for "+$takeFilePath+"\n");
					treeView -e -textColor $each .8 .2 .2 ("abxAssets"+$dept+"ScnList");
				}
			}
		}
	}

}

// processes a scene file name into a table of data for nicer lists
global proc string abxAssetsGetTakeLabel (string $takeName, string $filePath){
	//sample take name Flynn_geo_v025.mb
	//string $noExt = `basenameEx $takeName`;
	//string $tokenBuffer[];
	//tokenize $noExt "_" $tokenBuffer;
	//string $assetName = $tokenBuffer[0];
	//$dept = $tokenBuffer[1];
	//string $takeString = "default";
//
	//else if (size($tokenBuffer) == 4)
	//	$takeString = $tokenBuffer[3];



	return ($takeName);
}

global proc int abxAssetsUpdateTakeMenu (string $itemName) {
	$dept = `abxAssetsGetActiveDeptTab`;
	$dept = capitalizeString($dept);
	treeView -e -cs ("abxAssets"+$dept+"ScnList");
	treeView -e -si $itemName 1 ("abxAssets"+$dept+"ScnList");
	print ("abxAssets"+$dept+"ScnListMenuLabel\n");
	menuItem -e -label $itemName ("abxAssets"+$dept+"ScnListMenuLabel");
	abxAssetsSetActiveTake($itemName,1);
	return true;

}

global proc int abxAssetsSetActiveTake (string $itemName, int $state) {
	print ($state+"\n");
	$dept = `abxAssetsGetActiveDeptTab`;
	$dept = capitalizeString($dept);
	$treeView = ("abxAssets"+$dept+"ScnList");	
	if ($state == 1){
		treeView -e -textColor $itemName .2 .2 .2 $treeView;
	}
	else{
		treeView -e -textColor $itemName .8 .8 .8 $treeView;
	}

	return 1;
}

global proc int abxAssetsTakeListDblClk (string $sceneName){
	$dept = `abxAssetsGetActiveDeptTab`;
	$dept = capitalizeString($dept);
	abxAssetsOpenTake ("abxAssets"+$dept+"ScnList");
	abxAssetsRefreshDetailsUI("");
	return 1;
}

/*
global proc abxAssetsCreateTakeProc (){

	string $result = `layoutDialog -title "New Scene / Take" -ui "abxAssetsNewTakeDialog"`;
	print ($result+"\n");
	if ($result != "Cancel") {
		string $text = "";
		string $tokenBuffer[];
		tokenize $result ":" $tokenBuffer;
		if (size($tokenBuffer) == 2)
			$text = $tokenBuffer[1];

		string $mode = $tokenBuffer[0];
		
		//if ($result == "Make Alternate Scene/Take") $text = `promptDialog -query -text`;
		//string $tokenBuffer[];
	
		//$text = tolower($text);
		clear ($tokenBuffer);

		// turn underscores into interCaps
		tokenize $text "_" $tokenBuffer;
		if (size($tokenBuffer)> 1){
			$text = $tokenBuffer[0];
			int $i = 0;
			for ($i=1;$i<size($tokenBuffer);$i++){
				int $l = size($tokenBuffer[$i]);
				string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
				string $rest = `substring $tokenBuffer[$i] 2 $l`;
				$text += ($capLetter+$rest);
			}
		}

		// turn spaces into intercaps
		tokenize $text " " $tokenBuffer;
		if (size($tokenBuffer)> 1){
			$text = $tokenBuffer[0];
			int $i = 0;
			for ($i=1;$i<size($tokenBuffer);$i++){
				int $l = size($tokenBuffer[$i]);
				string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
				string $rest = `substring $tokenBuffer[$i] 2 $l`;
				$text += ($capLetter+$rest);
			}
		}
		string $shotFolder = `abxAssetsGetActiveShotFolder`;

		// get active tab to determine which dept to show
		string $dept = `abxAssetsGetActiveDeptTab`;

		// string $takeSceneNames[] = `textScrollList -q -ai $sourceList`;

		// get a list of take names from this for checking for duplicate names
		


		string $shotsPath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/");

		string $foundShotName[];
		if ($shotFolder == "_PREVIS") {
			$foundShotName = `treeView -q -si abxPrevisList`;
		}
		else{
			$foundShotName = `treeView -q -si abxAssetsList`;
		}
		evalEcho("abxAssetsCreateTake \""+$foundShotName[0]+"\" \""+$dept+"\" \""+$text+"\" \""+$mode+"\"");

	}
}


global proc abxAssetsCreateTake (string $assetPath, string $dept, string $takeName, string $mode){

	string $assetFullPath = (`workspace -q -rd`+"/"+$assetPath+"/");
	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetName = $tokenBuffer[2];
	string $extension = "ma";
	if ($dept == "geo")
		$extension = "mb";

	//$result = `confirmDialog -title "Create Take" -message "Save this scene as new take?" -button "Save This As" -button "New Scene File" -button "Cancel" -defaultButton "Save This As" -cancelButton "Cancel" -dismissString "Cancel"`;
	$result = $mode;
	if ($result == "SaveAs" || $result == "New"){
		string $takeFilePath = "";
		if ($takeName != "")
			$takeFilePath = ($assetFullPath+"/"+toupper($dept)+"/work/"+$assetName+"_"+$dept+"_"+$takeName+"_v001."+$extension);
		else 
			$takeFilePath = ($assetFullPath+"/"+toupper($dept)+"/work/"+$assetName+"_"+$dept+"_v001."+$extension);
		string $cmd = "";

		if ($result == "New"){	
			//$cmd = ("saveChanges(\"file -f -new\");");
			if (`exists ppDoNewScene`){
				if ($dept == "anm" || $dept == "pre"){
					$cmd = ("ppDoNewScene \"anm\";");
				}
				else if ($dept == "lgt"){
					$cmd = ("ppDoNewScene \"lgt\";");
				}
			}	
			else{
				$cmd = ("saveChanges(\"abxLockFileCheckOut(\\\"\\\");file -f -new;\");");
			}
		}
		abxLockFileCheckOut("");
		$cmd += ("file -rn \""+$takeFilePath+"\";");
		$cmd += ("abxAssetsIncrementalSave 0 \"\" \"auto\" \"\" \"\" \"\" \"\";");
		$cmd += ("abxAssetsRefreshDetailsUI \""+$shotName+"\";");
		//$cmd += ("string $shotName[] = `treeView -q -si abxAssetsList`;abxAssetsRefreshDetailsUI $shotName[0];");
		evalEcho ($cmd);


				// set the shot frame range if it exists in the db already
		string $shotDetails[] = abxAssetsGetShotDetails($shotName, $shotFolder);
		string $filePath = (`workspace -q -rd`+"scenes/"+$shotFolder+"/"+$shotName);

		print ("FilePath="+$filePath+"   shotName="+$shotName+"\n");
		if ($shotName != "" && `filetest -d ($filePath+"/CAM/")`){
			int $start = 0;
			int $end = 0;

			if ($shotFolder != "_PREVIS"){
				$fail = catch(python("activeShot = R.Shot.getFromPath('"+$filePath+"')"));
				$fail = catch($start = python("activeShot.startframe"));
				$fail = catch($end = python("activeShot.endframe"));

				if ($fail)
					print("rainbow request failed for frame range request. falling back to shot_details.txt");
			}

			if ($start == 0 && $shotDetails[2] != "")
				$start = $shotDetails[2];
			if ($end == 0 && $shotDetails[3] != "")
				$end = $shotDetails[3];
			if ($start == 0 && $end == 0){
				
			}
			else{
				playbackOptions -e -min $start -max $end;
				playbackOptions -e -ast $start -aet $end; 
			}
		}
		string $target = "Shot";
		string $targetPath = $takeFilePath;
		string $event = "created" ;
		string $message = ("Take Created: "+`basenameEx $takeFilePath`);
		evalEcho("abxAssetsSendNotification(\""+$target+"\",\""+$targetPath+"\", \""+$event+"\", \""+$message+"\", 0)");
	}
	else {
		print ("New Take Cancelled\n");
	}
}
*/

global proc string[] abxAssetsGetScenes (string $assetPath, string $dept) {

	//string $assetFolder = `abxAssetsGetActiveShotFolder`;
	string $assetFolder = (`workspace -q -rd`);
	
	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	$assetName = $tokenBuffer[2];//`abxAssetsGetShortName $assetPath`;

	string $assetPrefix = ($assetName+"_"+$dept+"_");
	//print ("Getting Folder: "+$assetFolder+"/"+$assetPath+"/"+tolower($dept)+"/work/\n");
	string $scenesPath = ($assetFolder+$assetPath+"/"+tolower($dept)+"/work/");
	string $scenesFolder[] = `getFileList -fs ($assetPrefix+"*") -folder $scenesPath`;
	//print ($assetPath+$assetPath+"/"+toupper($dept)+"/work/\n");
	//print $scenesFolder;

	string $sorted[] = sort($scenesFolder);

	string $foundTakeName[];
	string $foundExtension[];
	int $highestVersionInt[];
	string $highestVersion[];

	string $foundTakes[];
	string $foundVersions[];
	
	for ($each in $sorted){

		if (`gmatch $each ($assetPrefix+"*")`){

			string $nameOnly = `basenameEx $each`;
			string $extension = `fileExtension $each`;
			int $prefixSize = size($assetPrefix)+1;
			int $nameOnlySize = size($nameOnly);
			string $noAssetName = `substring $nameOnly $prefixSize $nameOnlySize`;
			int $noAssetNameSize = size($noAssetName);

			string $tokenBuffer[];
			tokenize $noAssetName "_" $tokenBuffer;
			string $version = $tokenBuffer[size($tokenBuffer)-1];

			int $takeNameSize = $noAssetNameSize - size($version) - 1;
			string $takeName = `substring $noAssetName 1 $takeNameSize`;
			if (size($tokenBuffer) == 1){
				$takeName="default";
				$takeNameSize = 7;
			}
			//print ($takeName+":"+$version+"\n");
			if (!`stringArrayContains $takeName $foundTakes`){
				$foundTakes[size($foundTakes)] = $takeName;
				if ($takeName != "default"){
					$foundVersions[size($foundVersions)] = abxAssetsGetLatestWorkVersion($assetPath, $dept, $takeName, "work",0);
					//print ("abxAssetsGetLatestWorkVersion(\""+$assetPath+"\", "+$dept+", \""+$takeName+"\", \"work\")");
				}
				else {
					$foundVersions[size($foundVersions)] = abxAssetsGetLatestWorkVersion($assetPath, $dept, "", "work",0);
					//print ("abxAssetsGetLatestWorkVersion(\""+$assetPath+"\", "+$dept+", \"\", \"work\")");
				}
				//print ("FoundVersion = "+$foundVersions[size($foundVersions)-1]+"\n");	
			}


		}
		//print $foundTakes;
	}

	string $results[];
	int $defaultTake = -1;
	//print ("sizeOfTakes"+size($foundTakes)+"\n");
	for ($i=0;$i<size($foundTakes);$i++){
		if ($foundTakes[$i] != "default"){
			
			$results[$i] = ($assetPrefix+$foundTakes[$i]+"_"+$foundVersions[$i]+".mb");
			if (!`filetest -r ($scenesPath+$results[$i])`)
				$results[$i] = ($assetPrefix+$foundTakes[$i]+"_"+$foundVersions[$i]+".ma");
			//print ("foundTakeName="+$foundTakes[$i]+" highestVersion="+$foundVersions[$i]+"\n");
			//$results[$i] = ($assetPrefix+$foundTakeName[$i]+"_"+$highestVersion[$i]+".ma");
			//print ("foundTakeName="+$foundTakeName[$i]+" highestVersion="+$highestVersion[$i]+"\n");
		}
		else {
			$defaultTake = $i;
			$results[$i] = ($assetPrefix+$foundVersions[$i]+".mb");
			if (!`filetest -r ($scenesPath+$results[$i])`)
				$results[$i] = ($assetPrefix+$foundVersions[$i]+".ma");
			//print ("foundTakeName="+$foundTakes[$i]+" highestVersion="+$foundVersions[$i]+"\n");
			//$results[$i] = ($assetPrefix+$highestVersion[$i]+".ma");
			//print ("noTake. foundTakeName="+$foundTakeName[$i]+" highestVersion="+$highestVersion[$i]+"\n");
		}
	}

	// make the default take the first item in the array
	if ($defaultTake > -1){
		string $defaultTakeName = $results[$defaultTake];
		stringArrayRemoveAtIndex($defaultTake ,$results);
		stringArrayInsertAtIndex(0, $results, $defaultTakeName);
	}

	return $results;

}

























// checks for the latest rig file and commits
// segment: previs | prod | proxy
global proc abxAssetsPublish(string $assetPath, int $force, string $note){

	// if the asset is of type "model"
	string $assetLib;
	string $assetType;
	string $assetName;

	string $tokenBuffer[];

	// check for a rig master file for the specified asset
	tokenize $assetPath "/" $tokenBuffer;
	if (size($tokenBuffer) == 3){
		$assetLib = $tokenBuffer[0];
		$assetType = $tokenBuffer[1];
		$assetName = $tokenBuffer[2];

		$rigMasterFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/rig/"+$assetName+"_rig.mb");
		if (!`filetest -r $rigMasterFile`){
			$rigMasterFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/rig/"+$assetName+"_rig.ma");
		}
		$publishMasterFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+".mb");
		$publishMasterFileTemp = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/TMP"+$assetName+".mb");
		$publishPrevisFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+"_previs.mb");
		$publishPrevisFileTemp = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/TMP"+$assetName+"_previs.mb");
		$publishProxyFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+"_proxy.mb");
		$publishProxyFileTemp = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/TMP"+$assetName+"_proxy.mb");

		if (`filetest -r $rigMasterFile`){
			if (`file -q -sn` == $rigMasterFile){
			
			}
			else {
				// if rig master exists then open it
				$result = "OK";
				if (!$force)
					$result = `confirmDialog -title "abxAssets Confirm" -message ("Must Open "+$assetName+" Rig Master to Continue") -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
				if ($result == "OK"){
					abxAssetsOpenMasterScene(($assetPath+"/rig"),0);
				
				}
				else {
					warning ("User Cancelled Publish");
					return;
				}
			}
		}
		else {
			$result = `confirmDialog -title "abxAssets Error" -message ($assetName+" Rig Master File Not Found") -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
			return;
		}

		// save the publish file
		evalEcho("file -rename \""+$publishMasterFileTemp+"\"");
		evalEcho("file -save");

		string $result = "Skip";
		if (!$force)
			$result = `promptDialog -title "Asset Manager Notes: Publish Scene" -message "Describe what you changed:                                                                            " -button "OK" -button "Skip"  -defaultButton "OK" -cancelButton "Skip" -dismissString "Skip"`;
		if ($result == "OK") {
			$note = `promptDialog -query -text`;
		}

		// log the publish event
		evalEcho("abxAssetsWriteAssetLog \""+$assetPath+"\" \"rig publish\" \"---\" \""+$note+"\"");

		if (`file -q -sn` == $publishMasterFileTemp){
			if (`filetest -w $publishMasterFile`){
				// Archive publish file
			}
			evalEcho("sysFile -move \""+$publishMasterFile+"\" \""+$publishMasterFileTemp+"\"");
			evalEcho("file -rename \""+$publishMasterFile+"\"");
		}
		
		// make a proxy if the geo_proxyRefSet exists
		if (`objExists "geo_lowProxySet"`){

			select -clear;
			select `ls -type mesh`;
			
			$keep = `sets -q geo_lowProxySet`;
			$keepShapes = `listRelatives -shapes $keep`;
			for ($each in $keep){
				catch(eval("setAttr \""+$each+".visibility\" 1;"));
			}
			
			for ($each in $keepShapes){
				catch(eval("setAttr \""+$each+".visibility\" 1;"));
			}

			select -deselect $keep;
			select -deselect $keepShapes;
			delete;

			select geo_lowProxySet;
			if (`objExists BODYShape`) select -add BODYShape;
			if (`objExists MOVERShape`) select -add MOVERShape;
			string $setsToExport[] = {"SETS","KEYABLE","ALLBODY","FACE","L_FINGERS","R_FINGERS","RES","HIGH","LOW","MED","UBER","SETUP","BND_JNTS"};
			for ($each in $setsToExport){
				if (`objExists $each`) select -add -noExpand $each;
			}
			if (`objExists "KEYABLE"`) {
				$controls = `sets -q KEYABLE`;
				$shapes = `listRelatives -shapes $controls`;
				select -add $controls;
				select -add $shapes;
			}
			$controls = `ls "*CTRL*"`;
			select -add $controls;

			$shapes = `listRelatives -shapes $controls`;
			select -add $shapes;

			file -force -type "mayaBinary" -options "v=0" -es -ch true -chn true -con true -exp true -sh true $publishProxyFile;
			select -clear;
		}
		file -mf false;
		// if the asset is of type "render"
		// open the latest master file 
		if (`objExists "geo_lowProxySet"`)
			$result = `confirmDialog -title "abxAssets Confirm" -message ($assetName+" Successfully Published.") -button "New Scene" -button "Open Work" -defaultButton "New Scene" -cancelButton "New Scene" -dismissString "New Scene"`;
		else
			$result = `confirmDialog -title "abxAssets Confirm" -message ($assetName+" Successfully Published.") -button "New Scene" -button "Open Work" -button "Inspect Publish" -defaultButton "New Scene" -cancelButton "New Scene" -dismissString "New Scene"`;

		if ($result == "Open Work"){
			abxAssetsOpenWorkScene($assetPath, "latest", true);
		}
		else if ($result == "New Scene"){
			if (`exists ppDoNewScene`)
				ppDoNewScene "empty";
			else 
				file -f -new;
		}
		else if ($result == "Inspect Publish"){
			headsUpMessage -time 3600  "THIS IS THE PUBLISHED RIG MASTER SCENE. DO NOT MODIFY!";
			file -mf false;
		}

	}
	else {
		error("Unknown asset path:"+$assetPath+" Cannot publish");
		return;
	}
}




























// interdepartmental proc for incrementally saving the file
// file format is /assets/type/<name>/<dept>/work/<name>_<dept>_w<version>.ma
global proc abxAssetsIncrementalSave(string $assetPath, int $force, string $note){

	string $sceneFileName = "";
	string $assetTypeGuess = "";
	string $assetNameGuess = "";
	string $deptGuess = "";
	string $subDeptGuess = "";
	string $assetLibGuess = "";
	string $ppTools = `getenv MAYA_PPTOOLS`;

	// need to remove namespaces sooner rather than during publish to make sure names only change once
	// remove all namespaces
	 //abxAssetsRemoveAllNamespaces;	

	// turn off shading and hw texturing
	$panels = `getPanel -type modelPanel`;
	for ($each in $panels){
    	modelEditor -e -da "wireframe" -displayTextures false $each;
	}

		// file save check procedures
	// checks for name clashes on file save
	int $failure = 0;
	if (`exists checkNameClash`==0) 
		evalEcho ("source \""+$ppTools+"/scripts/Toolbox/Misc/checkNameClash.mel\"");
	if (`exists checkNameClash`) {
		print ("Running Check Name Clash\n");
		$failure = catch(`checkNameClash`);
	}
	if ($failure == 0){

		// get the scene name
		string $currentScene = `file -q -sn`;

		// check the frame rate for skylanders
		string $prjDetails[] = abxProjectGetShotDetails(`workspace -q -rd`);
		if (`fpsNumeric` != $prjDetails[1]){
			$result = `confirmDialog -title "abxAssets Confirm" -message ("File is not at project default Frame Range of "+$prjDetails[1]+". Auto Convert it now?") -button "Convert" -button "Skip" -defaultButton "Convert" -cancelButton "Convert" -dismissString "Convert"`;
			if ($result == "Convert"){
				abxAssetsSetFrameRate ($prjDetails[1]);
			}
		}

		// tokenize the scene name for automatic incremental save
		string $tokenBuffer[];
		tokenize $currentScene "/" $tokenBuffer;

		$sceneFileName = $tokenBuffer[size($tokenBuffer)-1];

		int $latestFoundVersion = -1;

		if (size($tokenBuffer) > 1){
			$subDeptGuess = $tokenBuffer[size($tokenBuffer)-2];
			if (size($tokenBuffer) > 2 ) {
				$deptGuess = $tokenBuffer[size($tokenBuffer)-3];
				if (size($tokenBuffer) > 3 ) {
					$assetNameGuess = $tokenBuffer[size($tokenBuffer)-4];
					if (size($tokenBuffer) > 4 ){
						$assetTypeGuess = $tokenBuffer[size($tokenBuffer)-5];
						if (size($tokenBuffer) > 5){
							$assetLibGuess =  $tokenBuffer[size($tokenBuffer)-6];
						}
					}
				}
			}
		}

		// automatic incremental save, guesses based on your current scene where to incrementally save it
		if ($assetPath != "auto"){
		
			tokenize $assetPath "/" $tokenBuffer;
			if (size($tokenBuffer)== 4){
				$assetLib = $tokenBuffer[0];
				$assetType = $tokenBuffer[1];
				$assetName = $tokenBuffer[2];
				$assetDept = $tokenBuffer[3];
				string $result;
				print ("Testing "+$assetPath+"\n");
				if ($assetLib != $assetLibGuess || $assetType != $assetTypeGuess || $assetName != $assetNameGuess || $assetDept != $deptGuess){
					string $currentScn = "";
					$currentScn = `file -q -sn -shn`;
					//print ("currentScn=|"+$currentScn+"|\n");
					if ($currentScn == "" || $currentScn == " ") 
						$currentScn = "untitled";
					$result = "Force";
					if (!$force){
						$result = `confirmDialog -title "abxAssets Confirm" -message ("This File doesn't appear to belong here. Force Save \""+$currentScn+"\" into the \""+$assetName+"\" "+$assetDept+"? Are you sure?") -button "Force" -button "No" -defaultButton "No" -cancelButton "No" -dismissString "No"`;
					}
					if ($result == "Force"){
						print ("Forcing File Save\n");
					}
					else {
						return;
					}
					$assetLibGuess = $assetLib;
					$assetTypeGuess = $assetType;
					$assetNameGuess = $assetName;
					$deptGuess = $assetDept;
					$subDeptGuess = "work";
				}
				
			}
			else {
				error ("Unrecognized Asset Path:"+$assetPath);
			}		
		}


		string $pathGuess = "";
		print ($assetLibGuess+"\n");
		if ($assetLibGuess == "assets"){
			 $pathGuess = (`workspace -q -rd`+$assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess+"/"+$deptGuess+"/"+$subDeptGuess+"/");
			print ($pathGuess+"\n");
		}

		// test to see if we guessed the correct asset path
		if (`filetest -d $pathGuess`){
			string $workVersion = abxAssetsGetLatestWorkVersion(($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess),$deptGuess,"","work",0);
			print ($workVersion+"\n");
			if($workVersion == ""){
				$workVersion = "v000";
			}

			if ($workVersion != ""){



				string $numOnly = substring($workVersion,2,size($workVersion));
				int $wVersionInt = int($numOnly);
				$wVersionInt = $wVersionInt + 1;
				string $newWorkVersion = "";
				if ($wVersionInt > 99){
					$newWorkVersion = ("v"+$wVersionInt);
				}
				else if ($wVersionInt > 9){
					$newWorkVersion = ("v0"+$wVersionInt);
				}
				else {
					$newWorkVersion = ("v00"+$wVersionInt);
				}

				if ($deptGuess == "rig"){
					if (!`objExists ROOT`)
						createNode -ss -name "ROOT" transform;
					// add/update the assetPath to the shading group attr
					if (!`attributeExists "assetPath" "ROOT"`)
						addAttr -longName "assetPath" -dt "string" "ROOT";
					setAttr -type "string" ("ROOT.assetPath") ($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess);
					if (!`attributeExists "assetRigUser" "ROOT"`)
						addAttr -longName "assetRigUser" -dt "string" "ROOT";
					setAttr -type "string" ("ROOT.assetRigUser") `getenv USER`;
					if (!`attributeExists "assetRigVersion" "ROOT"`)
						addAttr -longName "assetRigVersion" -dt "string" "ROOT";
					setAttr -type "string" ("ROOT.assetRigVersion") $newWorkVersion;

					abxAssetsVraySubDCheck;
				}

				if ($deptGuess == "geo"){
					abxAssetsNamespaceToRnp;
					abxAssetsVraySubDCheck;
					//abxAssetsConformAllShapeNames;
					abxAssetsMakeTexturesLocal ($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess);

					// remove isolate selected sets

					//abxAssetsRemoveIntermediateShapes();
					abxAssetsRemoveIsolateSelected();
					abxAssetsFaceAssignmentCheck(0);
					initialShadingGroupCheck(0);


				}

				// remove fur plugin if its not in use
				if (`pluginInfo -q  -loaded Fur`){
					if (size(`ls -type FurFeedback`)==0){
						if (`objExists defaultFurGlobals`){
							delete defaultFurGlobals;
						}
					}
				}

				// remove shave and arnold if its skylanders2013
				if (`workspace -q -rd` == "M:/Skylanders2013_PP10102/3D/Skylanders2013_maya/"){
					string $pluginsToDel[] = {"mtoa","shaveNode"};
					for ($each in $pluginsToDel){
						if (evalEcho("pluginInfo -q -loaded "+$each)){
							string $pluginTypes[] = `pluginInfo -q -dependNode $each`;
							string $lsCmd = "ls ";
							for ($every in $pluginTypes){
								$lsCmd += ("-type "+$every+" ");
							}
							string $pluginNodes[] = evalEcho($lsCmd);
							if (size($pluginNodes)>0){
								$result = `confirmDialog -title "Plugin Police" -message ("Nodes from the plugin: "+$each+" were found. These will be forcibly deleted before saving.") -button "Remove Nodes" -button "Leave" -button "Abort Save" -defaultButton "Remove Nodes" -cancelButton "Abort Save" -dismissString "Abort Save"`;
								if ($result == "Remove Nodes"){
									for ($every in $pluginNodes){
										catch(eval("lockNode -l 0 "+$every));
										catch(eval("delete "+$every));
									}
								}
								else if ($result == "Abort Save"){
									error ("User Aborted Save due to questionable plugin nodes in scene.");
								}
							}
						}
					}
				}

				// save as ascii if its anything but geo files
				string $filePath = ($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess+"/"+$deptGuess+"/"+$subDeptGuess+"/"+$assetNameGuess+"_"+$deptGuess+"_"+$newWorkVersion+".ma");
				// if its geo save as binary file format
				if ($deptGuess == "geo"){
					$filePath = ($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess+"/"+$deptGuess+"/"+$subDeptGuess+"/"+$assetNameGuess+"_"+$deptGuess+"_"+$newWorkVersion+".mb");
				}
				evalEcho("file -rn \""+$filePath+"\";");
				if ($deptGuess == "geo"){
					evalEcho("file -f -save  -options \"v=0\" -type \"mayaBinary\"");
				}
				else{
					evalEcho("file -f -save  -options \"v=0\" -type \"mayaAscii\"");
				}

				// NEW UPDATE

				// if no note was specified as an argument then we must prompt the user for a note and status update
				if ($note == ""){
					if (!$force){
						$note = abxAssetsStatusWindowShowUI (($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess), $deptGuess, 1);

						// warn them again if they don't leave a note
						if ($note == "Cancel" || $note == ""){
							$note = abxAssetsStatusWindowShowUI (($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess), $deptGuess, 2);
						}
					}
				}
				/* OLD STATUS PROMPT
				string $result = "";
				//if ($note == ""){
					$result = `promptDialog -title "Asset Manager Notes: New Work Scene Version" -message "Describe what you changed:                                                                            " -text $note -button "OK" -button "Skip"  -defaultButton "OK" -cancelButton "Skip" -dismissString "Skip"`;
				//}
				if ($result == "OK") {
					$note = `promptDialog -query -text`;
				}
				*/
				// log the work update event
				evalEcho("abxAssetsWriteAssetLog \""+$assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess+"\" \""+$deptGuess+" work\" \""+$newWorkVersion+"\" \""+$note+"\"");
			}
			else {
				warning ("Could not Guess where to save this. Please Save using Asset Manager");
			}
		}
		else {
			warning ("Could not Guess where to save this. Please Save using Asset Manager");
		}
	}
	else {
		confirmDialog -title "Asset Manager" -message ("File Not Saved") -button "OK" -defaultButton "OK" -cancelButton "OK" -dismissString "OK";
		error ("User Aborted Script");
	}
}







































// interdepartmental proc for saving the latest master file
global proc abxAssetsMaster(string $assetPath, int $force, string $note){

	string $sceneFileName = "";
	string $assetTypeGuess = "";
	string $assetNameGuess = "";
	string $deptGuess = "";
	string $subDeptGuess = "";
	string $assetLibGuess = "";

	// get the scene name
	string $currentScene = `file -q -sn`;

	// tokenize the scene name for automatic incremental save
	string $tokenBuffer[];
	tokenize $currentScene "/" $tokenBuffer;
	$sceneFileName = $tokenBuffer[size($tokenBuffer)-1];

	// if the assetPath is auto then try and guess what to master based on the file name
	if (size($tokenBuffer) > 1) $subDeptGuess = $tokenBuffer[size($tokenBuffer)-2];
	if (size($tokenBuffer) > 2) $deptGuess = $tokenBuffer[size($tokenBuffer)-3];
	if (size($tokenBuffer) > 3) $assetNameGuess = $tokenBuffer[size($tokenBuffer)-4];
	if (size($tokenBuffer) > 4) $assetTypeGuess = $tokenBuffer[size($tokenBuffer)-5];
	if (size($tokenBuffer) > 5) $assetLibGuess = $tokenBuffer[size($tokenBuffer)-6];	

	// else master based on the return asset
	// automatic incremental save, guesses based on your current scene where to incrementally save it
	if ($assetPath != "auto")  {
		tokenize $assetPath "/" $tokenBuffer;
		if (size($tokenBuffer)== 4){
			$assetLib = $tokenBuffer[0];
			$assetType = $tokenBuffer[1];
			$assetName = $tokenBuffer[2];
			$assetDept = $tokenBuffer[3];
			string $result;
			if ($assetLib != $assetLibGuess || $assetType != $assetTypeGuess || $assetName != $assetNameGuess){
				$result = "Yes";// `confirmDialog -title "Confirm" -message "Save this Open Scene into the asset? Are you sure?" -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
			}
			if ($result == "Yes"){
				$assetLibGuess = $assetLib;
				$assetTypeGuess = $assetType;
				$assetNameGuess = $assetName;
				$deptGuess = $assetDept;
				$subDeptGuess = "work";
			}
		}
		else {
			error ("Unrecognized Asset Path:"+$assetPath);
		}
	}

	string $assetDirGuess = (`workspace -q -rd`+$assetLibGuess + "/" + $assetTypeGuess + "/" + $assetNameGuess + "/" + $deptGuess);
	string $workDirGuess = ($assetDirGuess + "/" + $subDeptGuess);

	string $workVersion = abxAssetsGetLatestWorkVersion(($assetLibGuess + "/" + $assetTypeGuess + "/" + $assetNameGuess), $deptGuess, "", "work",0); 

	string $filePath = ($workDirGuess +"/"+$assetNameGuess+"_"+$deptGuess+"_"+$workVersion+".mb");
	if (!`filetest -r $filePath`){
		$filePath = ($workDirGuess +"/"+$assetNameGuess+"_"+$deptGuess+"_"+$workVersion+".ma");
	}
	string $masterFilePath = ($assetDirGuess +"/"+$assetNameGuess+"_"+$deptGuess+".mb");
	string $tempMasterFilePath = ($assetDirGuess +"/TMP"+$assetNameGuess+"_"+$deptGuess+".mb");

	// if the latest workshop is already open 
	print ("// currentScene: "+$currentScene+" //\n");
	print ("// filePath: "+$filePath+" //\n");

	if ($currentScene != $filePath)  {
		// prompt the user to open the latest workshop
		$result = "OK";
		if (!$force)
			$result = `confirmDialog -title "abxAssets Confirm" -message "You must open the latest work scene to perform this operation.  " -button "Open" -button "Cancel" -defaultButton "Open" -cancelButton "Cancel" -dismissString "Cancel"`;
			if ($result == "Open")  {
				// open latest workshop file
				abxAssetsOpenWorkScene(($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess+"/"+$deptGuess), "", $force);
				$sceneFileName = $filePath;
				$currentScene = $filePath;
				file -mf false;
			}
			else {
				warning "User Cancelled Mastering Process";
				return;
			}
	}

	if ($currentScene == $filePath)  {
		// CB - save shaders and create/update attrs on geo to reflect latest names and version
		//$result = "Yes";
		//if (!cbxShadersNeedUpdating())
		//	$result = `confirmDialog -title "abxAssets Confirm" -message "Update Shaders Version?" -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;

		if ($deptGuess == "geo")  {
			/*
			$result = `confirmDialog -title "abxAssets Confirm" -message "Update Shaders Version?" -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
			if ($result == "Yes")  {
				// save another work version, so shader version is unique, I guess
				// should really only do this if the scene has been changed, or if the current version has shaders defined for it
				abxAssetsIncrementalSave("auto", false, "Updating work version for shaders");
				$currentScene = `file -q -sn`;
				$sceneFileName = `file -q -shn -sn`;
				$filePath = `file -q -sn`;
				$workVersion = abxAssetsGetLatestWorkVersion(($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess),$deptGuess,"","work",0);

				print("Saving shaders and updating work version to " + $workVersion + "\n");
				print("abxAssetsExportAssetShaders \""+$assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess+"\" \n");
				// disabled because we don't use this tool at the moment
				//abxAssetsExportAssetShaders($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess);

				//set the shading group assigned to geometry
				//cbxUpdateShadersVersion($assetDirGuess + "/shaders/" + $assetNameGuess + "_" + $workVersion, $workVersion);

				// log the shader mastering
				evalEcho("abxAssetsWriteAssetLog \""+$assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess+"\" \"shd master\" \""+$workVersion+"\" \""+$note+"\"");

				file -save;
				file -mf false;
			}
			*/
		}

		// if the file needs saving
		if (`file -q -mf`){
			// incrementally save the workshop
			abxAssetsIncrementalSave("auto", false, "");
			$currentScene = `file -q -sn`;
			$sceneFileName = `file -q -shn -sn`;
			$filePath = `file -q -sn`;
			$workVersion = abxAssetsGetLatestWorkVersion(($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess),$deptGuess,"","work",0);
			print("Saved new work version: " + $workVersion + "\n");
		}
	}

	// save the file as a temp file first
	evalEcho("file -rename \""+$tempMasterFilePath+"\"");

	////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////
	// MASTERING PROCEDURES ////////////////////////////////////////// //////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////

	select -clear;		

	// if dept is geo
	if ($deptGuess == "geo"){

		abxAssetsFixStoryNeonRefs();

		// delete any loaded or unloaded references
		string $keepFilter = "DECOR_*";
		abxAssetsRemoveAllReferences($keepFilter);

		abxAssetsImportAllReferences;

		abxDeleteAllRN;

		// remove items in the deleteSet
		string $deleteSets[] = `ls -type objectSet -r 1 "*deleteSet"`;
		for ($every in $deleteSets){
			lockNode -l 0 $every;
			$members = `sets -q $every`;
			for ($m in $members){
				catch(`lockNode -l 0 $m`);
				catch(`select -ne $m`);
				if (size(`ls -sl`)>0)
					catch(`lockNode -l 0`);
				delete `ls -sl`;
				if (`objExists $m`){
					catch(`delete $m`);
				}
			}
			if (`objExists $every`){
				catch(`delete $every`);
			}
		}

		// delete history on geo
		// DISABLED BECAUSE OF VRAY PROXIES NEED CONSTRUCTION HISTORY
		//select `ls -type "mesh" -type "nurbsSurface" -type "nurbsCurve"`;
		//delete -ch;
	
		$unknown = `ls -type unknown -type unknownDag -type unknownTransform`;
		for ($each in $unknown){
			catch(`lockNode -l 0 $each`);
			catch(`delete $each`);
		}


		// remove unknown ref nodes
		abxDeleteUnknownRefNodes;
		abxDeleteSharedRefNodes;
		

		// flatten hierarchies		

		// convert : to _
		abxAssetsNamespaceToRnp;

		// remove all namespaces
		abxAssetsRemoveAllNamespaces;

		abxAssetsNoPolySmooth;
		
		// optionally export shading networks along with a shader map file

		// remove junk
		delete `ls -type hyperView`;
		delete `ls -type objectTypeFilter`;
		delete `ls -type objectScriptFilter`;
		delete `ls -type objectFilters`;

		// delete render layers
		abxAssetsDeleteAllRenderLayers;


		// delete display layers
		abxAssetsDeleteAllDisplayLayers;

		// remove any isolateSelectedSets
		delete `ls -type objectSet "modelPanel*ViewSelectedSet"`;
		delete `ls -type objectSet "modelPanel*ViewSelectedSet*"`;


		//abxAssetsRemoveIntermediateShapes();
		abxAssetsRemoveIsolateSelected();
		abxAssetsFaceAssignmentCheck(0);
		initialShadingGroupCheck(0);

		abxAssetsMakeTexturesLocal ($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess);
		makeLowRezTextures;

		// lock REF LOCATORS
		$locs = `ls -type transform "_PROP_*"`;
		for ($each in $locs){
			setAttr -lock 1 ($each+".tx");
			setAttr -lock 1 ($each+".ty");
			setAttr -lock 1 ($each+".tz");
			setAttr -lock 1 ($each+".rx");
			setAttr -lock 1 ($each+".ry");
			setAttr -lock 1 ($each+".rz");
			setAttr -lock 1 ($each+".sx");
			setAttr -lock 1 ($each+".sy");
			setAttr -lock 1 ($each+".sz");
		}

	}
	// if dept is rig
	else if ($deptGuess == "rig")  {

		// clear all ref edits
		string $refNodes[] = `file -q -r`;
		for ($each in $refNodes){
			string $refNodeName = `referenceQuery -rfn $each`;
			referenceEdit -failedEdits true -successfulEdits false -removeEdits $refNodeName;
		}

		// restore deformed shaders
		abxAssetsRestoreDeformedShader 1;

		abxAssetsRestoreShapeRenderProperties 1;

		abxAssetsImportAllReferences;

		abxDeleteAllRN;

		// remove items in the deleteSet
		string $deleteSets[] = `ls -type objectSet -r 1 "*deleteSet"`;
		for ($every in $deleteSets){
			lockNode -l 0 $every;
			$members = `sets -q $every`;
			for ($m in $members){
				lockNode -l 0 $m;
				select -ne $m;
				if (size(`ls -sl`)>0)
					lockNode -l 0;
				delete `ls -sl`;
				if (`objExists $m`){
					delete $m;
				}
			}
			if (`objExists $every`){
				delete $every;
			}
		}

		// convert : to _
		abxAssetsNamespaceToRnp;

		// remove all namespaces
		abxAssetsRemoveAllNamespaces;


		// remove unknown ref nodes
		abxDeleteUnknownRefNodes;
		abxDeleteSharedRefNodes;

		abxAssetsDeleteUnkownNodes;

		abxDeleteExtraDefaultRenderLayers;

		abxAssetsHideJointAxes;

		abxAssetsNoPolySmooth;

		abxAssetsRemoveUnusedInfluences;

		// delete render layers
		abxAssetsDeleteAllRenderLayers;

		// delete display layers
		//abxAssetsDeleteAllDisplayLayers;

		//HideKinematics;
		//HideDeformers;

		// remove any isolateSelectedSets
		delete `ls -type objectSet "modelPanel*ViewSelectedSet"`;
		delete `ls -type objectSet "modelPanel*ViewSelectedSet*"`;

		eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Lighting/texRezSwitchButt.mel\"");
		texRezSwitchButt("LOW");

		// //set low rez textures
		// string $fileNodes[] = `ls -type file`;
		// for($tmp in $fileNodes)
		// {
		//     string $filePath = `getAttr ($tmp+".fileTextureName")`;
		//     string $baseFileName = `basenameEx($filePath)`;
		//     string $pathParts[];
		//     tokenize($filePath,"/",$pathParts);
		//     int $pp = `size $pathParts`-1;
		//     if(!`gmatch $baseFileName "*_LOW"`)
		//     {
		//           string $outputPath = substitute($pathParts[$pp],$filePath,($baseFileName+"_LOW.tga"));
		//           setAttr -type "string" ($tmp+".fileTextureName") $outputPath;
		//           print ($outputPath+"\n");
		//     }
		// }



	}
	

	// save the file as a temp file first
	evalEcho("file -rename \""+$tempMasterFilePath+"\"");
	
	evalEcho("file -type \"mayaBinary\" -save");


	// if the save was successful to the temp file
	if (`filetest -r $tempMasterFilePath`){

		if (`filetest -w $masterFilePath`){
			// archive the older master file
			
			abxAssetsArchiveFile ($masterFilePath, "master");
		}
			
		// rename the current temp master file
		sysFile -rename $masterFilePath $tempMasterFilePath;
		evalEcho("file -rename \""+$masterFilePath+"\"");

		string $result = "Skip";
		if (!$force)
			// $result = `promptDialog -title "Asset Manager Notes: Master Scene" -message "Describe what you changed:                                                                            " -text $note -button "OK" -button "Skip"  -defaultButton "OK" -cancelButton "Skip" -dismissString "Skip"`;
		if ($result == "OK")
			$note = `promptDialog -query -text`;

		// log the master event
		evalEcho("abxAssetsWriteAssetLog \""+$assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess+"\" \""+$deptGuess+" master\" \""+$workVersion+"\" \""+$note+"\"");

	}
	else {
		error ("mastering failed: Unable to Save:"+$tempMasterFilePath);
	}

	file -mf false;
	
	// procedure complete. prompt the user what to do next
	//string $thirdButton = "Force Publish";
	string $result = "New Scene";
	if ($deptGuess == "geo"){
		// if no rig scene exists then add a button for publish with simple rig scene.
		if (!$force)
			$result = `confirmDialog -title "abxAssets Confirm" -message ($deptGuess+" Master Successful.") -button "Open Work" -button "New Scene" -button "Quick Rig" -defaultButton "Open Work" -cancelButton "New Scene" -dismissString "New Scene"`;
	}
	else if ($deptGuess == "rig"){
		if (!$force)
			$result = `confirmDialog -title "abxAssets Confirm" -message ($deptGuess+" Master Successful.") -button "Open Work" -button "New Scene" -button "Force Publish"  -defaultButton "Open Work" -cancelButton "New Scene" -dismissString "New Scene"`;	
	}

	if ($result == "Open Work")  {
		abxAssetsOpenWorkScene($assetPath, "latest", $force);
	}
	else if ($result == "New Scene"){
		file -mf false;
		// file -f -new;
		if (`exists ppDoNewScene`){
			ppDoNewScene "empty";
		}
		else {
			file -f -new;
		}
	}
	else if ($result == "Force Publish"){
		if ($deptGuess == "rig")  {
			abxAssetsPublish(($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess), 1, $note);
		}
		else if ($deptGuess == "geo"){
		}
	}
	else if ($result== "Force Rig Remaster"){
		file -mf false;
		abxAssetsMaster(($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess+"/rig"),1,$note);
	}
	// if its a quick rig then take the geo master and make a quick rig
	else if ($result == "Quick Rig"){
		file -mf false;
		abxAssetsStartRigScene (($assetLibGuess+"/"+$assetTypeGuess+"/"+$assetNameGuess),1);
	}
}








































// CB - determine if shaders need updating
// NOT USED - we are only adding the shader name/version attrs to the master scene geo, so this will always fail
// Currently, just checks whether attrs have been created on geometry holding shader name and version
//	could also try to determine if shaders have been changed since last version
// Assumes that top-level node of model is named GEO
/*
global proc int cbxShadersNeedUpdating ()  {
	//string $shapes[] = `listRelatives -allDescendents -type mesh -type nurbsSurface -noIntermediate GEO`;
	string $shapes[] = `ls -type mesh -type nurbsSurface`;

	int $needUpdate = false;
	for ($sh in $shapes)  {
		string $sgs[] = `listSets -t 1 -o $sh`;
		if (size($sgs) > 0)  {
			if (!`attributeQuery -n $sh -ex "PP_SGName"`)  {
				$needUpdate = true;
				break;
			}
		}
	}
	return $needUpdate;
}
*/

// CB = save shaders to specified directory and add/update attrs on geometry
// Assumes that top-level node of model is named GEO
global proc cbxUpdateShadersVersion (string $shaderDir, string $workVersion)  {

	eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Lighting/abxExportShaderMel.mel\"");
	//string $shapes[] = `listRelatives -allDescendents -type mesh -type nurbsSurface -noIntermediate GEO`;
	string $shapes[] = `ls -type mesh -type nurbsSurface`;

	string $sgNodes[];
	for ($sh in $shapes)  {
		string $sgs[] = `listSets -t 1 -o $sh`;
		if (size($sgs) > 0)  {
			string $sg = $sgs[0];
			$sgNodes[size($sgNodes)] = $sg;

			if (!`attributeQuery -n $sh -ex "PP_SGName"`)  {
				addAttr -dt "string" -ln "PP_SGName" $sh;
				addAttr -dt "string" -ln "PP_SGVersion" $sh;
			}
			setAttr -type "string" ($sh + ".PP_SGName") $sg;
			setAttr -type "string" ($sh + ".PP_SGVersion") $workVersion;
		}
	}

	if (!`filetest -d $shaderDir`)  {
		print("Create Directory: " + $shaderDir + "\n");
		if (!`sysFile -makeDir $shaderDir`)  {
			print("makeDir failed\n");
			return;
		}
	}

	exportShadingNetworkMEL(stringArrayRemoveDuplicates($sgNodes), {$shaderDir});
}





global proc abxAssetsStartRigScene (string $assetPath, int $quickPublish){

	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $dept = "rig";

	// prompt the user if a rig work scene already exists. 
	string $workDirGuess = (`workspace -q -rd` + "/" + $assetPath + "/"+$dept+"/work/");
	string $workVersion = abxAssetsGetLatestWorkVersion($assetPath,$dept,"","work",0); 

	string $latestFoundVersion = ($tokenBuffer[2]+"_rig_"+$workVersion);
	string $filePath = (`workspace -q -rd`+$assetPath+"/rig/work/"+$latestFoundVersion+".ma");

	string $result = "Force";
	print ("CHECKING FOR "+$filePath+"\n");
	if (`filetest -r $filePath` && $workVersion != "v000"){
		$result = `confirmDialog -title "abxAssets Confirm" -message ("A Rig Scene Exists. Quick Rig Cannot Continue. Contact Rigging Department to publish your changes.") -button "Cancel Quick Rig" -defaultButton "Cancel" -cancelButton "Cancel" -dismissString "Cancel"`;
	}
	


	if ($result=="Force"){
		// create new rig work scene
		if (`exists ppDoNewScene`)
			ppDoNewScene "rig";
		else 
			file -f -new;
							
		if (!`objExists ROOT`)
			createNode -ss -name "ROOT" transform;
		// add/update the assetPath to the shading group attr
		if (!`attributeExists "assetPath" "ROOT"`)
			addAttr -longName "assetPath" -dt "string" "ROOT";
		setAttr -type "string" ("ROOT.assetPath") $assetPath;

				

		int $success = abxAssetsRefGeo($assetPath);

		// if a proxy set exists parent it to the SETS set 
		if (`objExists "geo_lowProxySet"`){
			if (`objExists RES`)
				sets -add RES "geo_lowProxySet";
		}
		
		string $geoObjects[] = `ls -dag "geo_*"`;
		string $geoAllRootObjs[] ;
		for ($each in $geoObjects){
			$geoAllRootObjs[size($geoAllRootObjs)] = rootOf($each);
		}
		string $geoRootObjs[] = stringArrayRemoveDuplicates($geoAllRootObjs);
		for ($every in $geoRootObjs){
			parent $every "BODY";
		}

	//save as rig work scene -force
		if ($success){

			// save as the v0 rig (aka the quick rig)
			string $quickRigFilePath = (`workspace -q -rd`+$assetPath+"/rig/work/"+$tokenBuffer[2]+"_rig_v000.ma");
			file -rn $quickRigFilePath;
			file -f -save;
			//abxAssetsIncrementalSave(($assetPath+"/rig"), 1, "saving basic rig");
		}
		if ($quickPublish){
			abxAssetsMaster (($assetPath+"/rig"), 1, "saving basic rig");
			abxAssetsPublish ($assetPath, 1, "publish basic rig");
		}
		else{
			//if (`exists ppDoNewScene`)
			//	ppDoNewScene "empty";
			//else 
			//	file -f -new;
		}
	}
}




global proc abxAssetsOpenTake (string $sourceList) {
	// set a global string to mark which dept the open take was called from. this helps the reference locking proc know how to lock the file
	global string $deptOpen;

	// get active tab to determine which dept to show
	string $dept = `abxAssetsGetActiveDeptTab`;

	//string $takeSceneName[] = `textScrollList -q -si $sourceList`;
	string $takeSceneName[] = `treeView -q -si $sourceList`;

	if (size($takeSceneName)>0){
		string $mayaFormat = `fileExtension $takeSceneName[0]`;
		if ($mayaFormat == "ma")
			$mayaFormat = "mayaAscii";
		else if ($mayaFormat == "mb")
			$mayaFormat = "mayaBinary";

		// THIS IS CRAPPY HACK TO GET THE ACTIVE ASSET PATH
		$assetLib = "assets";
		$assetName = `textFieldGrp -q -text abxAssetsDtlAssetName`; 
		$assetType = `textFieldGrp -q -text abxAssetsDtlType`;

		string $fileToOpen = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/"+tolower($dept)+"/work/"+$takeSceneName[0]);
		print ("$fileToOpen="+$fileToOpen+"\n");

		// check for file lock and prompt if locked
		if (abxLockFileGetStatus($fileToOpen,1) == 1){
			return;
		}
		// set the global var to the dept so that reference locking can guess how to lock the file we are about to open.
		$deptOpen = $dept;

		string $cmd = ("saveChanges(\"abxLockFileCheckOut(\\\"\\\");file -f -o \\\""+$fileToOpen+"\\\";abxLockFileCheckIn(\\\""+$fileToOpen+"\\\");\");");
		$cmd += ("addRecentFile(\""+$fileToOpen+"\", \""+$mayaFormat+"\");");
		evalEcho $cmd;

		if ($dept == "rig"){

			// add a deleteSet
			if (!`objExists deleteSet`) sets -empty -n deleteSet;

			// add forced outliner nodes if any
			string $outlinerNodes[] = {};
			for ($each in $outlinerNodes){
				if (`objExists $each`) reorder -front $each;
			}

			// check work references for updated versions
			abxAssetsUpdateWorkRefs "all" 0;
		}

		// check for references in scene file that need updating
		if ($dept == "geo" || $dept == "shd"){
			editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;
			if (!`objExists deleteSet`) sets -empty -n "deleteSet";
			//print ("Checking Take References\n");
			//CheckAllRefsForUpdate;
			// list references

			// check work references for updated versions
			abxAssetsUpdateWorkRefs "all" 0;
		}

		// check for updates to shaders - modelling only for now
		if ($dept == "geo")  {
			//cbxShotsCheckAllAssetsForShaderUpdates();
		}
	}
	$deptOpen = "";
}

// opens the assets current work scene, either the latest or a specified version
global proc abxAssetsOpenWorkScene(string $assetPath, string $which, int $force){
	
	string $tokenBuffer[];
	string $assetLib = "";
	string $assetType = "";
	string $assetName = "";
	string $dept = "";

	tokenize $assetPath "/" $tokenBuffer;
	if (size($tokenBuffer) == 4){
		$assetLib = $tokenBuffer[0];
		$assetType = $tokenBuffer[1];
		$assetName = $tokenBuffer[2];
		$dept = $tokenBuffer[3];
		
		string $workDirGuess = (`workspace -q -rd` + "/" + $assetLib + "/" + $assetType + "/" + $assetName +"/"+$dept+"/work/");

		string $workVersion = abxAssetsGetLatestWorkVersion(($assetLib + "/" + $assetType + "/" + $assetName),$dept,"","work",0); 

		string $latestFoundVersion = ($assetName+"_"+$dept+"_"+$workVersion);

		string $filePrefix = ($assetName+"_"+$dept);

		if ($workVersion != ""){
			string $filePath = ($workDirGuess+$latestFoundVersion+".ma");
			string $ext = "mayaAscii";
			if (!`filetest -r $filePath`){
				$ext = "mayaBinary";
				$filePath = ($workDirGuess+$latestFoundVersion+".mb");
			}			
			//saveChanges("file -f -options \"v=0\"  -typ \"mayaAscii\" -o \""+$filePath+"\";");
			if ($force)
				evalEcho("abxLockFileCheckOut(\"\");file -f -options \"v=0\" -o \""+$filePath+"\";");
			else
				//saveChanges("file -f -options \"v=0\" -o \""+$filePath+"\";");
				saveChanges("abxLockFileCheckOut(\"\");file -f -o \""+$filePath+"\";abxLockFileCheckIn(\""+$filePath+"\");");
			evalEcho("addRecentFile(\""+$filePath+"\", \""+$ext+"\");");

			if (!`objExists deleteSet`) sets -empty -n deleteSet;

			file -mf false;

			// check work references for updated versions
			abxAssetsUpdateWorkRefs "all" 0;
		}
		else {
			error ("No Work Scenes Found: "+$workDirGuess+$filePrefix+"_v###\n");
		}
	}
	else {
		error ("Unrecognized Asset Path: "+$assetPath+"\n");
	}
}

global proc abxAssetsOpenMasterScene(string $assetPath, int $force){
	string $tokenBuffer[];
	string $assetLib = "";
	string $assetType = "";
	string $assetName = "";
	string $assetDept = "";

	tokenize $assetPath "/" $tokenBuffer;
	if (size($tokenBuffer) == 4){
		$assetLib = $tokenBuffer[0];
		$assetType = $tokenBuffer[1];
		$assetName = $tokenBuffer[2];
		$assetDept = $tokenBuffer[3];
		
		string $masterFileGuess = (`workspace -q -rd`+$assetLib + "/" + $assetType + "/" + $assetName + "/" + $assetDept + "/"+$assetName+"_"+$assetDept+".mb");
		if (!`filetest -r $masterFileGuess`){
			$masterFileGuess = (`workspace -q -rd`+$assetLib + "/" + $assetType + "/" + $assetName + "/" + $assetDept + "/"+$assetName+"_"+$assetDept+".ma");
			if ($force)
				evalEcho("abxLockFileCheckOut(\"\");file -f -options \"v=0\"  -typ \"mayaAscii\" -o \""+ $masterFileGuess+"\";");
			else
				saveChanges("abxLockFileCheckOut(\"\");file -f -options \"v=0\"  -typ \"mayaAscii\" -o \""+ $masterFileGuess+"\";");
			evalEcho("addRecentFile(\""+$assetType + "/" + $assetName + "/" + $assetDept + "/"+$assetName+"_"+$assetDept+".ma" +"\", \"mayaAscii\");");
		}
		else {
			if ($force)
				evalEcho("abxLockFileCheckOut(\"\");file -f -options \"v=0\"  -typ \"mayaBinary\" -o \""+ $masterFileGuess+"\";");
			else
				saveChanges("abxLockFileCheckOut(\"\");file -f -options \"v=0\"  -typ \"mayaBinary\" -o \""+ $masterFileGuess+"\";");
			evalEcho("addRecentFile(\""+$assetType + "/" + $assetName + "/" + $assetDept + "/"+$assetName+"_"+$assetDept+".ma" +"\", \"mayaBinary\");");
		}

		file -mf false;
	}
	else {
		error ("Unrecognized Asset Path:"+$assetPath+"\n");
	}

}

global proc abxAssetsSetFrameRate (float $targetFPS){
	float $startFrame = `playbackOptions -q -min`;
	int $moveKeys = false;
	int $moveRange = false;
	int $snapKeys = false;
	int $snapRange = false;
	string $ppTools = `getenv MAYA_PPTOOLS`;

	eval("source \""+$ppTools+"/scripts/Toolbox/Animation/abxFPS.mel\"");
	frameRateChangeProc ($targetFPS,$startFrame,$moveKeys,$moveRange,$snapKeys,$snapRange);

}


global proc string abxAssetsGetLatestVersionFromPath (string $filePath){
	string $basename = `basenameEx $filePath`;
	string $tokenBuffer[];
	tokenize $basename "_" $tokenBuffer;

	string $tokenBuffer2[];
	tokenize $filePath "/" $tokenBuffer2;
	

	string $assetPath = "";
	string $dept = "";
	string $takeName = "";
	string $type = "work";
	int $getFullPath = 1;

	// if there are at least 7 folders deep its probably a valid asset
	//M:\STORY2012_PP10088\3D\STORY2012_maya\assets\characters\roboto\geo\work\file.ma
	if (size($tokenBuffer2) > 7){
		$assetPath = ($tokenBuffer2[4]+"/"+$tokenBuffer2[5]+"/"+$tokenBuffer2[6]);
	}	

	if (size($tokenBuffer) == 3){
		$dept = $tokenBuffer[1];
	}
	else if (size($tokenBuffer) == 4){
		$dept = $tokenBuffer[1];
		$takeName = $tokenBuffer[2];
	}
	
	return abxAssetsGetLatestWorkVersion($assetPath, $dept, $takeName, $type, $getFullPath);
}


global proc string abxAssetsGetLatestWorkVersion (string $assetPath, string $dept, string $takeName, string $type, int $getFullPath) {

	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetName = $tokenBuffer[2];
	//string $dept = $tokenBuffer[size($tokenBuffer)-2];
	string $assetType = $tokenBuffer[1];
	string $assetLib = $tokenBuffer[0];

	string $workPath = (`workspace -q -rd`+$assetPath+"/"+tolower($dept)+"/"+$type+"/");

	string $filePrefix = ($assetName+"_"+$dept+"_");

	if($takeName != "")
		$filePrefix += ($takeName+"_");

	if ($type == "master")
		$filePrefix += ("master_");

	// get the contents of the work directory
	string $workFolderFiles[] = `getFileList -fs ($filePrefix+"*") -folder $workPath`;

	string $workScenes[];
	string $latestFoundVersion = "v000";
	string $latestFoundFileName = "";
	int $highestVersion = 0;
		
	// iterate through the files to find the latest version number
	for ($each in $workFolderFiles){
		// match to the file naming structure
		if (`gmatch $each ($filePrefix+"*")`){
			$workScenes[size($workScenes)] = $each;
			string $wholeFileName = basenameEx($each);
			// added a plus 1
			int $prefixSize = size($filePrefix)+1;
			int $filenameSize = size($wholeFileName);
			string $fileName = `substring $wholeFileName $prefixSize $filenameSize`;
			//print ("FoundFilename="+$fileName+"\n");
			string $tokenBuffer2[];
			tokenize $fileName "_" $tokenBuffer2;
			if ($takeName != "" || size($tokenBuffer2) == 1){

				string $workVersion = "";
				$workVersion = $tokenBuffer2[size($tokenBuffer2)-1];
				
				// cut off the 'v' from the string for conversion to integer
				string $numOnly = substring($workVersion,2,size($workVersion));
				int $wVersionInt = 0;
				if (`match "[0-9]+" $numOnly` != "")
					$wVersionInt = int(`match "[0-9]+" $numOnly`);
				if ($wVersionInt > $highestVersion){
					$highestVersion = $wVersionInt;
					$latestFoundVersion = $workVersion;
					$latestFoundFileName = $each;
				}
			}
		}
	}

	if ($latestFoundVersion != ""){
		if ($getFullPath)
			if ($latestFoundFileName != "")
				return ($workPath+$latestFoundFileName);
			else 
				return "";
		else
			return $latestFoundVersion;
	}
	else {
		return "";
	}
}

global proc abxAssetsShowCreateUI (string $lib, string $type, string $name, string $template) {
	if (!`window -exists abxAssetsCreateWindow`){
		window -width 500 -height 200 abxAssetsCreateWindow;
		columnLayout;
		// asset library
		optionMenuGrp -label "Library:"  -columnWidth 2 80 abxAssetsCreateOMLib;
			menuItem -label "assets";
		// asset type
		optionMenuGrp -label "Type:"  -columnWidth 2 80  abxAssetsCreateOMType;
			// load the found folder names in assets and show them
			string $assetFolder = (`workspace -q -rd`+"assets/");
			string $foundAssetTypes[] = `getFileList -folder $assetFolder`;
			for ($each in $foundAssetTypes){
				menuItem -label $each;
			}
			//menuItem -label "characters";
			//menuItem -label "props";
			//menuItem -label "sets";
			//menuItem -label "shaders";
			//menuItem -label "lights";
			//menuItem -label "textures";
		
		// asset name
		textFieldGrp -label "Name:" -text  "dontUseUnderscores"  abxAssetsCreateTFName;

		// asset method
		optionMenuGrp -label "Template:"  -columnWidth 2 80  abxAssetsCreateOMTmpl;	
			menuItem -label "model";	
		rowLayout -numberOfColumns 2 -columnWidth2 250 250 -columnAttach 1 "both" 0 -columnAttach 2 "both" 0;
		button -label "Create" -c "abxAssetsCreateNew (`optionMenuGrp -q -value abxAssetsCreateOMLib`+\"/\"+`optionMenuGrp -q -value abxAssetsCreateOMType`+\"/\"+`textFieldGrp -q -text abxAssetsCreateTFName`) (`optionMenuGrp -q -value abxAssetsCreateOMTmpl`);window -e -vis 0 abxAssetsCreateWindow;" ;
		button -label "Cancel" -c "window -e -vis 0 abxAssetsCreateWindow";

		optionMenuGrp -e -value $lib abxAssetsCreateOMLib;
		optionMenuGrp -e -value $type abxAssetsCreateOMType;
		textFieldGrp -e -text $name abxAssetsCreateTFName;
		optionMenuGrp -e -value $template abxAssetsCreateOMTmpl;
		
		showWindow abxAssetsCreateWindow;
	}
	else {
		showWindow abxAssetsCreateWindow;
	}
}

global proc abxAssetsCreateNew (string $assetPath, string $type){


	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetLib = $tokenBuffer[0];
	string $assetType = $tokenBuffer[1];
	string $assetName = $tokenBuffer[2];

	// vallidate the asset name
	tokenize $assetName "_" $tokenBuffer;
	if (size($tokenBuffer)> 1){
		$assetName = $tokenBuffer[0];
		int $i = 0;
		for ($i=1;$i<size($tokenBuffer);$i++){
			int $l = size($tokenBuffer[$i]);
			string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
			string $rest = `substring $tokenBuffer[$i] 2 $l`;
			$assetName += ($capLetter+$rest);
		}
	}

	// vallidate the asset name
	tokenize $assetName " " $tokenBuffer;
	if (size($tokenBuffer)> 1){
		$assetName = $tokenBuffer[0];
		int $i = 0;
		for ($i=1;$i<size($tokenBuffer);$i++){
			int $l = size($tokenBuffer[$i]);
			string $capLetter = toupper(`substring $tokenBuffer[$i] 1 1`);
			string $rest = `substring $tokenBuffer[$i] 2 $l`;
			$assetName += ($capLetter+$rest);
		}
	}

	// if type is a maya model asset, use the geo/rig/sourceimages structure
	if ($type == "model"){
		string $path = (`workspace -q -rd`+$assetLib+"/");
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
		}
		$path = ($path+$assetType+"/");
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
		}
		$path = ($path+$assetName+"/");
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
		}
		string $deptPath = ($path+"_publish/");
		if (!`filetest -d $deptPath`){
			sysFile -makeDir $deptPath;
			sysFile -makeDir ($deptPath+"sourceimages/");
		}
		$deptPath = ($path+"archive/");
		if (!`filetest -d $deptPath`){
			sysFile -makeDir $deptPath;
		}
		$deptPath = ($path+"geo/");
		if (!`filetest -d $deptPath`){
			sysFile -makeDir $deptPath;
			sysFile -makeDir ($deptPath+"work/");
			sysFile -makeDir ($deptPath+"archive/");
		}
		$deptPath = ($path+"rig/");
		if (!`filetest -d $deptPath`){
			sysFile -makeDir $deptPath;
			sysFile -makeDir ($deptPath+"work/");
			sysFile -makeDir ($deptPath+"archive/");
		}
		$deptPath = ($path+"sourceimages/");
		if (!`filetest -d $deptPath`){
			sysFile -makeDir $deptPath;
			sysFile -makeDir ($deptPath+"work/");
			sysFile -makeDir ($deptPath+"archive/");
		}
		$deptPath = ($path+"shaders/");
		if (!`filetest -d $deptPath`){
			sysFile -makeDir $deptPath;
			sysFile -makeDir ($deptPath+"work/");
			sysFile -makeDir ($deptPath+"archive/");
		}
		$deptPath = ($path+"data/");
		if (!`filetest -d $deptPath`){
			sysFile -makeDir $deptPath;
			sysFile -makeDir ($deptPath+"clips/");
			sysFile -makeDir ($deptPath+"reference/");
		}
	}

	// else if the type is a fragment asset such as shaders or light rigs use a simple work/sourceimages structure
	else if ($type == "render"){
		string $path = (`workspace -q -rd`+$assetLib+"/");
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
		}
		$path = ($path+"work/");
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
		}
		$path = ($path+"archive/");
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
		}
		$path = ($path+"sourceimages/");
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
			sysFile -makeDir ($path+"work/");
			sysFile -makeDir ($path+"archive/");
		}		
	}
	// else if the type is a 2d asset use a simple work/master struct
	else if ($type == "texture"){
		string $path = (`workspace -q -rd`+$assetLib+"/");
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
		}
		$path = ($path+"work/");
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
		}
		$path = ($path+"archive/");
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
		}
	}
	print ("Created: "+$assetLib+"/"+$assetType+"/"+$assetName+"  Template:"+$type+"\n");

	string $thumbIcon = "out_character.png";

	catchQuiet(eval("treeLister -e -add "+$assetLib+"/"+$assetType+"/"+$assetName+" \""+$thumbIcon+"\" \"abxAssetsSetActiveAsset(\\\""+$assetLib+"/"+$assetType+"/"+$assetName+"\\\")\" abxAssetsTreeLister"));

	// add other job dept paths

	string $renderFolder = (`workspace -q -rd`+"../../RENDER/_ASSETS/");
	//string $compFolder = (`workspace -q -rd`+"../../COMP/_ASSETS/");
	string $sourceFolder = (`workspace -q -rd`+"../../SOURCE/_ASSETS/");
	string $styleFramesFolder = (`workspace -q -rd`+"../../STYLEFRAMES/_ASSETS/");

	string $paths[] = {$renderFolder,$sourceFolder, $styleFramesFolder};

	for ($path in $paths){
		$path += ($assetType+"/"+$assetName);
		if (!`filetest -d $path`){
			sysFile -makeDir $path;
		}
	}

	string $filepath = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName);
	// add it to the db
	global int $dbExists;
	if ($dbExists){
		$fail = catch(python("R.Asset.createFromPath('"+$filepath+"')"));
		print ("DB Create Asset FilePath ="+$filepath+"\n");
		if ($fail)
			warning("Rainbow Database failed to add asset. Skipping Database creating asset folders anyway");
	}
}

// mode allows you to reference full, proxy, previs, or renderproxy alternates
global proc string abxAssetsRefAsset (string $assetPath, string $mode, int $lockRef){
	
	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetLib = $tokenBuffer[0];
	string $assetType = $tokenBuffer[1];
	string $assetName = $tokenBuffer[2];

	if ($mode == "full") $mode = "";
	string $refFile = "";
	if ($mode == ""){
		$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+".mb");
		if (!`filetest -r $refFile`){
			$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+".ma");
		}
	}
	else {
		$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+"_"+$mode+".mb");
		if (!`filetest -r $refFile`){
			$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+"_"+$mode+".ma");
		}
	}

	if (`filetest -r $refFile`){
		string $newRef = abxAssetsCreateReference($refFile,$assetName,"namespace",$lockRef);
		abxAssetsCheckForProps({$newRef});
		return $newRef;
	}
	else {
		error ("Asset not Published");
		return "";
	}
}

global proc abxAssetsRefTemp (string $assetPath){
	
	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetLib = $tokenBuffer[0];
	string $assetType = $tokenBuffer[1];
	string $assetName = $tokenBuffer[2];

	$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+".mb");
	if (!`filetest -r $refFile`){
		$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+".ma");
	}

	if (`filetest -r $refFile`){
		abxAssetsCreateReference($refFile,("temp"+$assetName),"namespace",0);
	}
	else {
		error ("Asset not Published");
	}
}


global proc abxAssetsImpAsset (string $assetPath){
	
	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetLib = $tokenBuffer[0];
	string $assetType = $tokenBuffer[1];
	string $assetName = $tokenBuffer[2];

	$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+".mb");
	if (!`filetest -r $refFile`){
		$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/_publish/"+$assetName+".ma");
	}

	if (`filetest -r $refFile`){
		abxAssetsImportAsset($refFile,$assetName,"namespace");
	}
	else {
		error ("Asset not Published");
	}
}

global proc int abxAssetsRefGeo (string $assetPath){
	
	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetLib = $tokenBuffer[0];
	string $assetType = $tokenBuffer[1];
	string $assetName = $tokenBuffer[2];

	$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/geo/"+$assetName+"_geo.mb");

	if (!`filetest -r $refFile`){
		$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/geo/"+$assetName+"_geo.ma");
	}


	if (`filetest -r $refFile`){
		abxAssetsCreateReference($refFile,"geo","rename",0);
	}
	else {
		//error ($assetLib+"/"+$assetType+"/"+$assetName+" Geo Master Not Found");
		$result = `confirmDialog -title "abxAssets Error" -message ($assetName+" Geo Master not found. Please Master Geo Work Scene before starting rig") -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
		return 0;
	}
	return 1;
}

// file -r -type "mayaBinary" -gr -gn "ASSETNAME" -gl -loadReferenceDepth "all" -namespace "NAME" -options "v=0" "M:/Skylanders2013_PP10102/3D/Skylanders2013_maya/assets/props/KaosMonument/geo/work/KaosMonument_geo_v002.mb";
// references the latest geo work scene so that changes can be spit back into work scene
// should take changes and increment the work scene, save the changes to the work scene upstream, then ref the new incremented version.
// should also be aware of file locks
// need to add a update work version check into opening geo work scenes
// also need to remove all geo work references, leaving behind locators used for referencing later
// when saving the geo we also need to check for unsaved ref edits to prompt the user to save them
global proc int abxAssetsRefGeoWork (string $assetPath, string $refAs){
	// reference the latest geo work scene
	// lock the transforms on GRP 
	// group the GRP objects to a locator
	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetLib = $tokenBuffer[0];
	string $assetType = $tokenBuffer[1];
	string $assetName = $tokenBuffer[2];

	$locPrefix = "_LOC_";
	$refPrefix = "";
	int $wireColor = 28;

	if ($refAs == "prop"){
		$locPrefix = "_PROP_";
	}
	else if ($refAs == "decor"){
		$locPrefix = "_DECOR_";
		$refPrefix = "DECOR_";
		$wireColor = 31;
	}
		

	//$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/geo/"+$assetName+"_geo.mb");
	$refFile = abxAssetsGetLatestWorkVersion(($assetLib+"/"+$assetType+"/"+$assetName),"geo","","work",1);

	if (!`filetest -r $refFile`){
		$refFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/geo/"+$assetName+"_geo.ma");
	}
	print ("trying to reference: "+$refFile+"\n");

	if (`filetest -r $refFile`){
		$ref = abxAssetsCreateReference($refFile,($refPrefix+$assetName),"namespace",0);

		// create a locators and turn it purple
		string $newLoc[] = `spaceLocator -p 0 0 0`;
		string $newLocShapes[] = `listRelatives -shapes $newLoc[0]`;
		setAttr ($newLocShapes[0]+".localScaleX") 35;
		setAttr ($newLocShapes[0]+".localScaleY") 35;
		setAttr ($newLocShapes[0]+".localScaleZ") 35;
		setAttr ($newLoc[0]+".overrideEnabled") 1;
		setAttr ($newLoc[0]+".overrideColor") $wireColor;

		// get the assembly level objects
		string $namespace  = `file -q -namespace $ref`;
		string $rootOutlinerObjs[] = eval("ls -as \""+$namespace+":*\"");
		// parent them to the locator
		for ($each in $rootOutlinerObjs){
			parent $each $newLoc[0];
		}

		// rename the locator
		string $newName = `rename $newLoc[0] ($locPrefix+$namespace+"_")`;
		select $newName;
	}
	else {
		//error ($assetLib+"/"+$assetType+"/"+$assetName+" Geo Master Not Found");
		$result = `confirmDialog -title "abxAssets Error" -message ($assetName+" Geo Work not found. Please Make sure the asset geo exists") -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
		return 0;
	}


	return 1;
}

global proc string abxAssetsCreateReference (string $refFile, string $prefix, string $type, int $lock){
		
	string $result;
	if ($type == "rename"){
		namespace -set ":";
		//evalEcho ("file -r  -gl -loadReferenceDepth \"all\" -rpr \""+$prefix+"\" -options \"v=0\" \""+$refFile+"\"");
		$result = evalEcho ("file -r -gl -loadReferenceDepth \"all\" -rpr \""+$prefix+"\" -options \"v=0\" \""+$refFile+"\"");
		namespace -set ":";
	}
	else if ($type == "namespace"){
		namespace -set ":";
		//evalEcho ("file -r  -gl -loadReferenceDepth \"all\" -namespace \""+$prefix+"\" -options \"v=0\" \""+$refFile+"\"");
		if ($lock)
			$result = evalEcho ("file -r -lck -gl -loadReferenceDepth \"all\" -namespace \""+$prefix+"\" -options \"v=0\" \""+$refFile+"\"");
		else 
			$result = evalEcho ("file -r -gl -loadReferenceDepth \"all\" -namespace \""+$prefix+"\" -options \"v=0\" \""+$refFile+"\"");
		namespace -set ":";
	}
	return $result;
}

global proc abxAssetsImportAsset (string $impFile, string $prefix, string $type){

	if ($type == "rename"){
		namespace -set ":";
		evalEcho ("file -import -ra true -loadReferenceDepth \"all\" -rpr \""+$prefix+"\" -options \"v=0\" \""+$impFile+"\"");
		
	}
	else if ($type == "namespace"){
		namespace -set ":";
		evalEcho ("file -import -loadReferenceDepth \"all\" -namespace \""+$prefix+"\" -options \"v=0\" \""+$impFile+"\"");
		
	}
	namespace -set ":";
}


global proc abxAssetsImportAllReferences () {
	string $refNodes[] = `file -q -r`;
	for ($each in $refNodes){
		string $namespace = `file -q -namespace $each`;
		if (`gmatch $namespace "temp*"`){
			file -rr $each;
		}
		else{
			file -ir $each;
		}
	}
}


global proc abxAssetsRemoveAllNamespaces() {

	int $iterations = 10;
	string $refFiles[] = `file -q -r`;
	string $refNamespaces[];

	for ($each in $refFiles){
		string $namespace = `file -q -namespace $each`;
		$refNamespaces[size($refNamespaces)] = $namespace;
	}
	for ($i=0;$i<$iterations;$i++){
	// set namespace to root namespace
	namespace -set ":";
	string $foundNamespaces[] = `namespaceInfo -lon`;
	for ($each in $foundNamespaces){	
		if (!stringArrayContains($each,$refNamespaces)){
			// if its not an autodesk standard namespace remove the namesspace and move its children to the root namespace
			if ($each != "UI" && $each != "shared"){
				evalEcho("namespace -f -mv "+$each+" \":\"");
				evalEcho("namespace -rm "+$each);
			}
		}
	}	
	}

}

// converts colon to underscore in node names
global proc abxAssetsNamespaceToRnp(){
	$allNodes = `ls`;
	string $each;
	for ($each in $allNodes){
		$newName = substituteAllString($each,":","_");
		string $tokenBuffer[];
		tokenize $each "|" $tokenBuffer;
		if ($newName != $each){
		    if(`objExists $each` && size(`ls -rn $each`) == 0)		    
			evalEcho("rename "+$each+" "+$newName);
		}
	}
}

global proc abxAssetsArchiveFile (string $filePath, string $type) {

	string $pathOnly = dirname($filePath);
	
	string $extension = fileExtension($filePath);
	string $sceneName= basename($filePath,("."+$extension));
	


	// create an archive of the current file

	// if there is a log file, record its workshop version and append it to the file name

	// 

	if ($type == "publish"){
		

	}
	else if ($type == "master") {
		// check to see if there is an archive folder
		string $archFolder = ($pathOnly+"/archive/");
		if (!`filetest -d $archFolder`)
			sysFile -md $archFolder;
		if (`filetest -d $archFolder`){			
			$archiveFiles = `getFileList -folder $archFolder`;
			int $latestVersion = 0;
			string $each;
			for ($each in $archiveFiles){
				string $tokenBuffer[];
				tokenize $each "." $tokenBuffer;
				if (size($tokenBuffer) == 2){
					string $tokenBuffer2[];
					tokenize $tokenBuffer[0] "_" $tokenBuffer2;
					if (size($tokenBuffer2) == 3){
						string $foundVersionStr =  $tokenBuffer2[size($tokenBuffer2)-1];
						int $strSize = size($foundVersionStr);
						int $foundVersion = int(`substring $foundVersionStr 2 $strSize`);
						if ($latestVersion < $foundVersion){
							$latestVersion = $foundVersion;
						}
					}
				}
			}
			$latestVersion++;
			string $latestVersionStr = "";
			if ($latestVersion < 10)
				$latestVesionStr = ("v00"+$latestVersion);
			else if ($latestVersion < 100)
				$latestVesionStr = ("v0"+$latestVersion);
			else 
				$latestVesionStr = ("v"+$latestVersion);

			
			string $archivePath = ($pathOnly+"/archive/"+$sceneName+"_"+$latestVesionStr+"."+$extension);
			sysFile -move $archivePath $filePath ;
		}
	}
	

}

global proc abxAssetsCaptureThumbnail (string $assetPath) {

	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetLib = $tokenBuffer[0];
	string $assetType = $tokenBuffer[1];
	string $assetName = $tokenBuffer[2];

	string $pbPath = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/"+$assetName+".png");

	// set render globals
	//setAttr "defaultRenderGlobals.animation" 1;
	//setAttr defaultRenderGlobals.outFormatControl 0;
	//setAttr "defaultRenderGlobals.extensionPadding" 4;

	int $imgFormat = `getAttr defaultRenderGlobals.imageFormat`;

	// PNG image format
	setAttr defaultRenderGlobals.imageFormat 32;
	float $curFrame = `currentTime -q`;
	int $imgWidth = 512;
	int $imgHeight = 512;
	
	print (`playblast -ae`+"\n");

	// setup the playblast as a command string for deferred evaluation
	string $cmd = ("playblast  -format iff -completeFilename \""+$pbPath+"\" -frame "+$curFrame+" -forceOverwrite -sequenceTime 0 -clearCache 1 -viewer 0 -showOrnaments 0 -percent 100 -widthHeight "+$imgWidth+" "+$imgHeight);
	if (`about -version` == "2012 x64" || `about -version` == "2012"){
		print ($cmd+"\n");
		$cmd = ("playblast  -format iff -filename \""+$pbPath+"\" -frame "+$curFrame+" -fp 0 -forceOverwrite -sequenceTime 0 -clearCache 1 -viewer 0 -showOrnaments 0 -percent 100 -compression \"png\" -widthHeight "+$imgWidth+" "+$imgHeight+";\nsysFile -rename \""+$pbPath+"\" \""+$pbPath+".0.png\";");
	}
	
	// add to the deferred command to return the render global image format to sgi
	$cmd += (";setAttr defaultRenderGlobals.imageFormat "+$imgFormat+";");
	$cmd += ("abxAssetsRefreshDetailsUI \"\";");

	// run the playblast command as deferred evaluation
	evalDeferred ($cmd);

	

}

// removes intermidiate shape nodes from mesh and nurbs objects (geo shouldn't have history)
global proc abxAssetsRemoveIntermediateShapes(){
	// get a list of all mesh and nurbs
	$geoShapes = `ls -type mesh -type nurbsSurface`;

	// if they are intermediate delete them
	for ($each in $geoShapes){
		if (`getAttr ($each+".intermediateObject")` == true)
			catch(eval("delete "+$each));
	}
}

// removes excessive isolate selected nodes
global proc abxAssetsRemoveIsolateSelected(){
	string $modelSets[] =  `ls -r 1 "modelPanel*ViewSelectedSet*"`;

	for ($each in $modelSets){
		catch(eval("delete "+$each));
	}
}
global proc abxAssetsFaceAssignmentCheck(int $force){
	// find all shading engine sets
	string $foundFaces[];
	$sgNodes = `ls -type shadingEngine`;
	for ($each in $sgNodes){
		string $members[] = `sets -q $each`;
		string $every;
		for ($every in $members){
			if (`gmatch $every "*.f*"`){
				$foundFaces[size($foundFaces)]=$every;
			}
		}
	}
	if (size($foundFaces) > 0){
		$result = `confirmDialog -title "abxAssets: Face Assigned Shaders" -message ("You have face assigned shaders. Please fix before continuing.") -button "Cancel Save" -button "Save Anyway" -defaultButton "Cancel Save"`;
		$selCmd = "select ";
		for ($each in $foundFaces){
			$selCmd += (" "+$each);
		}
		catchQuiet(eval($selCmd));
		if ($result == "Save Anyway"){
			$force=1;
		}
		if ($force == 0)
			error("You have face assigned shaders. Please fix before continuing.");

	}
}

global proc initialShadingGroupCheck(int $force){
	// find all shading engine sets


	string $foundObjects[] = `sets -q "initialShadingGroup"`;

	if (size($foundObjects) > 0){
		$result = `confirmDialog -title "abxAssets: Objects Found with Lambert1 Assignment" -message ("Some Objects in your scene are assigned to Lambert1. Please assign these objects to another shader. No objects are allowed to be assigned to lambert1") -button "OK" -defaultButton "OK"`;
		select $foundObjects;
		if ($force == 0)
			error("Some Objects in your scene are assigned to Lambert1. Please create a shader for these objects even if just a temporary placeholder before continuing");

	}
}

global proc abxAssetsMakeTexturesLocal (string $assetPath) {
	string $tokenBuffer[];
	tokenize $assetPath "/" $tokenBuffer;
	string $assetLib = $tokenBuffer[0];
	string $assetType = $tokenBuffer[1];
	string $assetName = $tokenBuffer[2];

	int $found = false;
	string $nonLocalTexNodes[];
	string $nonLocalTex[];
	string $missingTexNodes[];
	string $missingTex[];


	string $mayaFiles[] = `ls -type file -type psdFileTex -type mentalrayTexture`;
	string $assetSourceImgPath = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/sourceimages/");
	// check to see if any textures are local or not and give warning

	for ($each in $mayaFiles){
		if (`objExists deleteSet`){
			if (!`sets -isMember "deleteSet" $each`){
				string $texPath = `getAttr ($each+".ftn")`;
				// expand the texture path incase it is relative to project
				$texPath = `workspace -en $texPath`;
				//print ("TexPath="+$texPath+"\n");
				// if the texPath is not local to the asset then copy it there
				if (!`filetest -r $texPath` && !`filetest -d $texPath`){
					$missingTex[size($missingTex)] = $texPath;
					$missingTexNodes[size($missingTexNodes)] = $each;
					print ("// MISSING: "+$each+"  \""+$texPath+"\" //\n");
					$found = true;
				}
				else if (!`gmatch $texPath ($assetSourceImgPath+"*")`){
					$nonLocalTex[size($nonLocalTex)] = $texPath;
					$nonLocalTexNodes[size($nonLocalTexNodes)] = $each;
					print ("// NON LOCAL: "+$each+"  \""+$texPath+"\" //\n");
					$found = true;
				}
				else{
					// make the texture path project relative
					setAttr -type "string" ($each+".ftn") `workspace -pp $texPath`;
				}

			}

		}

	}

	if ($found == true){
		string $list[];
		string $list2[];
		string $list3[];
		string $startList[] ;
		if (size($nonLocalTex)){
			$startList = {"// NON LOCAL TEXTURES //"};
			$list2 = `stringArrayCatenate $startList $nonLocalTex`;
		}
		if (size($missingTex) > 0){
			$list2[size($list2)] = " ";
			$list2[size($list2)] = "// MISSING TEXTURES //";
			$list3 = `stringArrayCatenate $list2 $missingTex`;
			$list = $list3;
		}
		else {
			$list = $list2;
		}
		$listStr = stringArrayToString($list, ",");
		
		string $result = "Abort";
		$result = `layoutDialog -title ("Asset Manager: Texture Check") -ui ("reportPrompt \"Move Non Local Textures to "+$assetPath+"/sourceimages/ ?\\n Missing Textures Will be ignored. Press Cancel if you want to fix missing textures.\" \""+$listStr+"\";")`;

		if ($result == "Abort"){
			error("File Not Saved. User Aborted.");
		}
		else if ($result == "Ignore"){
			return;
		}
	}

	for ($i=0;$i<size($nonLocalTex);$i++){
		string $texExt = fileExtension($nonLocalTex[$i]);
		string $texFileName = basename($nonLocalTex[$i] ,("."+$texExt));
		string $newTexPath = ($assetSourceImgPath+$texFileName+"."+$texExt);
		int $success = evalEcho("sysFile -copy \""+$newTexPath+"\" \""+ $nonLocalTex[$i]+"\"");
		if ($success){
			evalEcho("setAttr -type \"string\" "+$nonLocalTexNodes[$i]+".ftn"+" \""+`workspace -pp $newTexPath`+"\"");
		}
		else {
			evalEcho("setAttr -type \"string\" "+$nonLocalTexNodes[$i]+".ftn"+" \""+`workspace -pp $newTexPath`+"\"");

			//print ("Could not Copy File\n");
		}
	}
}

global proc abxAssetsDeleteAllDisplayLayers () {
	string $displayLayers[] = `ls -type displayLayer`;

	for ($each in $displayLayers){
		if (!`gmatch $each "*defaultLayer*"`){
			if (`objExists $each`){
			print ("Deleting Display Layer "+$each+"\n");
			catch(eval("layerEditorDeleteLayer "+$each));
			//delete $each;
			//updateEditorLayer DisplayLayerTab;
			}
		}
	}

}

global proc abxAssetsDeleteAllRenderLayers () {
	string $renderLayers[] = `ls -type renderLayer`;

	for ($each in $renderLayers){
		if (!`gmatch $each "*defaultRenderLayer*"`){
			renderLayerEditorDeleteLayer RenderLayerTab $each;
			//delete $each;
			updateEditorRenderLayer RenderLayerTab;
			print ("Deleting Render Layer "+$each+"\n");
		}
	}

}

global proc abxAssetsHideJointAxes () {

	string $joints[] = `ls -type joint`;
	for ($each in $joints){
		setAttr ($each+".displayLocalAxis") 0;
 
	}
}

global proc abxAssetsNoPolySmooth() {
	
	string $geo[] = `ls -type mesh`;
 	for ($each in $geo){
   		displaySmoothness -divisionsU 0 -divisionsV 0 -pointsWire 4 -pointsShaded 1 -polygonObject 1 $each;
    	subdivDisplaySmoothness -smoothness 1 $each;
 
 	}
	
}

global proc abxAssetsAttachMRProxy () {
	

}


global proc abxAssetsRemoveUnusedInfluences () {

	string $skinnedPolys[] = `ls -type skinCluster`;
	for ($each in $skinnedPolys){
		// removeUnusedForSkin $each 1;
 
	}
}

global proc abxAssetsRemoveAllReferences(string $keepFilter){


	string $references[] = `file -q -r`;
	for ($each in $references){
		string $namespace = `file -q -namespace $each`;
		if (!`gmatch $namespace ($keepFilter+"*")`)
			file -rr $each;

	}

	string $references[] = `file -q -r`;
	for ($each in $references){
		string $namespace = `file -q -namespace $each`;
		if (!`gmatch $namespace ($keepFilter+"*")`)
			file -rr $each;
	}

	string $references[] = `file -q -r`;
	for ($each in $references){
		string $namespace = `file -q -namespace $each`;
		if (!`gmatch $namespace ($keepFilter+"*")`)
			file -rr $each;
	}


}

global proc abxAssetsUpdateWorkRefs(string $refs, int $forceReload){
	string $refsToCheck[] = {$refs};
	string $workRefs[];

	if ($refs == "all"){
		$refsToCheck = `file -q -r`;
	}
	for ($each in $refsToCheck){
		// get the path name and check that it is a reference to a work file (*work/*_<dept>_<v>###.*)
		if (`gmatch $each "*work/*v*.m*"`){
			string $refNodeName = `referenceQuery -rfn $each`;
			string $filePathWCN = `referenceQuery -filename -wcn $each`;
			string $namespace = `file -q -namespace $each`;
			string $latestVersion = abxAssetsGetLatestVersionFromPath($filePathWCN);
			string $basename = `basenameEx $latestVersion`;
			//print ("// COMPARE //\n");
			//print ($filePathWCN+"\n");
			//print ($latestVersion+"\n");
			if ($latestVersion != $filePathWCN){
				$result = `confirmDialog -title "abxAssets Update Work References" -message ($namespace+" work reference has a new version. Would you like to update to "+$basename) -button "Update" -button "Skip Update" -defaultButton "Update" -cancelButton "Skip Update" -dismissString "Skip Update"`;
				if ($result == "Update"){
					evalEcho ("file -loadReference \""+$refNodeName+"\" \""+$latestVersion+"\"");
				}
				else{
					if ($forceReload){
						evalEcho ("file -loadReference \""+$refNodeName+"\"");
					}
				}
			}
			else {
				// if force reload is flagged, then reload non updated work references
				if ($forceReload){
					evalEcho ("file -loadReference \""+$refNodeName+"\"");
				}
			}
		}
	}
}

global proc abxAssetsInstanceWorkRef(){
	$sel = `ls -sl -type transform`;
	string $each = "";
	for ($each in $sel){
		if (`gmatch $each "_*_"`){
			string $newObj[]  = `instance $each`;
			setAttr ($newObj[0]+".overrideColor") 3;
			rename $newObj ($newObj[0]+"_INST_");
		}
		else{
			warning($each+" skipped because it does not appear to be a Prop/Decor Reference");
		}
	}
}

global proc abxDeleteAllRN() {
	// clear out old reference nodes
	$oldRN = `ls -type reference`;
	for ($each in $oldRN){
		lockNode -l 0 $each;
		delete $each;
	}

}

global proc abxDeleteUnknownRefNodes (){
	select `ls -type reference "*UNKNOWN*"`;
	if (size(`ls -sl`) > 0)
		lockNode -l 0;
	delete `ls -type reference "*UNKNOWN*"`;
}

global proc abxDeleteSharedRefNodes (){
	select `ls -type reference "*sharedReference*"`;
	if (size(`ls -sl`) > 0)
		lockNode -l 0;
	delete `ls -type reference "*sharedReference*"`;
}

global proc abxDeleteExtraDefaultRenderLayers () {
	string $drl[] = `ls "*defaultRenderLayer"`;
	for ($each in $drl){

		if ($each != "defaultRenderLayer" && $each != "defaultRenderLayerFilter"){
			delete $each;
			
		}
	}

	$drl = `ls "*defaultLayer"`;
	for ($each in $drl){

		if ($each != "defaultLayer" && $each != "defaultLayerFilter"){
			delete $each;
			
		}
	}

	$drl = `ls "defaultRenderLayer*"`;
	for ($each in $drl){

		if ($each != "defaultRenderLayer" && $each != "defaultRenderLayerFilter"){
			delete $each;
			
		}
	}

	$drl = `ls "defaultLayer*"`;
	for ($each in $drl){

		if ($each != "defaultLayer" && $each != "defaultLayerFilter"){
			catch(eval("delete "+$each));
		}
	}
}

global proc abxAssetsDeleteUnkownNodes () {
	string $unknown[] = `ls -type unknown -type unknownDag -type unknownTransform`;
	for ($each in $unknown){
		if (`objExists $each`){
			catch(eval("lockNode -l 0 "+$each));
			catch(eval("delete "+$each));
		}
	}
}


global proc abxAssetsAutoRig (string $assetPath) {


	// open the rig scene template

	// reference the geo file

	// parent the all contents of the geo file under the mover node

	// add geometry to all the res sets

	// save rig work file for asset
}

// opens a window browser at the asset path
global proc abxAssetsBrowseShot (string $assetName){

	string $assetPath = (`workspace -q -rd`+$assetName);
	$projPath = toNativePath($assetPath); 
	if (`about -os ` == "mac")
		exec ("open -a finder \""+$projPath+"\"");
	else 
		system(("start explorer "+$projPath));
}

// opens a standard maya file open browser at the asset path
global proc abxAssetsFileOpenHere(string $assetName){
	string $browserPath = (`workspace -q -rd`+$assetName);
	string $file[] = `fileDialog2 -fileFilter "Maya Files (*.ma *.mb);;Maya ASCII (*.ma);;Maya Binary (*.mb);;All Files (*.*)" -caption "Open" -fileMode 1 -dir $browserPath`;
	//$file[0] = `workspace -en $file[0]`;
	if (`filetest -r $file[0]`){
		print ($file[0]+"\n");
		saveChanges("abxLockFileCheckOut(\"\");file -f -o \""+$file[0]+"\";abxLockFileCheckIn(\""+$file[0]+"\");");
	}
		
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////DETAILS LOG FILE WRITING/////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

global proc string[] abxAssetsGetAssetDetails (string $assetPath) {

	string $tokenBuffer[];
	string $assetLib = "";
	string $assetType = "";
	string $assetName = "";
	string $assetDept = "";

	tokenize $assetPath "/" $tokenBuffer;
	if (size($tokenBuffer)>=3){
		$assetLib = $tokenBuffer[0];
		$assetType = $tokenBuffer[1];
		$assetName = $tokenBuffer[2];
	}
	else {
		warning ("Unknown assetPath:"+$assetPath+"\n");
		return {""};
	}
		

	string $detailsFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/"+$assetName+"_details.txt");
	string $assetDetails[];
	string $headerData="";
	string $nextLine="";
	string $tokenBuffer2[];
	

	if (`filetest -f ($detailsFile)`){
		 $fileId=`fopen $detailsFile "r"`;
			
			$nextLine = `fgetline $fileId`;
			tokenize $nextLine "=" $tokenBuffer2;
			string $abxAssetsVersion = strip($tokenBuffer2[1]);
			//print ("ver is "+$abxAssetsVersion+"\n");
	

			int $index = 0;
			while (size($nextLine) > 0){
				
 				$nextLine = `fgetline $fileId`;
				tokenize $nextLine "=" $tokenBuffer2;
				$assetDetails[$index] = strip($tokenBuffer2[1]);
				$index++;
			}
 		fclose $fileId;
		return $assetDetails;
	}
	else{
		//print ($detailsFile+" File not Found. Ignoring.\n");
		return {""};
	}
	
}

global proc abxAssetsUpdateDetailsFromScene(string $assetPath, string $updateWhat, string $updateValue) {

	string $assetDetails[];

	string $oldDetails[] = abxAssetsGetAssetDetails($assetPath);
	
	//pubStatus=
	$assetDetails[0]=$oldDetails[0];
	//rigStatus=
	$assetDetails[1]=$oldDetails[1];
	//geoStatus=
	$assetDetails[2]=$oldDetails[2];
	//shaderStatus=
	$assetDetails[3]=$oldDetails[3];
	//notes
	$assetDetails[4]=$oldDetails[4];


	if ($updateWhat == "pub status")
		$assetDetails[0]=$updateValue;
	if ($updateWhat == "rig status")
		$assetDetails[1]=$updateValue;
	if ($updateWhat == "geo status")
		$assetDetails[2]=$updateValue;	
	if ($updateWhat == "shd status")
		$assetDetails[3]=$updateValue;

	if ($updateWhat == "notes" || $updateWhat == "all"){
		
	}
	
	abxAssetsWriteAssetDetails ($assetPath, $assetDetails);

}

global proc abxAssetsWriteAssetDetails (string $assetPath, string $assetDetails[]){

	string $tokenBuffer[];
	string $assetLib = "";
	string $assetType = "";
	string $assetName = "";
	string $assetDept = "";

	tokenize $assetPath "/" $tokenBuffer;
	if (size($tokenBuffer)>=3){
		$assetLib = $tokenBuffer[0];
		$assetType = $tokenBuffer[1];
		$assetName = $tokenBuffer[2];
	}
	else {
		error ("Unknown assetPath:"+$assetPath+"\n");
	}
	

	string $detailsFile = (`workspace -q -rd`+$assetPath+"/"+$assetName+"_details.txt");

	// make sure status is set to 0;
	for ($i=0;$i<4;$i++){
		if ($assetDetails[$i] == ""){
			$assetDetails[$i] = "0";
		}
	}
	
	if (size($assetDetails) == 5){

		$fileId=`fopen $detailsFile "w"`;

		fprint $fileId ("abxAssetsVersion=1.0\n");
		fprint $fileId ("pubStatus="+$assetDetails[0]+"\n");
		fprint $fileId ("rigStatus="+$assetDetails[1]+"\n");
		fprint $fileId ("geoStatus="+$assetDetails[2]+"\n");
		fprint $fileId ("shdStatus="+$assetDetails[3]+"\n");
		fprint $fileId ("notes="+$assetDetails[4]+"\n");

		fclose $fileId;

	}
	else {
		Print ("Asset details not written, incorrect number of elements in AssetDetail array\n");
	}

}

global proc string[] abxAssetsGetAssetLog(string $assetPath){
	string $result[];
	string $tokenBuffer[];
	string $assetLib = "";
	string $assetType = "";
	string $assetName = "";
	string $assetDept = "";

	tokenize $assetPath "/" $tokenBuffer;
	if (size($tokenBuffer)>=3){
		$assetLib = $tokenBuffer[0];
		$assetType = $tokenBuffer[1];
		$assetName = $tokenBuffer[2];
	}
	else {
		warning ("Unknown assetPath:"+$assetPath+"\n");
		return {""};
	}
	string $logFile = (`workspace -q -rd`+$assetPath+"/"+$assetName+"_log.txt");
	
	if (`filetest -f ($logFile)`){
		 $fileId=`fopen $logFile "r"`;
			string $nextLine = `fgetline $fileId`;
			$result[size($result)] = $nextLine;
			while ( size( $nextLine ) > 0 ) {
				//print ( $nextLine );
				$nextLine = `fgetline $fileId`;
				$result[size($result)] = $nextLine;
			}
 		fclose $fileId;
		return $result;
	}
	else{
		//print ($logFile+" File not Found. Ignoring.\n");
		return {""};
	}
}

global proc abxAssetsWriteAssetLog (string $assetPath, string $updateWhat, string $version, string $note){

	string $tokenBuffer[];
	string $assetLib = "";
	string $assetType = "";
	string $assetName = "";
	string $assetDept = "";

	tokenize $assetPath "/" $tokenBuffer;
	if (size($tokenBuffer)>=3){
		$assetLib = $tokenBuffer[0];
		$assetType = $tokenBuffer[1];
		$assetName = $tokenBuffer[2];
	}
	else {
		error ("Unknown assetPath:"+$assetPath+"\n");
	}


	string $logFile = (`workspace -q -rd`+$assetLib+"/"+$assetType+"/"+$assetName+"/"+$assetName+"_log.txt");
	
	
	tokenize $updateWhat " " $tokenBuffer;
	string $process = toupper($tokenBuffer[1]);
	while (size($process)<10){
		$process+=" ";
	}
	string $dept = toupper($tokenBuffer[0]);
	while (size($dept)<10){
		$dept+=" ";
	}
	string $date = `date`;
	
	string $user = `getenv USER`;
	while (size($user)<10){
		$user+=" ";
	}	
	while (size($version)<10){
		$version+=" ";
	}
		
	

	$fileId=`fopen $logFile "a"`;
		//string $nextLine = `fgetline $fileId`;
		//while ( size( $nextLine ) > 0 ) {
		//	//print ( $nextLine );
		//	$nextLine = `fgetline $fileId`;
		//}
		//$nextLine = `fgetline $fileId`;
		
		
		//=====================
		//DATE	PROCESS	DEPT	VER	USER
		//
		//
		//
		
		
		fprint $fileId ($date+"\t"+$dept+"\t"+$process+"\t"+$version+"\t"+$user+"\t"+$note+"\n");

	fclose $fileId;



}

global proc string abxAssetsGetFriendlyDate(string $file){

	if (`filetest -r $file`){
		string $pyCmd = ("import os; import time; os.path.getmtime('"+$file+"');");

		string $modDate = python($pyCmd);
		string $curDate = python("time.time()");
		//print ("ModDate = "+$modDate+" curDate="+$curDate+"\n");
		int $mDate = int($modDate);
		int $cDate = int($curDate);
		int $day_diff = (($cDate - $mDate)/86400);
		int $second_diff = (($cDate - $mDate)%86400);

	    if ($day_diff < 1){
	        if ($second_diff < 10)
	            return "just now";
	        if ($second_diff < 60)
	            return ($second_diff+" seconds ago");
	        if ($second_diff < 120)
	            return  "a minute ago";
	        if ($second_diff < 3600)
	            return (( $second_diff / 60 )+" minutes ago");
	        if ($second_diff < 7200)
	            return ("an hour ago");
	        if ($second_diff < 86400)
	            return (($second_diff / 3600 )+" hours ago");
	    }
	    else if ($day_diff == 1)
	        return "Yesterday";
	    else if ($day_diff < 7)
	        return (($day_diff) + " days ago");
	    else if ($day_diff < 31)
	        return (($day_diff/7) + " weeks ago");
	    else if ($day_diff < 365)
	        return (($day_diff/30) + " months ago");
	    else 
	    	return (($day_diff/365) + " years ago");
	}
	else {
		return "Never";
	}
}

global proc string abxAssetsGetMDate(string $file){

	if (`filetest -r $file`){
		string $pyCmd = ("import os; import time; time.ctime(os.path.getmtime('"+$file+"'));");
		string $result = python($pyCmd);
		string $timeago = abxAssetsGetFriendlyDate($file);
		return ($result +"    ( "+$timeago+" )");
	}
	else {
		return "Never";
	}
}

global proc string abxAssetsGetMDateS(string $file){

	if (`filetest -r $file`){
		string $pyCmd = ("import os; import time;os.path.getmtime('"+$file+"');");
		string $result = python($pyCmd);
		return $result;
	}
	else {
		return "0";
	}
}

global proc assetStatusPrompt(string $assetPath, string $deptName,int $mode){

    // Get the dialog's formLayout.
    string $form = `setParent -q`;
		frameLayout -lv 1 -label ($deptName+" Status") -borderStyle "out" abxAssetsStatusFrmeLyt;
			columnLayout;
				separator -vis 1 -h 20;
				rowLayout -cw 1 20 -cw 2 200 -cw 2 200 -cw 3 200 -cw 4 20 -numberOfColumns 4;
					separator -vis 1;
					rowLayout -cw 1 20 -cw 2 205 -numberOfColumns 2 abxAssetsStatWinStageLyt;
						columnLayout;
							separator -vis 0 -h 5;
							intSlider -h 100 -horizontal false -min 0 -max 2 -value 0 -step 1 abxAssetsStatusWindowStageSlider;
						setParent ..;
						columnLayout -rs 5;
							button -w 120 -h 40 -label "Polishing" -ann "Polish: Smoothing has been approved, adding finishing touches" -c ("intSlider -e -value 2 abxAssetsStatusWindowStageSlider;");	
							button -w 120 -h 40 -label "Splining" -ann "Splining: Block has been approved. Animation is now being Smoothed out" -c ("intSlider -e -value 1 abxAssetsStatusWindowStageSlider;");
							button -w 120 -h 40 -label "Blocking" -ann "Blocking: Rough Timing of Animation. " -c ("intSlider -e -value 0 abxAssetsStatusWindowStageSlider;");
						setParent ..;
					setParent ..;
					rowLayout -cw 1 20 -cw 2 350 -numberOfColumns 2;
						columnLayout;
							//separator -vis 1 -h 3;
							intSlider -h 176 -horizontal false -min -2 -max 5 -value 0 -step 1 abxAssetsStatusWindowSlider;
						setParent ..;
						columnLayout -rs 1;
						//rowLayout -cw 1 95 -cw 2 95 -cw 3 95 -cw 4 95 -cw 5 95 -cw 6 95 -cw 7 95 -numberOfColumns 8;
							button -w 120 -label "Client Approved" -ann "Client Approved: Item has been approvd by the client" -bgc .15 .83 .77 -ebg 0 -c ("intSlider -e -value 5 abxAssetsStatusWindowSlider;");
							button -w 120 -label "Internal Approved" -ann "Internal Approved:  Item has been approved by in-house directors and is awaiting final client approval" -bgc .3 .7 .4 -ebg 0 -c ("intSlider -e -value 4 abxAssetsStatusWindowSlider;");
							button -w 120 -label "Pending Review" -ann "Review Needed: Item has had all notes and comments addressed and it is awaiting review for approval" -bgc .9 .85 .34 -ebg 0 -c ("intSlider -e -value 3 abxAssetsStatusWindowSlider;");
							button -w 120 -label "In Progress" -ann "Work In Progress: Item is actively being worked on" -bgc .7 .5 .3 -ebg 0 -c ("intSlider -e -value 2 abxAssetsStatusWindowSlider;");
							button -w 120 -label "Revision Needed" -ann "Revision Needed: Item requires changes to be addressed" -bgc .7 .3 .3 -ebg 0 -c ("intSlider -e -value 1 abxAssetsStatusWindowSlider;");
							button -w 120 -label "Not Started" -ann "Not Started: Item Has not been worked yet." -bgc .2 .2 .2 -ebg 0 -c ("intSlider -e -value 0 abxAssetsStatusWindowSlider;");
							button -w 120 -label "On Hold" -ann "On Hold: Work on the item is temporarily suspended." -bgc .2 .4 .7 -ebg 0 -c ("intSlider -e -value -1 abxAssetsStatusWindowSlider;");
							button -w 120 -label "Dead" -ann "Dead: Items set to this means Do Not Use them." -bgc .15 .15 .15 -ebg 0 -c ("intSlider -e -value -2 abxAssetsStatusWindowSlider;");
						setParent ..;
					setParent ..;
				separator -vis 1;
				setParent ..;
				separator -vis 1 -h 20;
			setParent ..;
		setParent ..;
		frameLayout -lv 1 -label "Revision Notes" -borderStyle "out" abxAssetsStatusNoteFrmeLyt;
			columnLayout -h 60 -adj 1 -cal "left" -cat "both" 3 -rs 3;
				text -label "Describe what you changed:";
				textField -h 80 -text "" -editable true abxAssetsStatusNotesField;
			setParent..;
		setParent $form;
		string $cmd = ("layoutDialog -dismiss (`intSlider -q -v abxAssetsStatusWindowSlider`+\"|\"+`intSlider -q -v abxAssetsStatusWindowStageSlider`+\"|\"+`textField -q -text abxAssetsStatusNotesField`);");
		button -h 40 -label ("Update Status and Notes") -c $cmd abxAssetsStatWinOKBtn;
		button -h 40 -label "Cancel" -c "layoutDialog -dismiss \"Cancel\"" abxAssetsStatWinCBtn;

		formLayout -e 

			-af abxAssetsStatusFrmeLyt "left" 3
			-af abxAssetsStatusFrmeLyt "top" 3 
			-an abxAssetsStatusFrmeLyt "bottom"
			-af abxAssetsStatusFrmeLyt "right" 3

			-af abxAssetsStatusNoteFrmeLyt "left" 3
			-ac abxAssetsStatusNoteFrmeLyt "top" 3 abxAssetsStatusFrmeLyt
			-af abxAssetsStatusNoteFrmeLyt "bottom" 55
			-af abxAssetsStatusNoteFrmeLyt "right" 3

			-af abxAssetsStatWinOKBtn "left" 0
			-an abxAssetsStatWinOKBtn  "top" 
			-af abxAssetsStatWinOKBtn "bottom" 3
			-ap abxAssetsStatWinOKBtn "right" 3 50

			-ap abxAssetsStatWinCBtn "left" 0 50
			-an abxAssetsStatWinCBtn  "top" 
			-af abxAssetsStatWinCBtn "bottom" 3
			-af abxAssetsStatWinCBtn "right"  3

			$form;

	if ($deptName != "anm")
		rowLayout -e -enable 0 abxAssetsStatWinStageLyt;

	if ($mode == 1 || $mode == 2){
		button -e -vis 0 abxAssetsStatWinCBtn;
		formLayout -e -ap abxAssetsStatWinOKBtn "right" 3 100 $form;
	}

	if ($mode == 2){
		textField -e -text (`getenv USERNAME`+" is too lazy to leave a useful note. Just assume they tumbled in thier viewport for 3 hours and then clicked save.") abxAssetsStatusNotesField;
		button -e -label ("Last Chance To Leave a Note") abxAssetsStatWinOKBtn;
	}
	// set the slider to the current status
	
	string $assetDetails[] = `abxAssetsGetAssetDetails $assetPath`;
	if (size($assetDetails) > 4){
		//print $assetDetails;
		if ($deptName == "pub"){
			if ($assetDetails[0] != "") {
				int $val = int($assetDetails[0]);
				intSlider -e -v $val abxAssetsStatusWindowSlider;
			}
		}
		else if ($deptName == "rig"){
			if ($assetDetails[1] != "") {
				int $val = int($assetDetails[1]);
				intSlider -e -v $val abxAssetsStatusWindowSlider;
			}
		}
		else if ($deptName == "geo"){
			if ($assetDetails[2] != "") {
				int $val = int($assetDetails[2]);
				intSlider -e -v $val abxAssetsStatusWindowSlider;
			}
		}
		else if ($deptName == "shd"){
			if ($assetDetails[3] != "") {
				int $val = int($assetDetails[3]);
				intSlider -e -v $val abxAssetsStatusWindowSlider;
			}
		}
	}
}

global proc string abxAssetsStatusWindowShowUI (string $assetPath, string $deptName, int $mode){

	string $result = "";
	$result = `layoutDialog -title ($assetPath+" Status Update and Notes") -ui ("assetStatusPrompt(\""+$assetPath+"\",\""+$deptName+"\","+$mode+")")`;
	
	if ($result != "Cancel" && $result != "dismiss") {
		string $tokenBuffer[];
		tokenize $result "|" $tokenBuffer;
		int $status =  $tokenBuffer[0];
		int $stage = $tokenBuffer[1];
		$note = $tokenBuffer[2];
		abxAssetsStatusWindowSetStatus $assetPath $deptName $mode $status $stage $note;
		return $note;
	}
	else {
		return "";
	}
}


global proc string abxAssetsStatAsColor (int $status){
	string $strStatus = $status;
	string $result = "";
	
	switch ($strStatus){
		case "-2":
			$result = ".15 .15 .15";
			break;
		case "-1":
			$result = ".2 .4 .7";
			break;
		case "0":
			$result = ".27 .27 .27";
			break;
		case "1":
			$result = ".7 .3 .3"; //179 77 77
			break;
		case "2":
			$result = ".7 .5 .3";
			break;
		case "3":
			$result = ".9 .85 .34"; // 230 217 87
			break;
		case "4":
			$result = ".3 .7 .4";
			break;
		case "5":
			$result = ".15 .83 .77"; //38 212 197
			break;
		}
	return $result;
}

global proc string abxAssetsStageAsLabel(int $stage){
	string $strStage = $stage;
	string $result = "";
	string $ppTools = `getenv MAYA_PPTOOLS`;
	
	switch ($strStage){
		case "0":
			$result = ($ppTools+"/icons/stat1.png"); // Blocking
			break;
		case "1":
			$result = ($ppTools+"/icons/stat2.png"); // Splining
			break;
		case "2":
			$result = ($ppTools+"/icons/stat3.png"); // Polish
			break;
	}
	return $result;
}

global proc string abxAssetsStatAsLabel(int $status){
	string $strStatus = $status;
	string $result = "";
	
	switch ($strStatus){
		case "-2":
			$result = "Dead";
			break;
		case "-1":
			$result = "On Hold";
			break;
		case "0":
			$result = "Not Started"; //".27 .27 .27";
			break;
		case "1":
			$result = "Revision Needed";
			break;
		case "2":
			$result = "In Progress";
			break;
		case "3":
			$result = "Pending Review";
			break;
		case "4":
			$result = "Internal Approved";
			break;
		case "5":
			$result = "Client Approved";
			break;
		}
	return $result;
}

global proc int abxAssetsTVBtnG (string $assetPath, int $state){
	abxAssetsStatusWindowShowUI $assetPath "geo" 0;
	return 1;
}
global proc int abxAssetsTVBtnS (string $assetPath, int $state){
	abxAssetsStatusWindowShowUI $assetPath "shd" 0;
	return 1;
}
global proc int abxAssetsTVBtnR (string $assetPath, int $state){
	abxAssetsStatusWindowShowUI $assetPath "rig" 0;
	return 1;
}
global proc int abxAssetsTVBtnP (string $assetPath, int $state){
	abxAssetsStatusWindowShowUI $assetPath "pub" 0;
	return 1;
}

global proc abxAssetsStatusWindowSetStatus (string $assetPath, string $deptName, int $mode, int $status, int $stage, string $note){

	string $updateWhat;

	string $listControl = "abxAssetsTreeView";
	string $color = `abxShotsStatAsColor $status`;
	string $label = `abxShotsStageAsLabel $stage`;
	string $setColorCmd = ("treeView -e ");
	$setColorCmd += ("-btc \""+$assetPath+"\" ");

	switch ($deptName){
		case "geo":
			$updateWhat = "geo status";
			$setColorCmd += "1";
			break;
		case "rig":
			$updateWhat = "rig status";
			$setColorCmd += "3";
			break;
		case "shd":
			$updateWhat = "shd status";
			$setColorCmd += "2";
			break;
		case "pub":
			$updateWhat = "pub status";
			$setColorCmd += "3";
			break;
		}
		$setColorCmd += (" "+$color+" ");

	$setColorCmd += $listControl;
	catchQuiet(evalEcho($setColorCmd));	

	string $updateValue = $status;
	// get the UI value and set the details
	evalEcho ("abxAssetsUpdateDetailsFromScene \""+$assetPath+"\" \""+$updateWhat+"\" \""+$updateValue+"\" ");

	// log the status change
	if ($mode == 0){
		string $note = (abxAssetsStatAsLabel($status)+": "+$note);;
		evalEcho("abxAssetsWriteAssetLog \""+$assetPath+"\" \""+$updateWhat+"\" \"---\" \""+$note+"\"");
	}

	string $filePath = (`workspace -q -rd`+$assetPath);
/*
	global int $dbExists;
	print ($filePath+"\n");
	string $cmd = ("R.Asset.getFromPath('"+$filePath+"').save();");
	print ($cmd+"\n");

	if ($dbExists == true){
		$fail = catch(python($cmd));
	}
	*/
}


// gets a list of all the found assets in the scene
global proc string[] abxAssetsGetAssetsInScene (){

	// find all referenced assets
	string $results[];
	string $refNodes[] = `file -q -r`;
	for ($each in $refNodes){
		$isUnloaded = false;
		string $refNodeName = `referenceQuery -rfn $each`;
		string $filePathWCN = `referenceQuery -filename -wcn $each`;
		string $namespace = `file -q -namespace $each`;
		if (`gmatch $filePathWCN "*assets*"`){
			string $regularExpr = "assets/[a-zA-Z0-9]+/[a-zA-Z0-9]+";
			string $assetName = `match $regularExpr $filePathWCN`;
			$results[size($results)] = ($assetName+"|"+$each);
		}
	}	
	/*
	string $foundNamespaces[] = `namespaceInfo -lon -r`;
	
	for ($each in $foundNamespaces){
		
		if ($each != "shared" && $each != "UI"){
			if (`objExists ($each+":ROOT")`){
				$results[size($results)] = $each;
			}
		}
	}
	*/

	return $results;
	// assets are objects which have a ROOT && a namespace
	// they can be either referenced or imported as long as they have the above criteria
	// references can be reloaded or re-imported
	// they can be delete/removed, their animation can be transferred or exported

}
// given an asset with a namespace in a lighting file, it will return the base asset name
global proc string abxAssetsGetShortAssetName (string $fullAssetName){
	string $tokenBuffer[];
	tokenize $fullAssetName ":" $tokenBuffer;
	return $tokenBuffer[size($tokenBuffer)-1];
}


// given an asset path or determined from the current scene file export the shaders to the shader group
global proc abxAssetsExportAssetShaders (string $assetPath)  {

	eval("source \""+`getenv MAYA_PPTOOLS`+"/scripts/Toolbox/Lighting/abxExportShaderMel.mel\"");
	string $scnNameShort = basenameEx(`file -q -shn -sn`);
	string $assetLib = "";
	string $assetType = "";
	string $assetName = "";

	if ($assetPath != "")  {
		string $tokenBuffer[];
		tokenize $assetPath "/" $tokenBuffer;
		if (size($tokenBuffer) == 3)  {
			$assetName = $tokenBuffer[2];
			string $tokenBuffer2[];
			tokenize $scnNameShort "_" $tokenBuffer2;
			string $workVersionGuess = $tokenBuffer2[size($tokenBuffer2)-1];
			if (size($workVersionGuess) == 4){
				// find all the shading groups.
				string $allSGNodes[] = `ls -type shadingEngine`;
				string $exludeSGs[] = { "initialShadingGroup", "initialParticleSE" };
				string $sgNodes[] = stringArrayRemove($exludeSGs, $allSGNodes);

				// test SG node list to make sure they are connected to something
				string $sgNodesUsed[];
				for ($sg in $sgNodes)  {
					if (size(`sets -q $sg`) > 0)
						$sgNodesUsed[size($sgNodesUsed)] = $sg;
				}
				for ($i=0;$i<size($sgNodesUsed);$i++){
				//for ($sg in $sgNodesUsed){

					// correct the names of the shading groups if they are wrong
					string $tokenBuffer[];
					tokenize $sgNodesUsed[$i] ":" $tokenBuffer;
					string $fixedName = $tokenBuffer[size($tokenBuffer)-1];
					if (size($tokenBuffer)>1){
						string $fixedName = $tokenBuffer[size($tokenBuffer)-1];
						$result = `rename  $sgNodesUsed[$i] $fixedName`;
						 $sgNodesUsed[$i] = $result;
					}

					// add/update the assetPath to the shading group attr
					if (!`attributeExists "assetPath"  $sgNodesUsed[$i]`)
						addAttr -longName "assetPath" -dt "string"  $sgNodesUsed[$i];
					setAttr -type "string" ( $sgNodesUsed[$i]+".assetPath") $assetPath;
					// add/update the shader version to the shading group attr
					if (!`attributeExists "shaderVersion"  $sgNodesUsed[$i]`)
						addAttr -longName "shaderVersion" -dt "string"  $sgNodesUsed[$i];
					setAttr -type "string" ( $sgNodesUsed[$i]+".shaderVersion") $workVersionGuess;
					// add/update the date/time stamp
					if (!`attributeExists "shaderDate"  $sgNodesUsed[$i]`)
						addAttr -longName "shaderDate" -dt "string"  $sgNodesUsed[$i];
					setAttr -type "string" ( $sgNodesUsed[$i]+".shaderDate") `date`;			
					// add/update the user name who is doing the master
					if (!`attributeExists "shaderUser"  $sgNodesUsed[$i]`)
						addAttr -longName "shaderUser" -dt "string"  $sgNodesUsed[$i];
					setAttr -type "string" ( $sgNodesUsed[$i]+".shaderUser") `getenv USER`;	
					// add/update the current scene path to the shading group attr
					if (!`attributeExists "shaderSource"  $sgNodesUsed[$i]`)
						addAttr -longName "shaderSource" -dt "string"  $sgNodesUsed[$i];
					setAttr -type "string" ( $sgNodesUsed[$i]+".shaderSource") `file -q -sn`;	
				}

				// create a folder with the asset name and the shading version in asset/shaders/master eg. (Kaos/shaders/master/Kaos_shd_master_v001/shadingGroup.mel)
				string $masterFolderPath = (`workspace -q -rd`+$assetPath+"/shaders/master/"+$assetName+"_shd_master_"+$workVersionGuess+"/");
				if (`filetest -d $masterFolderPath` == false){
					evalEcho ("sysFile -makeDir \"" + $masterFolderPath + "\"");
				}

				// delete any files in the shader dir
				string $existingFiles[] = `getFileList -folder $masterFolderPath`;
				if (size($existingFiles) > 0)  {
					for ($f in $existingFiles)
						sysFile -delete ($masterFolderPath + $f);
				}

				// export each shading group to the destination folder
				exportShadingNetworkMEL $sgNodesUsed {$masterFolderPath};
			}
			else {
				error "Could not determine scene version number";
			}
		}
	}
}

global proc string[] cbxAssetsGetLatestAssetShaderInfo (string $assetPath)  {
	string $shaderTopFolder = (`workspace -q -rd` + "/" + $assetPath + "/shaders/master/"); // must have / at end!
	string $shaderFolders[] = `getFileList -folder $shaderTopFolder`;
	string $versMaxStr = "";
	string $versMaxShaderFolderStr = "";
	int $versMax = 0;
	for ($sf in $shaderFolders)  {
		string $versStr = endString($sf, 4);
		if (isValidString($versStr, "v[0-9][0-9][0-9]"))  {
			int $versInt = int(endString($versStr, 3));
			if ($versInt > $versMax)  {
				$versMaxStr = $versStr;
				$versMaxShaderFolderStr = $sf;
				$versMax = $versInt;
			}
		}
	}
	return {$versMaxStr, $versMaxShaderFolderStr};
}

global proc reportPrompt(string $message, string $list)
{
    // Get the dialog's formLayout.
    string $form = `setParent -q`;

    formLayout -e -width 500 -height 300 $form;

    string $t = `scrollField reportPromptSF`;

    string $lbl = `text -ww 1 -label $message`;

    string $newList = substituteAllString($list, ",", "\n");
    scrollField -e -text $newList $t;

    string $b1 = `button -l "Ignore" -c "layoutDialog -dismiss \"Ignore\""`;
    string $b2 = `button -l "Move to Asset's sourceimages" -c "layoutDialog -dismiss \"Fix\""`;
    string $b3 = `button -l "Abort" -c "layoutDialog -dismiss \"Abort\""`;

    int $spacer = 5;
    int $top = 5;
    int $edge = 5;

    formLayout -edit


        -attachForm            $t   "top"    $top 
        -attachForm            $t   "left"   $edge
        -attachControl         $t   "bottom"  20 $lbl
        -attachForm            $t   "right"  $edge

        -attachNone            $lbl   "top"   
        -attachForm            $lbl   "left"   ($edge+20)
        -attachControl         $lbl   "bottom" ($spacer+20) $b1
        -attachForm            $lbl   "right"  ($edge+20)

        -attachOppositeForm    $b1  "top"    (-25-$spacer)
        -attachForm            $b1  "left"   $edge
        -attachNone            $b1  "bottom"
        -attachPosition        $b1  "right"  $spacer 33

        -attachOppositeForm    $b2  "top"    (-25-$spacer)
        -attachPosition        $b2  "left"   $spacer 33
        -attachNone            $b2  "bottom"
        -attachPosition        $b2  "right" $edge 66

        -attachOppositeForm    $b3  "top"    (-25-$spacer)
        -attachPosition        $b3  "left"   $spacer 66
        -attachNone            $b3  "bottom"
        -attachForm            $b3  "right" $edge

    $form;
}

// checks for vray attributes for subdivision settings
global proc abxAssetsVraySubDCheck (){
	string $meshes[] = `ls -type mesh`;

	for ($each in $meshes){
		if (!`attributeExists "vraySubdivEnable" $each`){
			addAttr -longName "vraySubdivEnable" -at "long" $each;
			setAttr ($each+".vraySubdivEnable") 1;
		}
		if (!`attributeExists "vraySubdivUVsAtBorders" $each`){
			addAttr -longName "vraySubdivUVsAtBorders" -at "long" $each;
			setAttr ($each+".vraySubdivUVsAtBorders") 1;
		}
		if (!`attributeExists "vraySubdivUVs" $each`){
			addAttr -longName "vraySubdivUVs" -at "long" $each;
			setAttr ($each+".vraySubdivUVs") 1;
		}
		if (!`attributeExists "vrayStaticSubdiv" $each`){
			addAttr -longName "vrayStaticSubdiv" -at "long" $each;
			setAttr ($each+".vrayStaticSubdiv") 0-9;
		}
		if (!`attributeExists "vrayOverrideGlobalSubQual" $each`){
			addAttr -longName "vrayOverrideGlobalSubQual" -at "long" $each;
			setAttr ($each+".vrayOverrideGlobalSubQual") 1;
		}
		if (!`attributeExists "vrayViewDep" $each`){
			addAttr -longName "vrayViewDep" -at "long" $each;
			setAttr ($each+".vrayViewDep") 1;
		}
		if (!`attributeExists "vrayEdgeLength" $each`){
			addAttr -longName "vrayEdgeLength" -at "float" $each;
			setAttr ($each+".vrayEdgeLength") 4.0;
		}
		if (!`attributeExists "vrayMaxSubdivs" $each`){
			addAttr -longName "vrayMaxSubdivs" -at "long" $each;
			setAttr ($each+".vrayMaxSubdivs") 3;
		}
	}
}

// conforms shape node names to match their parents
// <parentName>Shape<parentNumber>
global proc abxAssetsConformAllShapeNames (){
// 

	// build the list by first getting root objects in dag

	//select -clear;
    //select `ls -as long`;
    //select `listRelatives -fullPath -ad`
    //select -deselect `ls -fullPath -referencedNodes`;
    //select -deselect `ls -ud`;

    $sel = `ls -as -long`;
    for ($each in $sel){
    	$descendents = `listRelatives -ad -fullPath $each`;
    	string $every;
    	for ($every in $descendents){
    		// if it is a shape node
    		if (size(`ls -shapes $every`)>0){

    			// find the first parent used for naming (especially instance nodes so they have their first parents name)
    			string $parents[] = `listRelatives -fullPath -allParents $every`;
				string $tokenBuffer2[];
				tokenize $parents[0] "|" $tokenBuffer2;
				$parentShortName = $tokenBuffer2[size($tokenBuffer2)-1];

				// find the actual dag path parent
				string $tokenBuffer3[];
				tokenize $every "|" $tokenBuffer3;
				$pathParent = ("|"+$tokenBuffer3[0]);
				for ($i=1;$i<size($tokenBuffer3)-1;$i++){
					$pathParent += ("|"+$tokenBuffer3[$i]);
				}

				string $parentNumber = `match "[0-9]+$" $parentShortName`;
				int $size = size($parentShortName) - size($parentNumber);		
				string $nameMinusNum = substring($parentShortName,1,$size);

				string $conformName = ($pathParent+"|"+$nameMinusNum+"Shape"+$parentNumber);
	            //print ("comparing "+$every+" to "+$conformName+"\n");
				if ($every != $conformName){
					//print ("fixing "+$every+" to "+$conformName+"\n");

					int $index = 1;
					string $uniqueConformName = $conformName;
					while (`objExists $uniqueConformName`){
						$uniqueConformName = ($conformName+"_"+$index);
						$index++;
					}

					string $tokenBuffer[];
					tokenize $uniqueConformName "|" $tokenBuffer;
					$shortName = $tokenBuffer[size($tokenBuffer)-1];
					//print ("rename "+$every+" "+$shortName+"\n");
					evalEcho("rename "+$every+" "+$shortName);   
				}
		
    		}
    	}
    }
/*
    $sel = `ls -sl -long`;
    string $each;
	for ($each in $sel){
		string $shapes[] = `listRelatives -fullPath -shapes $each`;
		for ($every in $shapes){
		    // get the first parent if its instanced
		    string $parents[] = `listRelatives -fullPath -allParents $every`;
		    // if the objects parent is the original parent (for instances it would be the first parent found)
		    //print ("comparing "+$each+" to "+$parents[0]+"\n");
		    if ($each == $parents[0]){
				string $tokenBuffer2[];
				tokenize $parents[0] "|" $tokenBuffer2;
				$parentShortName = $tokenBuffer2[size($tokenBuffer2)-1];
				string $parentNumber = `match "[0-9]+$" $parentShortName`;
				int $size = size($parentShortName) - size($parentNumber);			
				string $nameMinusNum = substring($parentShortName,1,$size);

				string $conformName = ($each+"|"+$nameMinusNum+"Shape"+$parentNumber);
	            //print ("comparing "+$every+" to "+$conformName+"\n");
				if ($every != $conformName){
					//print ("fixing "+$every+" to "+$conformName+"\n");

					int $index = 1;
					string $uniqueConformName = $conformName;
					//while (`objExists $uniqueConformName`){
					//	$uniqueConformName = ($conformName+$index);
					//}
					string $tokenBuffer[];
					tokenize $uniqueConformName "|" $tokenBuffer;
					$shortName = $tokenBuffer[size($tokenBuffer)-1];
					print ("rename "+$every+" "+$shortName+"\n");
					//evalEcho("rename "+$every+" "+$shortName);
				}	
			}	
		}
	}
	select -clear;
	*/
}

global proc abxAssetsClearFailedEdits (){
		string $refNodes[] = `file -q -r`;
		for ($each in $refNodes){
			string $refNodeName = `referenceQuery -rfn $each`;
			referenceEdit -failedEdits true -successfulEdits false -removeEdits $refNodeName;
		}
}

global proc abxAssetsRestoreShapeRenderProperties (int $force){

	// remove any edits to objects with "Shape" in their name (horrible i know. needs to test object for type)
	editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;
	string $excludeEditRemoveAttributes[] = {"uvSet","instObjGroups","objectGroups","uvSetName","objectGroupId","scale", "rootThickness","rootSplay", "disableDynamics","enableCollision","stiffness","rootStiffness","dampening","blindShaveData"};

	$allowableMultiAttrTypes = { "double2", "double3", "double4", "float2", "float3", "float4", "short2", "short3", "long2", "long3", "stringArray", "doubleArray", "floatArray" };
	$allowableAttrTypes = {"float","long","double","short","int","bool","enum"};


	

	// removes setAttr edits on any node found to be an intermediate object thats a shape node
	string $refNodes[] = `file -q -r`;
	for ($each in $refNodes){

		string $rmvEditCmds[];

		$isUnloaded = false;
		string $refNodeName = `referenceQuery -rfn $each`;
		string $namespace = `file -q -namespace $each`;
		string $editCommands[] = `referenceQuery -failedEdits false -successfulEdits true -editCommand "setAttr" -editNodes -editAttrs $each`;
		for ($every in $editCommands){
			//print ("// Checking Edit Command "+$every+"\n");
			// if its a geo and a parent command then its probably a deformed shape
			if (`gmatch $every "*Shape*"`){
				if (!`gmatch $every "*intermediate*"` && !`gmatch $every "*.pt*"`){
					/*
					if ($isUnloaded == false){
						evalEcho("file -unloadReference \""+$refNodeName+"\"");
						$isUnloaded = true;
					}
					*/

					string $tokenBuffer[];
					tokenize $every "." $tokenBuffer;
					
					//if (`nodeType $tokenBuffer[0]` != "shaveHair"){
						if (!stringArrayContains($tokenBuffer[size($tokenBuffer)-1], $excludeEditRemoveAttributes))
							$rmvEditCmds[size($rmvEditCmds)] = ("referenceEdit -failedEdits false -successfulEdits true -removeEdits  \""+$every+"\"");
							//evalEcho("referenceEdit -failedEdits false -successfulEdits true -removeEdits  \""+$every+"\"");
					//}
				}
			}
		}

		// unload then remove the edits that have been marked for removal then reload the reference
		if ($isUnloaded == false){
			evalEcho("file -unloadReference \""+$refNodeName+"\"");
			$isUnloaded = true;
		}
		for ($every in $rmvEditCmds){
			evalEcho($every);
		}

		if ($isUnloaded == true){
			evalEcho("file -loadReference \""+$refNodeName+"\"");
		}


	}






	// check for deformed shapes and make sure other children of the deformed shape have same attributes
	string $foundDeformed[];
	for ($each in $refNodes){

		string $refNodeName = `referenceQuery -rfn $each`;
		string $namespace = `file -q -namespace $each`;
		string $editCommands[] = `referenceQuery -failedEdits false -successfulEdits true -editCommand "setAttr" -editNodes -editAttrs $each`;
		for ($every in $editCommands){
			//print ("// Checking Edit Command "+$every+"\n");
			// if its a geo and a parent command then its probably a deformed shape
			if (`gmatch $every "*Shape*"`){
				if (`gmatch $every "*intermediate*"`){
					string $tokenBuffer[];
					tokenize $every "." $tokenBuffer;
					$foundDeformed[size($foundDeformed)] = $tokenBuffer[0];
				}
			}
		}
	}	

	// remove duplicates of found deformed
	string $noDupes[] =  `stringArrayRemoveDuplicates($foundDeformed)`;

	if (size($noDupes)>0){
		print ("// Found Deformed\n");
		print $noDupes;
	}

	for ($each in $noDupes){
		
		// get the parent of the intermediate shape
		string $parents[] = `listRelatives -parent -fullPath $each`;
		// get the children of the intermediate shape
		string $childrenShapes[] = `listRelatives -shapes -fullPath $parents[0]`;

		for ($every in $childrenShapes){
			// if the object is not the original shape node and its not a referenced object
			if ($every != $each && !`referenceQuery -inr $every`){
				// apply settings from $each to $every

				string $attrsToCopy[] = {"castsShadows","receiveShadows","motionBlur","primaryVisibility","smoothShading","visibleInReflections","visibleInRefractions","doubleSided","opposite","geometryAntialiasingOverride","shadingSamplesOverride","maxShadingSamples","shadingSamples","antialiasingLevel","geometryAntialiasingOverride","shadingSamplesOverride"};
				string $pluginAttrs[] = `listAttr -fromPlugin $each`;
				string $userAttrs[] = `listAttr -userDefined $each`;
				string $settableAttrs[] = stringArrayCatenate($attrsToCopy,$pluginAttrs);
				string $settableAttrs2[] = stringArrayCatenate($settableAttrs,$userAttrs);
				for ($s in $settableAttrs2){
					//if (!catch(eval("getAttr "+$each+"."+$s))){
					if (catch(`getAttr -type ($each + "." + $s)`) == 0){
						string $attrType = `getAttr -type ($each + "." + $s)`;		

						string $setAttrCmd = "";
						string $typeFlag = "";
						string $attrValStr = "";
						if ($attrType == "string" || $attrType == "stringArray")  {
							//$attrType = ("\"" + $attrType + "\"");
							if ($attrType == "stringArray")  {
								string $attrStrs[] = `getAttr ($each + "." + $s)`;
								for ($attrStr in $attrStrs)
									$attrValStr += (" \"" + $attrStr + "\"");
								$typeFlag = " -type \"stringArray\"";
							} else  {
								string $attrStr = `getAttr ($each + "." + $s)`;
								$attrValStr = (" \"" + $attrStr + "\"");
								$typeFlag = " -type \"string\"";
							}
						} else if (stringArrayContains($attrType, $allowableMultiAttrTypes))  {
							float $attrVals[] = `getAttr ($each + "." + $s)`;
							for ($attrVal in $attrVals)
								$attrValStr += (" " + $attrVal);
							$typeFlag = (" -type " + $attrType);
						} else if (stringArrayContains($attrType, $allowableAttrTypes))  {
							float $attrVal = `getAttr ($each + "." + $s)`;
							$attrValStr = (" " + $attrVal);
							$typeFlag = "";
						}
						
							$setAttrCmd = ("setAttr \""+$every+"."+$s+"\" "+$typeFlag+$attrValStr);
							
						if ($attrValStr != ""){
							//print ($setAttrCmd+"\n");
							catch(eval($setAttrCmd));
						}
						else{
							print ("// skipping type "+$attrType+": "+$setAttrCmd+"\n");
						}
					}

						//$val = `getAttr ($each+"."+$s)`;
						//if (size($val) > 0)
						//catch(evalEcho("setAttr \""+$every+"."+$s+"\" "+$val));
					//}
				}
			}
		}
	}
}

// restores the reference shader assignmnet to the deformed shapes
global proc abxAssetsRestoreDeformedShader (int $force){

	// set to the default render layer before processing
	editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;

	string $foundDeformed[];
	string $setAttrCmds[];

	string $refNodes[] = `file -q -r`;
	for ($each in $refNodes){
		string $refNodeName = `referenceQuery -rfn $each`;
		string $namespace = `file -q -namespace $each`;
		string $editCommands[] = `referenceQuery -failedEdits false -successfulEdits true -editCommand "parent" -editStrings $each`;
		string $oldSetAttrCmds[] = $setAttrCmds;
		string $newSetAttrCmds[] = `referenceQuery -failedEdits false -successfulEdits true -editCommand "setAttr" -editStrings $each`;
		$setAttrCmds = stringArrayCatenate($oldSetAttrCmds,$newSetAttrCmds);
		for ($every in $editCommands){
			//print ("// Checking Edit Command "+$every+"\n");
			// if its a geo and a parent command then its probably a deformed shape
			if (`gmatch $every "*geo_*"`){
				// if its an instance ignore it as a potential suspect
				//if (!`gmatch $every "parent -s -r -add *"`){
				//print ("GeoEdit:"+$every+"\n");
					string $tokenBuffer[];
					tokenize $every " " $tokenBuffer;
					string $editCmd = $tokenBuffer[0];
					string $editTarget = "";
					string $editSource = "";
					if ($editCmd == "parent"){
						//print ($every+"\n");
						// shading engine (sg) name

						$editTarget = $tokenBuffer[4];
						$editSource = $tokenBuffer[3];

						if ($editTarget != ""){
							
							//print ("editTarget="+$editTarget+"\n");
							// if the target is not referenced object but a deformed shape add it to the list of found deformed
							if (size(`ls -rn $editSource`) == 0)
								//print ("// adding Edit String To Array\n");
								$foundDeformed[size($foundDeformed)] = $editTarget;
								//print ("// done Edit String To Array\n");
						}
					}
				//}
			}
		}
	}

	if (size($foundDeformed)>0){
		print ("Found Deformed\n");
		print $foundDeformed;
	}

	// parse through the found deformed and make it assign the intermediate
	/*
	string $intermediateCmds[];
	for ($es in $setAttrCmds){
		if (`gmatch $es "*intermediate*"`){
			$intermediateCmds[size($intermediateCmds)] = $es;
		}
	}
	*/

	for ($each in $foundDeformed){
		string $cmd = ("listRelatives -shapes -fullPath "+$each);
		$childrenShapes = eval($cmd);
		if (size($childrenShapes) > 1){
			string $shapeTurnedIntermediate = "";
			// find the shape that has a reference edit that turns it into an intermediate object and use this as the source of the shader assignment
			for ($every in $childrenShapes){
				if (`referenceQuery -inr $every`){
					//for ($es in $intermediateCmds){
					//	if (`gmatch $es "*intermediate*"`){
							$shapeTurnedIntermediate  = $every;
					//	}
					//}
				}
			}			
			// if there was an instanced geo turned intermediate get its shader and assign it to the other shape nodes
			if ($shapeTurnedIntermediate != ""){
				string $shadingGroups[] = `listConnections -type "shadingEngine" -s 1 ($shapeTurnedIntermediate+".instObjGroups[0]")`;
				string $faceShadingGroups[] = `listConnections -type "shadingEngine" -s 1 ($shapeTurnedIntermediate+".instObjGroups[0].objectGroups[0]")`;
				if (size($shadingGroups) > 0){
					for ($i=1;$i<size($childrenShapes);$i++){
						if (!`referenceQuery -inr $childrenShapes[$i]`){
							evalEcho("sets -e -forceElement "+$shadingGroups[0]+" "+$childrenShapes[$i]);
						}
					}
				}
				else if (size($faceShadingGroups) > 0){
					for ($i=1;$i<size($childrenShapes);$i++){
						if (!`referenceQuery -inr $childrenShapes[$i]`){
							evalEcho("sets -e -forceElement "+$faceShadingGroups[0]+" "+$childrenShapes[$i]);
						}
					}					
				}
			}
		}
	}
}

// retargets missing shape nodes to point to the conformed shape node names
global proc abxAssetsRestoreRenamedShapeNames (){

	string $foundTargets[];
	string $each;
	// get the failed edits
	$failedEdits = `referenceQuery -failedEdits 1 -successfulEdits 0 -editStrings geoRN`;
	for ($each in $failedEdits){
		string $tokenBuffer[];
		tokenize $each " " $tokenBuffer;
		string $editCommand = $tokenBuffer[0];
		string $target;
		if ($editCommand == "addAttr")
			$target = $tokenBuffer[size($tokenBuffer)-1];
		else if ($editCommand == "setAttr")
			$target = $tokenBuffer[1];
		else if ($editCommand == "connectAttr")
			$target = $tokenBuffer[1];
		else if ($editCommand == "disconnectAttr")
			$target = $tokenBuffer[2];
		else if ($editCommand == "parent")
			$target = $tokenBuffer[1];
			
			
		string $tokenBuffer3[];
		tokenize $target "." $tokenBuffer3;
		
		if (!`objExists $tokenBuffer3[0]`){
		    //print ( $tokenBuffer3[0]+"\n");
			$foundTargets[size($foundTargets)] = $tokenBuffer3[0];
		}
	}

	string $missingNodes[] = stringArrayRemoveDuplicates ($foundTargets);
	//print $missingNodes;
	string $reTargets[];

	for ($each2 in $missingNodes){
		string $tokenBuffer2[];
		tokenize $each2 "|" $tokenBuffer2;
		string $shortName = $tokenBuffer2[size($tokenBuffer2)-1];
		string $parentName = "";
		if (size($tokenBuffer2)>1)
			$parentName = $tokenBuffer2[size($tokenBuffer2)-2];

		if ($parentName != ""){
			string $parentNumber = `match "[0-9]+$" $parentName`;
			int $size = size($parentName) - size($parentNumber);		
			string $nameMinusNum = substring($parentName,1,$size);
			string $conformName = ($nameMinusNum+"Shape"+$parentNumber);
			//print ("$each2="+$each2+"\n$shortName="+$shortName+"\n$parentName="+$parentName+"\n$conformName="+$conformName+"\n");
			$reTargets[size($reTargets)] = "referenceEdit -cet \""+$shortName+"\" \""+$conformName+"\" geoRN";

		}
	}

	print $reTargets;
}


global proc abxAssetsFixStoryNeonRefs(){
	string $refNodes[] = `file -q -r`;
	for ($each in $refNodes){
		$isUnloaded = false;
		string $refNodeName = `referenceQuery -rfn $each`;
		string $filePathWCN = `referenceQuery -filename -wcn $each`;
		string $namespace = `file -q -namespace $each`;
		if (`gmatch $each "N:*"`){
			string $regularExpr = "N:/STORY2012_PP10088/3D/story2012_maya";
			string $fixedPath = `substitute $regularExpr $filePathWCN "M:/STORY2012_PP10088/3D/STORY2012_maya"`;

			evalEcho("file -loadReference "+$refNodeName+" \""+$fixedPath+"\"") ;
		}
	}
}

// removes all but original shape nodes
global proc abxAssetsRemoveExtraShapeNodes() {

    string $nodesTocheck[] = `ls -type transform -dag`;
    string $each;
    for ($each in $nodesTocheck){
        $childShapes = `listRelatives -shapes $each`;
        if (size($childShapes)>1){
            print ($each+" has more than one shape\n");
            for ($i = 1;$i<size($childShapes);$i++){
                delete $childShapes[$i];
            }
        }
    }

}

global proc abxAssetsCheckForProps (string $refNodes[]){

	if (size($refNodes)==1 && $refNodes[0] == "")
		$refNodes = `file -q -r`;

	

	for ($each in $refNodes){
		string $requiredProps[];
		clear($requiredProps);
		$isUnloaded = false;
		string $refNodeName = `referenceQuery -rfn $each`;
		string $filePathWCN = `referenceQuery -filename -wcn $each`;
		string $namespace = `file -q -namespace $each`;
		// if its a set or vehicle asset
		if (`gmatch $each "*/sets/*"` || `gmatch $each "*/vehicles/*"`){
			// search namespace for _PROP_ locators
			//print ("Found Asset "+$each+" to be a set or vehicle\n");
			string $prefix = ($namespace+":geo__PROP_*");
			$foundProps = `ls -type transform $prefix`;
			string $every;
			for ($every in $foundProps){
				//print ("$foundProps="+$every+"\n");

				// if its not an instance locator
				if (!`gmatch $every "*INST*"`){

					// get the propName from the locator
					string $propName = `substitute $prefix $every ""`;
					//print ("propName=" + $propName+"\n");
					int $endStr = size($propName);
					int $endStr2 = $endStr - 1;

					// strip off underscore on end if it exists
					string $result = `substring $propName $endStr $endStr`;
					//print ("Result="+$result+"\n");
					if ($result == "_"){
						$propName = `substring $propName 1 $endStr2 `;
					}
					//print ("Asset Namespace:"+$propName+"\n");


					// check if there is already a reference to the prop
					int $foundPropRef = false;
					for ($ref in $refNodes){
						if ($foundPropRef == false){
							string $namespace2 = `file -q -namespace $ref`;
							if ($namespace2 == $propName){
								$foundPropRef = true;
							}
						}
					}
					
					if ($foundPropRef == false){
						//print ("Reference to Prop not Found: "+$propName+"\n");
						$requiredProps[size($requiredProps)] = $propName;
					}
				}
			}


			if (size($requiredProps)>0){
				string $requiredPropsStr = stringArrayToString($requiredProps, ", ");
				$result = `confirmDialog -title "abxShots: Requires Prop References" -message ("The Asset: "+$namespace+" requires the following props: "+$requiredPropsStr+". Would you like to automatically reference and place these props in your scene? (You can also run this check manually in the Shot Manager Tools Menu)") -button "Yes, Reference Missing Props" -button "Not Right Now" -defaultButton "Yes, Reference Missing Props" -dismissString "Not Right Now"`;
				if ($result == "Yes, Reference Missing Props"){
					for ($each in $requiredProps){
						$assetNameGuess = `match "[a-zA-Z]+" $each`;
						string $assetPath = ("assets/props/"+$assetNameGuess);
						//$newRef = abxAssetsRefAsset($assetPath,0);
						$refFile = (`workspace -q -rd`+"assets/props/"+$assetNameGuess+"/_publish/"+$assetNameGuess+".mb");
						string $newRef = abxAssetsCreateReference($refFile,$each,"namespace",0);
						$newRefNamespace = `file -q -namespace $newRef`;
						string $locatorName = ($namespace+":geo__PROP_"+$each);
						if (!`objExists $locatorName`)
							$locatorName +="_";

						if (!`objExists _PROPS_`)
							createNode transform -ss -name "_PROPS_" ;
						parent ($newRefNamespace+":ROOT") _PROPS_;

						// find instances for this object and create in-scene locators and snap to them
						$instances = `ls -type transform ($locatorName+"*INST*")`;
						//print ("Checking for instances named "+$locatorName+"*INST*\n;");
						string $every;
						for ($every in $instances){
							string $prefix = ($namespace+":");
							$instLocName = `substitute $prefix $every ""`;
							if (!`objExists $instLocName`){
								$newLoc = `spaceLocator -name $instLocName`;
								$instLocName = $newLoc[0];
								parent $instLocName _PROPS_;
								$trans = `xform -q -a -ws -t $every`;
								$rot = `xform -q -a -ws -ro $every`;
								$scl = `xform -q -r -s $every`;
								xform -a -ws -t $trans[0] $trans[1] $trans[2] $instLocName;
								xform -a -ws -ro $rot[0] $rot[1] $rot[2] $instLocName;
								xform -s $scl[0] $scl[1] $scl[2] $instLocName;
							}
							string $instRenamePrefix = `substitute "geo__PROP_" $instLocName ""`;
							$instRenamePrefix = `substitute "_PROP_" $instRenamePrefix ""`;
							$dupeROOT = `duplicate -po -name ($instRenamePrefix+"ROOT") ($newRefNamespace+":ROOT")`;
							$dupeMOVER = `duplicate -po -name ($instRenamePrefix+"MOVER") ($newRefNamespace+":MOVER")`;
							$newInst = `instance -name ($instRenamePrefix+"BODY") ($newRefNamespace+":BODY")`;
							$newInstGeo = `instance -name ($instRenamePrefix+"GEO") ($newRefNamespace+":GEO")`;
							evalEcho("parent -r "+$dupeMOVER[0]+" "+$dupeROOT[0]);
							evalEcho("parent -r "+$newInst[0]+" "+$dupeMOVER[0]);
							evalEcho("parent -r "+$newInstGeo[0]+" "+$dupeROOT[0]);
							evalEcho("parent -r "+$dupeROOT[0]+" "+$instLocName);
							setAttr ($instLocName+".overrideEnabled") 1;
							setAttr ($instLocName+".overrideColor") 3;
						}

						if (`objExists $locatorName`){
							$trans = `xform -q -a -ws -t $locatorName`;
							$rot = `xform -q -a -ws -ro $locatorName`;
							$scl = `xform -q -r -s $locatorName`;
							xform -a -ws -t $trans[0] $trans[1] $trans[2] ($newRefNamespace+":ROOT");
							xform -a -ws -ro $rot[0] $rot[1] $rot[2] ($newRefNamespace+":ROOT");
							xform -s $scl[0] $scl[1] $scl[2] ($newRefNamespace+":ROOT");
						}
						else {
							warning ("No Locator Named:"+$locatorName+" unable to snap "+$each+"\n");
						}
					}

				}
			}
			else {
				print ("No Missing Props Found for Asset:"+$namespace+"\n");
			}
		}
	}
}


global proc abxAssetsUpdatePropInstances(string $refNodes[], int $forceRebuild){
	if (size($refNodes)==1 && $refNodes[0] == "")
		$refNodes = `file -q -r`;

	string $validatedInstLoc[];

	for ($each in $refNodes){

		string $refNodeName = `referenceQuery -rfn $each`;
		string $filePathWCN = `referenceQuery -filename -wcn $each`;
		string $namespace = `file -q -namespace $each`;
		print ("CHECKING ASSET: "+$namespace+" for INST\n");
		string $locatorName = ($namespace+":geo__PROP_");
		$instances = `ls -type transform ($locatorName+"*INST*")`;
		print ("SEARCHING FOR: "+$namespace+":geo__PROP_"+$namespace+"*INST*"+"\n");
		string $every;

		// for all found INST locators in the referenced set create and validate an in-scene instance of that prop
		for ($every in $instances){
			print ("INST FOUND : "+$every+"\n");
			string $prefix = ($namespace+":geo__PROP_");
			string $oldPrefix = ($namespace+":");
			$instOldLocNameStyle = `substitute $oldPrefix $every ""`;
			$instLocName = `substitute $prefix $every ""`;
			if (`objExists $instOldLocNameStyle`)
				rename $instOldLocNameStyle $instLocName;

			// extract the instanced assets namespace from the name of the locator
			string $instAssetNamespace = `substitute "geo__PROP_" $instLocName ""`;
			string $tokenBuffer[];
			tokenize $instAssetNamespace "_" $tokenBuffer;
			$instAssetNamespace = $tokenBuffer[0];

			int $skipRebuild = false;

			if (!`objExists $instLocName`){
				$newLoc = `spaceLocator -name $instLocName`;
				$instLocName = $newLoc[0];
				parent $instLocName _PROPS_;
				$trans = `xform -q -a -ws -t $every`;
				$rot = `xform -q -a -ws -ro $every`;
				$scl = `xform -q -r -s $every`;
				xform -a -ws -t $trans[0] $trans[1] $trans[2] $instLocName;
				xform -a -ws -ro $rot[0] $rot[1] $rot[2] $instLocName;
				xform -s $scl[0] $scl[1] $scl[2] $instLocName;				
			}
			else{
				// delete any old-style children of the instance (child is named ROOT1, ROOT2 etc.)
				string $instChild[] = `listRelatives -children $instLocName`;
				for ($c in $instChild){
					if (`gmatch $c "ROOT*"`){
						delete $c;
					}
					if (`gmatch $c ($instLocName+"ROOT")`){
						if ($forceRebuild == false)
							$skipRebuild = true;
						else
							delete $c;
					}
				}
			}
			if ($skipRebuild == false){
				if (!`objExists $instLocName`){
					string $instRenamePrefix = `substitute "geo__PROP_" $instLocName ""`;
					$instRenamePrefix = `substitute "_PROP_" $instRenamePrefix ""`;
					$dupeROOT = `duplicate -po -name ($instRenamePrefix+"ROOT") ($instAssetNamespace+":ROOT")`;
					$dupeMOVER = `duplicate -po -name ($instRenamePrefix+"MOVER") ($instAssetNamespace+":MOVER")`;
					$newInst = `instance -name ($instRenamePrefix+"BODY") ($instAssetNamespace+":BODY")`;
					$newInstGeo = `instance -name ($instRenamePrefix+"GEO") ($instAssetNamespace+":GEO")`;
					evalEcho("parent -r "+$dupeMOVER[0]+" "+$dupeROOT[0]);
					evalEcho("parent -r "+$newInst[0]+" "+$dupeMOVER[0]);
					evalEcho("parent -r "+$newInstGeo[0]+" "+$dupeROOT[0]);
					evalEcho("parent -r "+$dupeROOT[0]+" "+$instLocName);
					setAttr ($dupeROOT[0]+".translate") 0 0 0;
					setAttr ($dupeROOT[0]+".rotate") 0 0 0;			
					setAttr ($instLocName+".overrideEnabled") 1;
					setAttr ($instLocName+".overrideColor") 3;
				}
			}

			$validatedInstLoc[size($validatedInstLoc)] = $instLocName;
		}
		
	}

	// check validated INST locators (ones that were actually still existing in sets) and compare
	// against all found INST locators. Rename and HIDE the ones that were not validated
	$allFoundInstLocs = `ls -type transform "*_INST_*"`;

	for ($each in $allFoundInstLocs){
		$shapes = `listRelatives -shapes $each`;
		if (size($shapes)>0){
			if (`objectType $shapes[0]` == "locator"){
				if (!stringArrayContains($each,$validatedInstLoc)){
					if (!`gmatch $each "LOST_*"`){
						hide $each;
						rename $each ("LOST_"+$each);
					}
				}
			}
		}
	}
}

// parses the PREVIS and _ALL_SHOTS details.txt to see what shots use the asset.
global proc abxAssetsAnalyzeUse (string $assetPath){

    //string $assetPath = "assets/characters/Tessa";

	string $pubDirGuess = (`workspace -q -rd` + $assetPath + "/_publish/");
	string $previsDir = (`workspace -q -rd` + "scenes/_PREVIS/");
	string $allShotsDir = (`workspace -q -rd` + "scenes/_ALL_SHOTS/");
	string $previsShots[];
	string $allshotsShots[];

	string $preSeq[] = `getFileList -folder $previsDir`;

	string $allShotsSeq[] = `getFileList -folder $allShotsDir`;
	for ($each in $allShotsSeq){
		if ($each != "old" && $each != "archive" && $each != "OLD"){
			string $seqShots[] = `getFileList -folder ($previsDir+$each+"/")`;
			for ($every in $seqShots){
				string $shotDetails[] = abxShotsGetShotDetails(($each+"/"+$every), "_ALL_SHOTS");
				if (`gmatch $shotDetails[13] ("*"+$assetPath+"*")`)
					$allShotsSeq[size($allShotsSeq)] = $every;
			}
		}
	}

	//print ("Asset: "+$assetPath+" used in "+size($previsShots)+" _PREVIS shots\n");
	//print $previsShots;
	print ("Asset: "+$assetPath+" used in "+size($allShotsSeq)+" _ALL_SHOTS shots\n");
	print $allShotsSeq;
}

global proc abxAssetsTexPathReplace(string $find, string $replace){

	$files = `ls -type file`;
string $each;
for ($each in $files){
    string $oldPath = `getAttr ($each+".ftn")`;
    $newPath = substitute($find,$oldPath,$replace);
    setAttr -type "string" ($each+".ftn") $newPath;
}

} 