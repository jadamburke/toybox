// maya2VRay.mel// Version 1.0// by Paul Dreisen paul@dryzen.com/*	Usage:	This script converts the most used shaders from Maya and Maya + MR (Mia material) into a VRay Material.	The scripts scans the most common used inputs of your shader and connects them to a new VRay shader.	After all the connections are made it connects the VRay shader into the shading group of the old material, so it will work with renderpass assignements etc.	Limitations:	!!!	If you want to convert a mia shader you must first use the upgrade feature of Maya to convert it into a mia_material_passes_x!!!	Due to the fact that some inputs (incandescence; ambientColor and some more) are not present in the VRay material, those connections are going to be lost.	Complex shading networks with multiple shaders cannot be converted with this script. Those networks need to be converted one shader at a time!	It is not possible to convert/connect the inputs that they look completely the same with the VRay shader, but the look will go in the right direction.How to:	1. select any Mia material you want. If it is an old material like MiaX, Mia, or Mia_material_pass use the upgrade feature in the attribute Editor.	2. upgrade the material into a "mia_material_x_passes" (you can find the upgrade button insde the attribute editor) 	3. run the script. The script works with any number of shaders, but I suggest to do it only with one at a time ;-)	4. If you are converting normal Maya shader, there is no need to change everything. Right now the script converts only Blinn, Lamber and Phong shaders!Install:		Copy the script to your scripts folder, source and run it.		source maya2VRay.mel;		maya2VRay.mel;Version:		1.0	First version of the script. It can convert Lambert, Blinn, Phong and Mia_material_pass_x tinto a VRay material.				I hope the script will save you some time on the scene conversion. If there is any problem or something you would like to have, please contact me!Thanks Paul*/global proc maya2VRay(){	// get selected shaders		string $sel[] = `ls -sl -st`;		for ($i=0;$i<size($sel);$i=$i+2)	{		// $i=$i+2 takes every second string and runs the script		// $sel[$i]=object		// $sel[$i+1]=objectType			if ($sel[$i+1] == "lambert")		{				print ("\n");			print ("running Lambert conversion on " + $sel[$i] + " hold on tight");			lambert2VRay($sel[$i]);		}	else if ($sel[$i+1] == "blinn")		{					print ("\n");			print ("running Blinn conversion on " + $sel[$i] + " hold on tight");			blinn2VRay($sel[$i]);		}	else if ($sel[$i+1] == "phong")		{				print ("\n");			print ("running Phong conversion on " + $sel[$i] + " hold on tight");			phong2VRay($sel[$i]);		}	else if ($sel[$i+1] == "mia_material_x_passes")		{				print ("\n");			print ("running Mia conversion on " + $sel[$i] + " hold on tight");			mia2VRay($sel[$i]);		}	}	}// now the sub scripts for the different shading networks.	global proc lambert2VRay(string $obj){		// first create a new VRay material	$newMtl=`shadingNode -as -n ($obj +"_VRAY") VRayMtl`;				// use this string to fill up all the needed connections. It works like this 1. Value = the input of the source shader like lambert.diffuse		// and the second value is the input of the ne VRay material like VRayMat1.diffuseColor		// You can easily add new connections if you need them, just add them at the end of the next string $conMap[], but allways use 2 values	// note: You will need 2 arrays: one for alle connections with 3 RGB inputs and the second array with all the alpha or single value inputs		// start with the ones with 3 inputs!!				string $conMap[] = {".color", ".diffuseColor"};		string $conMapSingle[] = {".diffuse", ".diffuseColorAmount"};				for ($i=0;$i<size($conMap);$i=$i+2)	{			string $conn=`connectionInfo -sfd ($obj + $conMap[$i])`;	if ($conn=="")		{			float $tmp[]=`getAttr ($obj + $conMap[$i])`;			setAttr ($newMtl+$conMap[$i+1]) -type double3 $tmp[0] $tmp[1] $tmp[2];		}	else		{		connectAttr -f $conn ($newMtl + $conMap[$i+1]);		}	}				for ($i=0;$i<size($conMapSingle);$i=$i+2)		{		string $connSingle=`connectionInfo -sfd ($obj + $conMapSingle[$i])`;		print $connSingle;	if ($connSingle=="")		{			float $tmp=`getAttr ($obj + $conMapSingle[$i])`;			setAttr ($newMtl + $conMapSingle[$i+1]) $tmp;		}	else		{			connectAttr -f $connSingle ($newMtl + $conMapSingle[$i+1]);		}	}// next step the bump connection, wasn´t possible to do it with the other connections	string $bump[] = `listConnections -d off -s on ($obj +".normalCamera")`;			if ($bump[0]=="")			{				print ("\n");	print "no bump connected";print ("\n");			}		else			{				string $bumpcon=`connectionInfo -sfd ($bump[0] +".bumpValue")`;				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapR");				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapG");				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapB");				float $bumpdepth=`getAttr ($bump[0]+".bumpDepth")`;				setAttr ($newMtl+".bumpMult") $bumpdepth;			}	// get the connection of the transparency of the Maya shader	string $trans = `connectionInfo -sfd ($obj +".transparency")`;			if ($trans=="")			{				// if there is only a value it needs to be reversed!!! this will work good with no colors here, but could lead to strange results with colored transparency values!!!				float $tmp[]=`getAttr ($obj + ".transparency")`;				float $tmpR = $tmp[0] * -1 +1;				float $tmpG = $tmp[1] * -1 +1;				float $tmpB = $tmp[2] * -1 +1;				setAttr ($newMtl + ".opacityMap") -type double3 $tmpR $tmpG $tmpB;											}		else			{				// if there is a connected texture we need a reverse node to make the transparency work with the VRay shader, it has the same problem with colored transparency, but hopefully it will work a bit.				$reverse=`shadingNode -au -n ($obj +"REVERSE") reverse`;				connectAttr -f $trans ($reverse +".input");				connectAttr -f ($reverse + ".output") ($newMtl +".opacityMap");			}// find the shading group and connect the new VRay shader	string $SG[] = `listConnections -t shadingEngine $obj`;	connectAttr -f ($newMtl +".outColor") ($SG[0] +".surfaceShader");// delete the original shader	delete $obj;}global proc blinn2VRay(string $obj){		// first create a new VRay material	$newMtl=`shadingNode -as -n ($obj +"_VRAY") VRayMtl`;				// use this string to fill up all the needed connections. It works like this 1. Value = the inpuet of the source shader like lambert.diffuse		// and the second value is the input of the ne VRay material like VRayMat1.diffuseColor		// You can easily add new connections if you need them, just add them at the end of the next string $conMap[], but allways use 2 values	// note: You will need 2 arrays: one for alle connections with 3 RGB inputs and the second array with all the alpha or single value inputs		// start with the ones with 3 inputs!!						string $conMap[] = 	{	".color", ".diffuseColor",						".reflectedColor", ".reflectionColor",						".specularColor", ".reflectionColor" 					};		string $conMapSingle[] = 	{	".diffuse", ".diffuseColorAmount",							".reflectivity", ".reflectionColorAmount",							".eccentricity", ".reflectionGlossiness"						};				for ($i=0;$i<size($conMap);$i=$i+2)	{			string $conn=`connectionInfo -sfd ($obj + $conMap[$i])`;	if ($conn=="")		{			float $tmp[]=`getAttr ($obj + $conMap[$i])`;			setAttr ($newMtl+$conMap[$i+1]) -type double3 $tmp[0] $tmp[1] $tmp[2];		}	else		{		connectAttr -f $conn ($newMtl + $conMap[$i+1]);		}	}				for ($i=0;$i<size($conMapSingle);$i=$i+2)		{		string $connSingle=`connectionInfo -sfd ($obj + $conMapSingle[$i])`;		print $connSingle;	if ($connSingle=="")		{			float $tmp=`getAttr ($obj + $conMapSingle[$i])`;			setAttr ($newMtl + $conMapSingle[$i+1]) $tmp;		}	else		{			connectAttr -f $connSingle ($newMtl + $conMapSingle[$i+1]);		}	}// next step the bump connection, wasn´t possible to do it with the other connections	string $bump[] = `listConnections -d off -s on ($obj +".normalCamera")`;			if ($bump[0]=="")			{				print ("\n");	print "no bump connected";print ("\n");			}		else			{				string $bumpcon=`connectionInfo -sfd ($bump[0] +".bumpValue")`;				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapR");				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapG");				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapB");				float $bumpdepth=`getAttr ($bump[0]+".bumpDepth")`;				setAttr ($newMtl+".bumpMult") $bumpdepth;			}	// get the connection of the transparency of the Maya shader	string $trans = `connectionInfo -sfd ($obj +".transparency")`;			if ($trans=="")			{				// if there is only a value it needs to be reversed!!! this will work good with no colors here, but could lead to strange results with colored transparency values!!!				float $tmp[]=`getAttr ($obj + ".transparency")`;				float $tmpR = $tmp[0] * -1 +1;				float $tmpG = $tmp[1] * -1 +1;				float $tmpB = $tmp[2] * -1 +1;				setAttr ($newMtl + ".opacityMap") -type double3 $tmpR $tmpG $tmpB;											}		else			{				// if there is a connected texture we need a reverse node to make the transparency work with the VRay shader, it has the same problem with colored transparency, but hopefully it will work a bit.				$reverse=`shadingNode -au -n ($obj +"REVERSE") reverse`;				connectAttr -f $trans ($reverse +".input");				connectAttr -f ($reverse + ".output") ($newMtl +".opacityMap");			}// some basic settings for the new shader to match the look of the Maya blinnsetAttr ($newMtl+".useFresnel") 1;// find the shading group and connect the new VRay shader	string $SG[] = `listConnections -t shadingEngine $obj`;	connectAttr -f ($newMtl +".outColor") ($SG[0] +".surfaceShader");// delete the original shader	delete $obj;}global proc phong2VRay(string $obj){		// first create a new VRay material	$newMtl=`shadingNode -as -n ($obj +"_VRAY") VRayMtl`;				// use this string to fill up all the needed connections. It works like this 1. Value = the inpuet of the source shader like lambert.diffuse		// and the second value is the input of the ne VRay material like VRayMat1.diffuseColor		// You can easily add new connections if you need them, just add them at the end of the next string $conMap[], but allways use 2 values	// note: You will need 2 arrays: one for alle connections with 3 RGB inputs and the second array with all the alpha or single value inputs		// start with the ones with 3 inputs!!						string $conMap[] = 	{	".color", ".diffuseColor",						".reflectedColor", ".reflectionColor",						".specularColor", ".reflectionColor" 					};		string $conMapSingle[] = 	{	".diffuse", ".diffuseColorAmount",							".reflectivity", ".reflectionColorAmount"						};				for ($i=0;$i<size($conMap);$i=$i+2)	{			string $conn=`connectionInfo -sfd ($obj + $conMap[$i])`;	if ($conn=="")		{			float $tmp[]=`getAttr ($obj + $conMap[$i])`;			setAttr ($newMtl+$conMap[$i+1]) -type double3 $tmp[0] $tmp[1] $tmp[2];		}	else		{		connectAttr -f $conn ($newMtl + $conMap[$i+1]);		}	}				for ($i=0;$i<size($conMapSingle);$i=$i+2)		{		string $connSingle=`connectionInfo -sfd ($obj + $conMapSingle[$i])`;		print $connSingle;	if ($connSingle=="")		{			float $tmp=`getAttr ($obj + $conMapSingle[$i])`;			setAttr ($newMtl + $conMapSingle[$i+1]) $tmp;		}	else		{			connectAttr -f $connSingle ($newMtl + $conMapSingle[$i+1]);		}	}// next step the bump connection, wasn´t possible to do it with the other connections	string $bump[] = `listConnections -d off -s on ($obj +".normalCamera")`;			if ($bump[0]=="")			{				print ("\n");	print "no bump connected";print ("\n");			}		else			{				string $bumpcon=`connectionInfo -sfd ($bump[0] +".bumpValue")`;				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapR");				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapG");				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapB");				float $bumpdepth=`getAttr ($bump[0]+".bumpDepth")`;				setAttr ($newMtl+".bumpMult") $bumpdepth;			}	// get the connection of the transparency of the Maya shader	string $trans = `connectionInfo -sfd ($obj +".transparency")`;			if ($trans=="")			{				// if there is only a value it needs to be reversed!!! this will work good with no colors here, but could lead to strange results with colored transparency values!!!				float $tmp[]=`getAttr ($obj + ".transparency")`;				float $tmpR = $tmp[0] * -1 +1;				float $tmpG = $tmp[1] * -1 +1;				float $tmpB = $tmp[2] * -1 +1;				setAttr ($newMtl + ".opacityMap") -type double3 $tmpR $tmpG $tmpB;											}		else			{				// if there is a connected texture we need a reverse node to make the transparency work with the VRay shader, it has the same problem with colored transparency, but hopefully it will work a bit.				$reverse=`shadingNode -au -n ($obj +"REVERSE") reverse`;				connectAttr -f $trans ($reverse +".input");				connectAttr -f ($reverse + ".output") ($newMtl +".opacityMap");			}// get the cosingePower of the phong shader and convert the value to match the VRay shader values			float $cosPower=`getAttr ($obj + ".cosinePower")`;			setAttr ($newMtl + ".reflectionGlossiness") ($cosPower / 100);// some basic settings for the new shader to match the look of the Maya blinnsetAttr ($newMtl+".useFresnel") 1;setAttr ($newMtl+".brdfType") 0;// find the shading group and connect the new VRay shader	string $SG[] = `listConnections -t shadingEngine $obj`;	connectAttr -f ($newMtl +".outColor") ($SG[0] +".surfaceShader");// delete the original shader	delete $obj;}global proc mia2VRay(string $obj){		// first create a new VRay material			$newMtl=`shadingNode -as -n ($obj +"_VRAY") VRayMtl`;				// use this string to fill up all the needed connections. It works like this 1. Value = the inpuet of the source shader like lambert.diffuse		// and the second value is the input of the ne VRay material like VRayMat1.diffuseColor		// You can easily add new connections if you need them, just add them at the end of the next string $conMap[], but allways use 2 values		// note: You will need 2 arrays: one for alle connections with 3 RGB inputs and the second array with all the alpha or single value inputs		// start with the ones with 3 inputs!!				string $conMap[] = {	".diffuse", ".diffuseColor", 					".refl_color", ".reflectionColor",					".refr_color", ".refractionColor", 					".refr_falloff_color", ".fogColor" };		// single value link connections source first, then input		string $conMapSingle[] = {	".diffuse_weight", ".diffuseColorAmount", 						".diffuse_roughness", ".roughnessAmount", 						".reflectivity", ".reflectionColorAmount", 						".refl_gloss", ".reflectionGlossiness", 						".transparency", ".refractionColorAmount", 						".refr_ior", ".refractionIOR", 						".refr_gloss", ".refractionGlossiness"};				for ($i=0;$i<size($conMap);$i=$i+2)	{			string $conn=`connectionInfo -sfd ($obj + $conMap[$i])`;	if ($conn=="")		{			float $tmp[]=`getAttr ($obj + $conMap[$i])`;			setAttr ($newMtl+$conMap[$i+1]) -type double3 $tmp[0] $tmp[1] $tmp[2];		}	else		{		connectAttr -f $conn ($newMtl + $conMap[$i+1]);		}	}				for ($i=0;$i<size($conMapSingle);$i=$i+2)		{		string $connSingle=`connectionInfo -sfd ($obj + $conMapSingle[$i])`;		print $connSingle;	if ($connSingle=="")		{			float $tmp=`getAttr ($obj + $conMapSingle[$i])`;			setAttr ($newMtl + $conMapSingle[$i+1]) $tmp;		}	else		{			connectAttr -f $connSingle ($newMtl + $conMapSingle[$i+1]);		}}// get the bump connection for the overal bump slot	string $bump[] = `listConnections -d off -s on ($obj +".overall_bump")`;	string $bump1[] = `listConnections -d off -s on ($obj +".standard_bump")`;				if ($bump[0]=="")				{										print "no overal bump connected checking standard bump";					print ("\n");									}			else				{					string $bumpcon=`connectionInfo -sfd ($bump[0] +".bumpValue")`;					print $bumpcon;					print ("\n");						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapR");						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapG");						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapB");						float $bumpdepth=`getAttr ($bump[0]+".bumpDepth")`;						print $bumpdepth;						setAttr ($newMtl+".bumpMult") $bumpdepth;				}			if ($bump1[0]=="")				{										print "no bump connected";					print ("\n");									}			else				{					string $bumpcon=`connectionInfo -sfd ($bump1[0] +".bumpValue")`;											connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapR");						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapG");						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapB");						float $bumpdepth=`getAttr ($bump1[0]+".bumpDepth")`;						setAttr ($newMtl+".bumpMult") $bumpdepth;				}// find the shading group	string $SG[] = `listConnections -t shadingEngine $obj`;	print $SG[0];// connect the VRay shader to the shading group	connectAttr -f ($newMtl +".outColor") ($SG[0] +".surfaceShader");// delete the mia shader// delete $obj;}